// VLISP - Feb 06 - by Sylvain Huet
// Metal

proto main 0;;
proto setRunState 1;;
proto getRunState 0;;

// XMPP ECHO DEBUG
fun Xw str = 
	Secholn str;;
fun Xx i = 
	Iecholn i;;

// ping echo debug
fun Pingw str = nil;; //Secholn str;;

// dns echo debug
fun Dnsw str = nil;; //Secholn str;;

// programs debug
fun Progw str = nil;; //Secholn strcatlist "[program] " :: str :: nil;;

// streaming debug
fun Streamw str = nil;; //Secholn strcatlist "[streaming] " :: str :: nil;;

// #define SIMU

// set doPing to something else than nil to activate ping
var doPing = nil ;;



const HARDWARE=4;;

proto buttoncheckevent 0;;

//
// Etats generaux
var gItState = 0;;			// interactif
var gSleepState = 1;;		// sleeping
var gStreamingState = 0;;	// streaming
var gProcessingState = 0;; 	// processing a program
var gProcessingWaitState = 0;;  // executing a "wait" command in a program. when checking this var, check gProcessingState first, as it is not always reseted to 0
var gBusyState = 0;;		// busy (incoming message queue full)
var gItApp = nil;;			// the name of the interactive application
var gEarInited = 0;;		// si les oreilles ont ÈtÈ initialisÈes.
var gRegistrationError = 0;;// registration error during login

proto itNoteEarTouched 3;;
proto processIncomingTrame 3;;
proto dumpStatus 0;;

// file net_vars.mtl //
var netip="\0\0\0\0";;
var netmask="\255\255\255\0";;
var netgateway="\0\0\0\0";;
var netdnslist=nil;;

var mymac;;

const macbroadcast="\$ff\$ff\$ff\$ff\$ff\$ff";;
const ipbroadcast="\$ff\$ff\$ff\$ff";;

const netip_empty="\0\0\0\0";;

const netip_master="\192\168\2\1";;
const netmask_master="\255\255\255\0";;
const netgateway_master="\192\168\0\1";;
// end of file net_vars.mtl //
// back to file STDIN, line 60

const BYTECODE_REVISION_STR = "$Rev: 21029 $";;
fun getBytecodeRevision =
	strsub BYTECODE_REVISION_STR 6 ((strlen BYTECODE_REVISION_STR) - 8);;


// file utils.mtl //
//fun strcmp a b = vstrcmp a 0 b 0 nil;;
fun strstr s p i=strfind s i p 0 nil;;
fun itoanil l=if l==nil then '0'::nil else l;;
fun listlen l=if l==nil then 0 else 1+listlen tl l;;
fun listrem l x=if l!=nil then if x==hd l then tl l else (hd l)::listrem tl l x;;
fun slistlen l=	if l==nil then 0 else (strlen hd l)+slistlen tl l;;
fun listnth l i=if !i then hd l else if i>0 then listnth tl l i-1;;


/**
	Extracts a number from a string, according to the length used the
number of bytes it is encoded on. (1, 2, 4)
*/
fun strgetnum src i nbbytes =
	if (nbbytes == 1) then
		strget src i
	else if (nbbytes == 2) then
		strgetword src i
	else if (nbbytes == 4) then
		(strgetword src i) * 65536 + (strgetword src i+2)
;;

fun listtostr l=
	let strnew listlen l -> s in
	let 0->i in
	(
		for p=l;p!=nil;tl p do
		(
			strset s i hd p;
			set i=i+1
		);
	s
	);;

fun atoibin2 val=itobin2 atoi val;;

fun countpattern s p i=
	let strstr s p i -> j in
	if j==nil then 0
	else 1+countpattern s p j+strlen p;;

fun strreplace2 sn s p v i id=
	if i<strlen s then
	let strstr s p i -> j in
	let if j==nil then strlen s else j -> k in
	(
		strcpy sn id s i k-i;
		if j!=nil then strcpy sn id+k-i v 0 nil;
		strreplace2 sn s p v k+strlen p id+k-i+strlen v
	);;
	
fun strreplace s p v=
	let countpattern s p 0 -> i in
	if !i then s
	else let strnew (strlen s) + ((strlen v)-(strlen p))*i -> sn in
	(
		strreplace2 sn s p v 0 0;
		sn
	);;


fun rev p q=if p==nil then q else rev tl p (hd p)::q;;

fun remfromlist l t= if l!=nil then if t==hd l then tl l else (hd l)::remfromlist tl l t;;

fun insert x l f=
	if l==nil then x::nil
	else let call f [x hd l] -> r in
	if r>0 then (hd l)::insert x tl l f
	else if r<0 then x::l
	else insert x tl l f;;

fun sort l f= if l!=nil then insert hd l sort tl l f f;;

fun select l a f= if l!=nil then let hd l-> x in if call f [x a] then x::select tl l a f else select tl l a f;;

fun conc p q=if p==nil then q else (hd p)::conc tl p q;;

fun random n= ((rand&255)*n)>>8;; // nombre entre 0 et n-1 inclus

fun _useparamip s i val j=
	if i<4 then
	let strstr val "." j -> k in
	(
		strset s i atoi strsub val j if k==nil then nil else k-j;
		_useparamip s i+1 val if k==nil then strlen val else k+1
	);;

fun useparamip val=
	let strnew 4 -> ip in
	(
		_useparamip ip 0 val 0;
		ip
	);;

fun webip ip=
	strcatlist (itoa strget ip 0)::"."::(itoa strget ip 1)::"."::(itoa strget ip 2)::"."::(itoa strget ip 3)::nil;;

/***
	like strcmp, but for ip addresses
*/
fun ipcmp a b =
	strcmp (strsub a 0 4) (strsub b 0 4);;

// Ceci s'appelait webmac avant, mais il y a avait un conflit : 2 fonctions webmac.. J'ai renomm√© en fonction de la pr√©c√©dence dans le fichier source.
fun _fullwebmac key i=
	if i<strlen key then (ctoh strget key i)::if i+1<strlen key then ":"::_fullwebmac key i+1 else _fullwebmac key i+1;;
fun fullwebmac key=strcatlist _fullwebmac key 0;;

// "001904031Dcc"
fun _webmac key i=
	if i<strlen key then (ctoh strget key i)::_webmac key i+1;;
fun webmac key=strcatlist _webmac key 0;;

/* Si une chaine commence par un '\0', la remplace par une chaine vide */
fun makestremptyifzero s =
	if 0 == strget s 0 then "" else s ;;


fun AsciiToInt asccode =
	if asccode <= 57 then // '9' /  
		asccode - 48 // '0' 
	else if asccode <= 70 then // 'F' 
		asccode - 55 // 'F' - 15 
	else asccode - 87 // 'f' - 15 
;;

fun IntToAscii intval =
	if intval < 10 then
		intval + 48	// '0' 
	else
		intval + 87	// 'f' - 15 
;;

fun XorHexStr str1 str2 =
	let strlen str1 -> length in
	let strnew length -> result in (
	for i=0; i<length do (
        		let strget str1 i -> ch1 in
			let strget str2 i -> ch2 in
			let AsciiToInt ch1 -> int1 in
			let AsciiToInt ch2 -> int2 in
			let IntToAscii (int1 ^ int2) -> intval in (
        			strset result i intval
			)
	);
	result )
;;


/** splits a number in the form of 4 bytes into a couple [ highBytes, lowBytes ] */
fun seqSplitHighLow s =
	[ (strgetnum s 0 2) (strgetnum s 2 2) ]
;;

/* helper fun for seqHighLowCmp */
fun seqHighLowCmpHelper a b =
	if (a > b) then 1 else if (a == b) then 0 else -1 ;;

/* returns 1 if s1 > s2, 0 if s1==s2, -1 if s1 < s2 */
fun seqHighLowCmp s1 s2 =
	let s1 -> [ h1 l1 ] in
	let s2 -> [ h2 l2 ] in
	let seqHighLowCmpHelper h1 h2 -> res1 in
		if 0 == res1 then seqHighLowCmpHelper l1 l2 else res1
;;

/* converts raw data to a printable form */
fun dataToHexStr s =
	let strlen s -> len in
	let strnew (2*len) -> res in
	(
		for i=0 ; i< len do
			strcpy res (2*i) (ctoh strget s i) 0 2;
		res
	)
;;



fun MACecho src i0 ln=
	for i=0;i<6 do (Secho ctoh strget src i0+i; Secho ".");	if ln then Secholn "";
	src;;

fun SEQecho src i0 ln=
	for i=0;i<4 do (Secho ctoh strget src i0+i; Secho ".");	if ln then Secholn "";
	src;;

fun IPecho src i0 ln=
	for i=0;i<4 do (Iecho strget src i0+i; Secho ".");if ln then Secholn "";
	src;;

fun itoh4 i = strcatlist (ctoh i>>24)::(ctoh i>>16)::(ctoh i>>8)::(ctoh i)::nil;;

fun strputchk s i w=
	strset s i ~(w>>8);
	strset s i+1 ~w;
	0;;

fun dump s=
	for i0=0;i0<strlen s;i0+16 do
	(
		Secho itoh4 i0;
		Secho " ";
		for i=0;i<16 do let strget s i0+i -> c in
		(
			Secho if c==nil then "  " else ctoh c;
			Secho " "
		);
		Secho " ";
		for i=0;i<16 do let strget s i0+i -> c in
		(
			Secho if c==nil then "  " else if c<32 then "." else ctoa c
		);
		Secholn ""
	);

	s;;
// end of file utils.mtl //
// back to file STDIN, line 67
// file leds.mtl //
// file leds_protos.mtl //
/** met toutes les leds du lapin dans la couleur rgbCode */
proto setleds 1 ;; // rgbCode

/** constantes qui pour les leds du lapin */
const LED_NOSE = 0 ;;
const LED_BODY_LEFT = 1 ;;
const LED_BODY_MIDDLE = 2 ;;
const LED_BODY_RIGHT = 3 ;;
const LED_BASE = 4 ;;

/** diff√©rents √©tats dans lesquels les leds sont dans un √©tat particulier */
type TLedsState = LEDS_STATE_START  | LEDS_STATE_CONFIG_WAIT | LEDS_STATE_XMPP_OPENING_XMPP_TCP | LEDS_STATE_XMPP_OPENING_XMPP_BOSH | LEDS_STATE_XMPP_OPENING_XMPP | LEDS_STATE_XMPP_CONNECTED ;;

/** place les leds du lapin dans la configuration correspondant √† state */
proto leds_set_state 1 ;; // TLedState state

// file colors.mtl //
/** (some) colors that can be used for the leds */

const RGB_WHITE  = 0xffffff ;;
const RGB_BLACK  = 0x000000 ;;
const RGB_RED    = 0xff0000 ;;
const RGB_BLUE   = 0x0000ff ;;
const RGB_GREEN  = 0x00ff00 ;;
const RGB_AMBER  = 0xff8000 ;;
const RGB_VIOLET = 0xff00ff ;;
// end of file colors.mtl //
// back to file leds_protos.mtl, line 17
// end of file leds_protos.mtl //
// back to file leds.mtl, line 1

fun setleds col= for i=0;i<5 do led i col;;

var leds_currentState = nil ;;

fun leds_set_state state =
	if (leds_currentState != state) then
	(
		set leds_currentState = state;
		match state with
			 (LEDS_STATE_START -> setleds RGB_BLACK; led LED_NOSE RGB_BLUE)
			|(LEDS_STATE_CONFIG_WAIT -> setleds RGB_BLACK; led LED_BODY_LEFT RGB_BLUE)
			|(LEDS_STATE_XMPP_OPENING_XMPP_TCP -> setleds RGB_BLACK; led LED_BODY_MIDDLE RGB_BLUE)
			|(LEDS_STATE_XMPP_OPENING_XMPP_BOSH -> setleds RGB_BLACK; led LED_BODY_MIDDLE RGB_AMBER)
			|(LEDS_STATE_XMPP_OPENING_XMPP -> setleds RGB_BLACK; led LED_BODY_MIDDLE RGB_GREEN)
			|(LEDS_STATE_XMPP_CONNECTED -> 0 /* ne rien faire, maintenant les leds sont sett√©es dans le code */)
	)
;;
// end of file leds.mtl //
// back to file STDIN, line 68


// ---------------- dns prototypes

proto addnewdns 2;;
proto dnslisttostr 0;;
proto dnslistfromdhcp 1;;

// ---------------- end dns prototypes


// file md5.mtl //
// ################################################
// ##### LeftRotate 16bits // Octobre 2007 // Romain COCHET
// ################################################
var tmp;;
var val;;
fun leftrotate val nb_rot =
	let val.(0) -> valh in
	let val.(1) -> vall in ( 
		if nb_rot == 16 then (
			{vall valh}
		) else (
			if nb_rot > 16 then (
				// inversion de h et l, et on g√®re comme si c'√©tait n-16.
				set tmp = valh;
				set valh = vall;
				set vall = tmp;
				set nb_rot = nb_rot - 16
			);				
			{
				(valh << nb_rot) & 0xFFFF | (vall >> (16 - nb_rot))
				(vall << nb_rot) & 0xFFFF | (valh >> (16 - nb_rot))
			}
		)
	);;

// ################################################
// ##### MD5 // Octobre 2007 // Romain COCHET
// ################################################
// Exemple de fonctionnement : Secholn md5 "http://r.nabaztag.com/vl/securestreaming.jsp?t=1189430760&r=42&pos=0&sn=0013D380FD33violet";
// ATTENTION LA TAILLE de la chaine ne doit pas √™tre supp√©rieurs √†  134 217 728 octets ...
// http://fr.wikipedia.org/wiki/MD5
// Constantes
const md5r		= { 7 12 17 22 7 12 17 22 7 12 17 22 7 12 17 22 5 9 14 20 5 9 14 20 5 9 14 20 5 9 14 20 4 11 16 23 4 11 16 23 4 11 16 23 4 11 16 23 6 10 15 21 6 10 15 21 6 10 15 21 6 10 15 21 };;
const md5k 		= { 0xd76a 0xa478 0xe8c7 0xb756 0x2420 0x70db 0xc1bd 0xceee 
0xf57c 0x0faf 0x4787 0xc62a 0xa830 0x4613 0xfd46 0x9501 
0x6980 0x98d8 0x8b44 0xf7af 0xffff 0x5bb1 0x895c 0xd7be 
0x6b90 0x1122 0xfd98 0x7193 0xa679 0x438e 0x49b4 0x0821 
0xf61e 0x2562 0xc040 0xb340 0x265e 0x5a51 0xe9b6 0xc7aa 
0xd62f 0x105d 0x0244 0x1453 0xd8a1 0xe681 0xe7d3 0xfbc8
0x21e1 0xcde6 0xc337 0x07d6 0xf4d5 0x0d87 0x455a 0x14ed
0xa9e3 0xe905 0xfcef 0xa3f8 0x676f 0x02d9 0x8d2a 0x4c8a
0xfffa 0x3942 0x8771 0xf681 0x6d9d 0x6122 0xfde5 0x380c
0xa4be 0xea44 0x4bde 0xcfa9 0xf6bb 0x4b60 0xbebf 0xbc70
0x289b 0x7ec6 0xeaa1 0x27fa 0xd4ef 0x3085 0x0488 0x1d05
0xd9d4 0xd039 0xe6db 0x99e5 0x1fa2 0x7cf8 0xc4ac 0x5665
0xf429 0x2244 0x432a 0xff97 0xab94 0x23a7 0xfc93 0xa039
0x655b 0x59c3 0x8f0c 0xcc92 0xffef 0xf47d 0x8584 0x5dd1
0x6fa8 0x7e4f 0xfe2c 0xe6e0 0xa301 0x4314 0x4e08 0x11a1
0xf753 0x7e82 0xbd3a 0xf235 0x2ad7 0xd2bb 0xeb86 0xd391 };;
var md5h0h		= 0x6745;;var md5h0l		= 0x2301;;var md5h1h		= 0xEFCD;;var md5h1l		= 0xAB89;;
var md5h2h		= 0x98BA;;var md5h2l		= 0xDCFE;;var md5h3h		= 0x1032;;var md5h3l		= 0x5476;;
var md5len		= 0;;	// Taille du message     md5len = 512 * md5mult + md5reste
var md5mult		= 0;;var md5reste	= 0;;var md5message	= "msg";;var md5return	= "";;
var md5bloc		= {
	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000 };;
// Variables (a, b, c, d, f,g et divers)
var md5ah		= 0;;var md5al		= 0;;var md5bh		= 0;;var md5bl		= 0;;var md5ch		= 0;;var md5cl		= 0;;
var md5dh		= 0;;var md5dl		= 0;;var md5fh		= 0;;var md5fl		= 0;;var md5g		= 0;;var md5msglen	= 0;;
var md5tmp1h	= 0;;var md5tmp1l	= 0;;var md5tmp2h	= 0;;var md5tmp2l	= 0;;var md5tmp3h	= 0;;var md5tmp3l	= 0;;
var md5len64h	= 0x00000000;;			 var md5len64l	= 0x00000000;;

// Fonction Principale MD5
fun md5bytes strmd5=
	// ### Initialisation des variables
	// Constantes
	set md5h0h		= 0x6745;
	set md5h0l		= 0x2301;
	set md5h1h		= 0xEFCD;
	set md5h1l		= 0xAB89;
	set md5h2h		= 0x98BA;
	set md5h2l		= 0xDCFE;
	set md5h3h		= 0x1032;
	set md5h3l		= 0x5476;
	// Variable de message
	set md5len		= strlen strmd5;					// Taille de la chaine de caractere
	set md5reste 	= md5len&0x3FF;						// Reste de la division par 512 bits
	set md5mult 	= md5len/64;						// Reste de la division par 64octets(512bits)
	if (md5reste > 55 && md5reste < 64) then set md5mult = md5mult + 1;	// Si la taille de la chaine entre dans les 64Bits de fin (en comptant le bit de fin de message) on allonge de 512bits
	set md5msglen	= (md5mult+1)*64;					// Taille du message apr√®s preparation
	
	// ### Preparation du message
	set md5message 	= strnew md5msglen;							// Allocation de la chaine
	for i=0;i<md5msglen do strset md5message i 0;				// Initialise la chaine
	for i=0;i<md5len do strset md5message i (strget strmd5 i);	// Copie le message
	strset md5message md5len 0x80;								// Ajout d'un bit 1 √† la fin du message
	
	// Puisque la chaine est de longueur de la chaine est max de 2^30 octect >> elle est de max (2^30) * 8 (01 FF FF FF F8)
	set md5len64h = ((((0xFFFFFF000000&md5len)>>24)*8) + (((((0x000000FFFFFF&md5len)>>00)*8)>>24)&0x000000FFFFFF));
	set md5len64l = ((((0x000000FFFFFF&md5len)>>00)*8)&0x000000FFFFFF);
	
	// On copie la longueur de 64 bits
	for i=0; i<3 do	strset md5message (md5msglen-8+i) (((md5len64l)>>(i*8))&0xFF);
	for i=3; i<6 do	strset md5message (md5msglen-8+i) (((md5len64h)>>((i-3)*8))&0xFF);
	
	// ### Calcul par blocs
	for i=0; i<=md5mult do (	// Faire tous les blocs de md5message
		// Preparation du bloc
		for j=0; j<16 do (		// A chaque bloc organiser le blog de 16 * 32bits en little endian
			set md5bloc.(j*2) = (strget md5message ((i*64) + (j*4) + 3)) * 0x100;
			set md5bloc.(j*2) = (strget md5message ((i*64) + (j*4) + 2)) + md5bloc.(j*2);
			set md5bloc.(j*2+1) = (strget md5message ((i*64) + (j*4) + 1)) * 0x100;
			set md5bloc.(j*2+1) = (strget md5message ((i*64) + (j*4) + 0)) + md5bloc.(j*2+1)
		);
		
		// Initialiser les valeurs de hachage
		set md5ah	= md5h0h;		set md5al	= md5h0l;		set md5bh	= md5h1h;		set md5bl	= md5h1l;
		set md5ch	= md5h2h;		set md5cl	= md5h2l;		set md5dh	= md5h3h;		set md5dl	= md5h3l;
		
		// Op√©rations de l'algo
		for j=0; j<64 do (
			if j < 16 then (
				set md5fh 	= (md5bh&md5ch)|((~md5bh)&md5dh);	//f := (b et c) ou ((non b) et d)
				set md5fl 	= (md5bl&md5cl)|((~md5bl)&md5dl);	//f := (b et c) ou ((non b) et d)
				set md5g	= j
			) else if  j < 32 then (
				set md5fh 	= (md5dh&md5bh)|((~md5dh)&md5ch);	//f := (d et b) ou ((non d) et c)
				set md5fl 	= (md5dl&md5bl)|((~md5dl)&md5cl);	//f := (d et b) ou ((non d) et c)
				set md5g	= (5*j + 1) %16
			) else if  j < 48 then (
				set md5fh 	=  md5bh^md5ch^md5dh;				//f := b xor c xor d
				set md5fl 	=  md5bl^md5cl^md5dl;				//f := b xor c xor d
				set md5g	= (3*j + 5) %16
			) else (
				set md5fh 	= md5ch^(md5bh|((~md5dh)&0xFFFF));	//f := c xor (b ou (non d))
				set md5fl 	= md5cl^(md5bl|((~md5dl)&0xFFFF));	//f := c xor (b ou (non d))
				set md5g	= (7*j) %16
			);
			
			set md5tmp1h 	= md5dh;			set md5tmp1l	= md5dl;			set md5dh 		= md5ch;
			set md5dl 		= md5cl;			set md5ch 		= md5bh;			set md5cl 		= md5bl;			
			// ((a+f+g+k(i) + w(g)
			set md5tmp2h 	= (md5ah + md5fh + md5k.(j*2  ) + md5bloc.(md5g*2  ));
			set md5tmp2l 	= (md5al + md5fl + md5k.(j*2+1) + md5bloc.(md5g*2+1));
			set md5tmp2h	= ((md5tmp2l >> 16) + md5tmp2h) & 0xFFFF;
			set md5tmp2l	= md5tmp2l & 0xFFFF;
			// Rotation
			let md5r.(j) -> nb_rot in
			let leftrotate { md5tmp2h md5tmp2l } nb_rot -> tmpr in (
				set md5tmp2h	= tmpr.(0);
				set md5tmp2l	= tmpr.(1)
			);			
			set md5bh		= ((md5tmp2h + md5bh) + ((md5tmp2l + md5bl) >> 16))&0xFFFF;
			set md5bl		= (md5tmp2l + md5bl)&0xFFFF;			
			set md5ah 		= md5tmp1h;
			set md5al 		= md5tmp1l
		);
		
		// Derni√®re √©tape pour le prochain bloc 
		set md5h0h		= (md5h0h + md5ah + ((md5h0l+md5al) >> 16)) & 0xFFFF;
		set md5h0l		= (md5h0l + md5al) & 0xFFFF;
		set md5h1h		= (md5h1h + md5bh + ((md5h1l+md5bl) >> 16)) & 0xFFFF;
		set md5h1l		= (md5h1l + md5bl)&0xFFFF;
		set md5h2h		= (md5h2h + md5ch + ((md5h2l+md5cl) >> 16)) & 0xFFFF;
		set md5h2l		= (md5h2l + md5cl)&0xFFFF;
		set md5h3h		= (md5h3h + md5dh + ((md5h3l+md5dl) >> 16)) & 0xFFFF;
		set md5h3l		= (md5h3l + md5dl)&0xFFFF
		
	);
	
	let strnew 16 -> md5_16octets in (
		// #### Concat√©nation et cr√©ation du bag de 16 octets
		for i=0; i<8 do (
			for j=0; j<2 do (
				if 		i == 0 then set md5tmp2h = md5h0l
				else if i == 1 then set md5tmp2h = md5h0h
				else if i == 2 then set md5tmp2h = md5h1l
				else if i == 3 then set md5tmp2h = md5h1h
				else if i == 4 then set md5tmp2h = md5h2l
				else if i == 5 then set md5tmp2h = md5h2h
				else if i == 6 then set md5tmp2h = md5h3l
				else 				set md5tmp2h = md5h3h;
				let (md5tmp2h>>(8*j))&0xFF -> octet in
					strset md5_16octets (i*2+j) octet
			)
		); 
		md5_16octets);;

fun md5tohex bytes =
	// convertit un paquet de bytes en hex
	let "" -> md5str in (
		for k=0; k<strlen bytes do set md5str = strcat md5str ctoh strget bytes k;
		md5str
	);;		

fun md5 str=
	md5tohex md5bytes str;;
// end of file md5.mtl //
// back to file STDIN, line 80
// file b64.mtl //
// ################################################
// ##### B64 // Novembre 2007 // Romain COCHET
// ################################################

const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";;

// Fonction permettant d'encoder en B64
fun StoB64 String =
	let "" -> B64Result in
	let 0 -> B64Len in
	let 0 -> B64Num in
	let 0 -> B64NumL in
	let 0 -> B64NumH in
	let 0 -> i in
	let 0 -> j in
	let 0 -> k in (	
		// Determine la taille et creer la chaine de caractere de retour
		set B64Len = ((strlen String) * 8) / 6 + 2;
		set B64Result = strnew (B64Len+1);
		for i=0; i<=B64Len do ( strset B64Result i 0 );
		set k = 0;
		
		for i=0; i<(strlen String) do (
			set j = i % 3;						// L'encodage comporte 3 phases par cycle
			set B64Num = strget String i;		// On recupere la lettre
			if j == 0 then (
				set B64NumH = B64Num >> 2;
				set B64NumL = (B64Num&0x03) << 4;
				strset B64Result k (strget Base64 B64NumH);
				set k = k+1
			)else if j == 1 then (
				set B64NumL = B64NumL | (B64Num >> 4);
				set B64NumH = (B64Num&0x0F) << 2;
				strset B64Result k (strget Base64 B64NumL);
				set k = k+1
			)else (
				set B64NumH = B64NumH | (B64Num >> 6);
				set B64NumL = (B64Num&0x3F);
				strset B64Result k (strget Base64 B64NumH);
				strset B64Result (k+1) (strget Base64 B64NumL);
				set k = k+2
			)
		);		
		// Si il reste des caract√®res non √©crit, il sont compl√©t√© avec des 0 et √©cris dans le r√©sultat
		if j == 0 then		(strset B64Result k (strget Base64 B64NumL); strset B64Result k+1 61; strset B64Result k+2 61;set k = k+2)
		else if j == 1 then	(strset B64Result k (strget Base64 B64NumH); strset B64Result k+1 61;set k = k+1);
		// remove trailing zeroes [as 26nov2007]
		let strsub B64Result 0 k -> truncated in
			 truncated
	);;


// Fonction permettant de d√©coder du B64
fun B64toS String =
	let "" -> B64Result in
	let 0 -> B64Len in
	let 0 -> B64Num in
	let 0 -> B64NumL in
	let 0 -> B64NumH in
	let 0 -> i in
	let 0 -> j in
	let 0 -> k in (
		// Determine la taille et creer la chaine de caractere de retour
		set B64Len = (((strlen String)) * 6) / 8;
		set B64Result = strnew (B64Len);
		for i=0; i<B64Len do ( strset B64Result i 0 );
		set k = 0;
		
		for i=0; i<(strlen String) do (
			set j = i % 4;													// On calcule le cas
			set B64Num = strfind Base64 0 (strsub String i 1) 0 nil;		// On recupere la lettre
			if B64Num != nil then (											// On ne prend pas en compte les == et autres caract√®res qui ne sont pas dans la chaine
				if j == 0 then (
					set B64NumH = B64Num << 2
				)else if j == 1 then (
					set B64NumH = B64NumH | ((B64Num&0x30) >> 4);
					set B64NumL = (B64Num&0x0F) << 4;
					strset B64Result k B64NumH;
					set k = k+1
				)else if j == 2 then (
					set B64NumL = B64NumL | ((B64Num&0x3C) >> 2);
					set B64NumH = (B64Num&0x03) << 6;
					strset B64Result k B64NumL;
					set k = k+1
				)else (
					set B64NumH = B64NumH | B64Num;
					strset B64Result k B64NumH;
					set k = k+1
				)
			)
		);
		B64Result
	);;
// end of file b64.mtl //
// back to file STDIN, line 81
// file xmlparser.mtl //
// ################################################
// ##### XML Parser // Novembre 2007 // Romain COCHET
// ################################################	
	
type Attribute = [tagS valueS];;
type Element = [nameS attribute content];;
type Content = ContentElement Element | ContentText S;;
type XmlResponse = [inXml EndStrS];;
type AttributeResponse = [ListAttributes toAnalyseS];;

fun BuildAttributes XmlAttr =
	if (strlen XmlAttr) != 0 then (
		let [ListAttributes:nil toAnalyseS:nil] -> Resp in (
			if (strget XmlAttr 0) == 32 /* Caractere espace */ then ( // Si on a un espace au d√©but de la chaine, on ne le prend pas en compte
				set Resp = BuildAttributes strsub XmlAttr 1 (strlen XmlAttr)
			)else if (strget XmlAttr 0) == '>' || ((strget XmlAttr 0) == '/' && (strget XmlAttr 1) == '>') then ( // Si on arrive √† la fin de la balise contenant des attributs on retourne une r√©ponse vide
				set Resp = [ListAttributes:nil toAnalyseS:(strsub XmlAttr 0 strlen XmlAttr)]
			)else (
				let (strfind XmlAttr 0 "=" 0 nil)+2 -> EqualTo in
				let strget XmlAttr (EqualTo-1) -> QuoteType in
				let 0 -> PosQuote in
				let [tagS:nil valueS:nil] -> NewAttribute in
				let "'" -> Quote in (
					if QuoteType != 39 /* Simple Quote */ then set Quote = "\""; // Si il ne s'agit pas d'un Simple, on recherche le double
					set PosQuote = strfind XmlAttr EqualTo Quote 0 nil; // On d√©termine le prochaine Quote (Double ou Simple)
					set NewAttribute.tagS = strsub XmlAttr 0 EqualTo-2;
					set NewAttribute.valueS = strsub XmlAttr EqualTo (PosQuote-EqualTo);
					let BuildAttributes strsub XmlAttr (PosQuote+1) strlen XmlAttr -> GetAll in (
						set GetAll.ListAttributes = NewAttribute::GetAll.ListAttributes;
						set Resp = GetAll
					)
				)
			)
		)
	)
;;

// First function, prepare the string xml
fun ReverseElements List =
	let hd List -> Maille in
	let nil -> NewList in (
		while Maille != nil do (
			if NewList == nil then
				set NewList = Maille::nil
			else
				set NewList = Maille::NewList;
			set List = tl List;
			set Maille = hd List
		);
		NewList
	)
;;


/** reste quelques bugs, mais normalement, √ßa n'arrive pas dans notre cas..
		- bad XML non g√©r√© "<m><a</m>" ou "<m><a></m>"
		- recursive balises non g√©r√© "<m><m></m></m>"...
***/
fun ParseXML XML =
	if (strlen XML) != 0 then (
		let [inXml:nil EndStrS:nil] -> XmlResp in
		let strlen XML -> StrLen in
		let strlen XML -> NewLen in
		let strfind XML 0 "<" 0 nil -> FirstElement in
		(
			// In an Element (could be <xml> or <xml attribute=''>...)
			if FirstElement == 0 then
			(
				let strfind XML 0 " " 0 nil -> Space in
				let strfind XML 0 ">" 0 nil -> Ending in
				let nil -> Name in
				let nil -> Attributes in
				let nil -> Contents in
				let nil -> NewList in
				let nil -> ToAnalyseAfter in
				let nil -> ToAnalyseNow in
				(
					if Ending == nil then (
						// pas de Ending "<m" : n'√©tait pas trait√© [AS 5dec07]
						set ToAnalyseAfter = XML;
						0
					) else (
						if Space == nil then set Space = Ending+1;
						if Ending < Space then ( // we have <balise>
							set Name = strsub XML 1 (Ending-1);
							set NewLen = (strfind XML 0 (strcatlist "</"::Name::">"::nil) 0 nil);
							
							if NewLen != nil then ( // si on ne trouve pas la fin, on ne donne rien √† analyser
								set ToAnalyseNow = strsub XML (Ending+1) (NewLen-Ending-1);
								set ToAnalyseAfter = strsub XML (NewLen + (strlen Name) + 3) strlen XML
							)else(
								set ToAnalyseAfter = XML
							);
							0
						)else( // we have an attribute
							set Name = strsub XML 1 (Space-1);
							
							set NewLen = (strfind XML 0 (strcatlist "</"::Name::">"::nil) 0 nil);
							if NewLen != nil then set StrLen = NewLen;
							
							// Get attributes
							let BuildAttributes (strsub XML (Space+1) (StrLen-Space-1)) -> AttributesResp in (
								set Attributes = AttributesResp.ListAttributes;
								set ToAnalyseNow = AttributesResp.toAnalyseS
							);
							// Check balise
							if (strfind ToAnalyseNow 0 "/>" 0 nil) == 0 then ( // we got this : <balise atr="" />
								set XmlResp.inXml = ContentElement [nameS:Name attribute:Attributes content:nil];
								set XmlResp.EndStrS = strsub ToAnalyseNow 2 strlen ToAnalyseNow;
								set ToAnalyseAfter = XmlResp.EndStrS;
								set ToAnalyseNow = nil
							)else if NewLen != nil then ( // si on ne trouve pas la fin, on ne donne rien √† analyser
								set ToAnalyseNow = strsub ToAnalyseNow 1 strlen ToAnalyseNow;
								set ToAnalyseAfter = strsub XML (NewLen + (strlen Name) + 3) strlen XML
							)else (
								set ToAnalyseNow = nil;
								set ToAnalyseAfter = XML
							);
							0
						)
					);
					
					if ToAnalyseNow != nil then (
						let ParseXML ToAnalyseNow -> NewContent in
						(
								while NewContent.EndStrS != nil do
								(
									if Contents == nil then		set Contents = (NewContent.inXml)::nil
									else						set Contents = (NewContent.inXml)::Contents;
									set NewContent = ParseXML NewContent.EndStrS
								);
								if NewContent != nil then (
									if Contents == nil then		set Contents = (NewContent.inXml)::nil
									else						set Contents = (NewContent.inXml)::Contents
								)
						);
						set Contents = ReverseElements Contents; // On renverse les elements pour les remettres dans le bon ordre
						set XmlResp.inXml = ContentElement [nameS:Name attribute:Attributes content:Contents];
						set XmlResp.EndStrS = ToAnalyseAfter
					)else (
						if XmlResp.inXml == nil then (
							set XmlResp.inXml = ContentText ToAnalyseAfter;
							set XmlResp.EndStrS = nil
						)
					)
				);
				0
			// Not in an Element (could be text...)
			)else if FirstElement != nil then // There is a balise after
			(
				set XmlResp.inXml = ContentText strsub XML 0 FirstElement;
				set XmlResp.EndStrS	= strsub XML FirstElement StrLen;
				0
			)else ( // There is no balise after
				set XmlResp.inXml = ContentText strsub XML 0 strlen XML;
				set XmlResp.EndStrS	= nil;
				0
			);
		if (strlen XmlResp.EndStrS) == 0 then set XmlResp.EndStrS = nil;
		XmlResp
		
		)
	)
;;
// Qui n'accepte que des paquets XML bien form√©s
fun ParseXMLPacket XML =
    let ParseXML XML -> xml in
    (
        match xml.inXml with
        (ContentText Texte ->
            set xml.inXml = nil;
            set xml.EndStrS = Texte;
        0)|
        (_ -> -1);
        xml
    )
;;

// ----- XML utils
fun Xml_FindFirstElementNamed elem nam=
	let nil -> res in (
		let elem.content -> l in
		while ((hd l) != nil) && (res == nil) do (
			let (hd l) -> xmlPaqi in (
				match xmlPaqi with
				(ContentElement subXml -> if (!strcmp subXml.nameS nam) then set res = subXml; 0) |
				(_ -> 0)
			);
			set l = tl l
		);
		res
	);;

// returns the content's content, if it is a ContentText, nil otherwise
fun Xmp_GetTextContent elem=
	let hd elem.content -> firstcontent in let nil -> res in (
		set res = match firstcontent with (ContentElement _ -> nil)|(ContentText txt -> txt);
		res
	);;

fun Xml_GetElementAttribute elem tag=
	//Secho "Xml_GetElementAttribute:"; XMLPrintElement elem 0;
	let nil -> res in (
		let elem.attribute -> l in
			while ((hd l) != nil) && (res == nil) do (
				let hd l -> att in (
					//Secho att.tagS; Secho ",";
					if (!strcmp att.tagS tag) then set res = att.valueS
				);
				set l = tl l
			);
		//Secho "Xml_GetElementAttribute("; Secho tag; Secho ")="; Secholn res;
		res);;


// Printing XML
proto XMLPrintContent 2;;

// prints an Element
fun XMLPrintElement Balise First=
	Secho "    |";
	for i=0; i<First do Secho ".";
	Secholn (Balise.nameS);
	let Balise.attribute -> ListAttribut in
	let Balise.content -> Recur in
	(
		while (hd ListAttribut) != nil do (
			let hd ListAttribut -> Attr in (
				Secho "    | ";
				for i=0; i<First do Secho " ";
				Secho Attr.tagS;
				Secho " => ";
				Secholn Attr.valueS
			);
			set ListAttribut = tl ListAttribut
		);
		while (hd Recur) != nil do (
			XMLPrintContent (hd Recur) (First+2);
			set Recur = tl Recur
		)
	);;
			
// prints a ContentXXX
fun XMLPrintContent Xml First = // was print_r
	let match Xml with
		(ContentElement Balise ->
			XMLPrintElement Balise First;
		0)|
		(ContentText Texte ->
			Secho "    !";
			for i=0; i<First do Secho ".";
			Secholn Texte;
		0)|
		(_ -> -1)-> Expect in
		if Expect == -1 then Secholn "Erreur"
;;
// end of file xmlparser.mtl //
// back to file STDIN, line 82

// file config.mtl //
// file config_protos.mtl //
proto confGetWifissid 0 ;;
proto confGetWificrypt 0 ;;
proto confGetWifikey0 0 ;;
proto confGetWifiauth 0 ;;
proto confGetWifipmk 0 ;;

proto confGetDhcp 0 ;;
proto confGetNetip 0 ;;
proto confGetNetmask 0 ;;
proto confGetNetgateway 0 ;;
proto confGetNetdns 0 ;;

proto confGetServerUrl 0 ;;
proto confGetLogin 0 ;;
proto confGetPwd 0 ;;

proto confGetProxy 0 ;;
proto confGetProxyip 0 ;;
proto confGetProxyport 0 ;;
// end of file config_protos.mtl //
// back to file config.mtl, line 1

const CONF_SERVERURL=0;;		//41
const CONF_NETDHCP=41;;		//1
const CONF_NETIP=42;;			//4
const CONF_NETMASK=46;;		//4
const CONF_NETGATEWAY=50;;	//4
const CONF_NETDNS=54;;		//4
const CONF_WIFISSID=58;;		//32
const CONF_WIFIAUTH=90;;		//1
const CONF_WIFICRYPT=91;;		//1
const CONF_WIFIKEY0=92;;		//64
const CONF_PROXYENABLE=156;;	//1
const CONF_PROXYIP=157;;		//4
const CONF_PROXYPORT=161;;	//2
const CONF_LOGIN=163;;		//6
const CONF_PWD=169;;			//6
const CONF_WIFIPMK=175;;		//32
const CONF_MAGIC=207;;		//1
const CONF_LENGTH=208;;

var conf;;

/*
var conf0=
"r.nabaztag.com/vl\0-----------------------\
\1\0\0\0\0\255\255\255\0\0\0\0\0\0\0\0\0\
\0-------------------------------\
\0\0abcde\0----------------------------------------------------------\
\0\0\0\0\0\0\0\
\0\0\0\0\0\0\
\0\0\0\0\0\0\
--------------------------------\
\$48";;
*/

fun confSave=
	Secholn "## save configuration";
	dump conf;
	save conf 0 "conf.bin" 0 CONF_LENGTH;;

fun confInit=
	set conf=strnew CONF_LENGTH;
	load conf 0 "conf.bin" 0 CONF_LENGTH;
/*	if (strget conf CONF_MAGIC)!=0x48 then
	(
		set conf=strnew CONF_LENGTH;
		strcpy conf 0 conf0 0 nil;
		confSave;
		set conf=strnew CONF_LENGTH;
		load conf 0 "conf.bin" 0 CONF_LENGTH
	);
*/	dump conf;;

fun confGet i len= strsub conf i len;;

fun confGetbin i len= strsub conf i len;;

fun confGetstr i len=
	let strstr conf "\0" i -> j in
	strsub conf i (if j==nil then len else min len j-i);;

fun confSet i val len=
	strcpy conf i val 0 len;;

fun confSetbin i val len=strcpy conf i val 0 len;;

fun confSetstr i val len=
	let min strlen val len-1 -> len in
	(
		strcpy conf i val 0 len;
		strset conf i+len 0
	);;

fun webport s= ((strget s 0)<<8)+strget s 1;;

fun confGetWifissid=confGetstr CONF_WIFISSID 32;;
fun confGetWificrypt=strget confGet CONF_WIFICRYPT 1 0;;
fun confGetWifikey0=confGetstr CONF_WIFIKEY0 64;;
fun confGetWifiauth=strget confGet CONF_WIFIAUTH 1 0;;
fun confGetWifipmk=confGetbin CONF_WIFIPMK 32;;

fun confGetDhcp=strget confGet CONF_NETDHCP 1 0;;
fun confGetNetip=confGet CONF_NETIP 4;;
fun confGetNetmask=confGet CONF_NETMASK 4;;
fun confGetNetgateway=confGet CONF_NETGATEWAY 4;;
fun confGetNetdns=confGet CONF_NETDNS 4;;

fun confGetServerUrl=confGetstr CONF_SERVERURL 40;;
fun confGetLogin=confGet CONF_LOGIN 6;;
fun confGetPwd=confGet CONF_PWD 6;;

fun confGetProxy=strget confGet CONF_PROXYENABLE 1 0;;
fun confGetProxyip=confGet CONF_PROXYIP 4;;
fun confGetProxyport=webport confGet CONF_PROXYPORT 2;;

// end of file config.mtl //
// back to file STDIN, line 84

// file: STDIN, line 89
// file ip.mtl //
// end of file ip.mtl //
// back to file STDIN, line 89
// file arp.mtl //
// file arp_protos.mtl //
proto resetarp 0 ;;
proto cbnetarp 2 ;;
proto arptime 0 ;;
proto arpreq 2 ;;
// end of file arp_protos.mtl //
// back to file arp.mtl, line 1

const ARPREQ=1;;
const ARPANS=2;;

var larp;;
var larpreq;;


fun mkarp op ipsrc macdst ipdst=
	strcatlist
	"\$aa\$aa\$03\$00\$00\$00\$08\$06\$00\$01\$08\$00\$06\$04\$00"::(ctoa op)::
	mymac::
	netip::
	macdst::
	ipdst
	::nil;;

fun sendarp ip=
	netSend (mkarp ARPREQ netip macbroadcast ip) 0 nil macbroadcast 0 1;;


fun filterarpip l src =
	if l!=nil then let hd l->[ip _ _] in if !vstrcmp src 8+14 ip 0 4  then filterarpip tl l src
	else (hd l)::filterarpip tl l src;;

fun checkarp l src=
	if l!=nil then let hd l->[ip _ cb] in 
	(
		if !vstrcmp src 8+14 ip 0 4 then
		let strsub src 8+8 6 -> mac in
		(
			Secho "found MAC target : "; MACecho mac 0 1;
			set larp=[ip mac]::larp;
			call cb [mac]
		);
		checkarp tl l src
	);
	nil
;;

fun cbnetarp src mac=
	//Secho "<a";
	let strget src 8+7-> op in
	if op==1 then // req
	(
//		Secho "ask ";MACecho src 16+10 1; IPecho src 16+16 1;
		if !vstrcmp src 32 netip 0 4 then
			netSend (mkarp ARPANS netip strsub src 16 6 strsub src 22 4) 0 nil mac 0 1;
		nil
	)
	else if op==2 then
		let larpreq->l in
		(
			set larpreq=filterarpip larpreq src;
			checkarp l src
		)
	; 0
;;

fun subnet_ ip i=
	if i<0 then 1
	else if ((strget ip i)^(strget netip i))&(strget netmask i) then 0
	else subnet_ ip i-1;;

fun subnet ip=
	//Secho "test subnet "; IPecho ip 0 1;
	/*Iecholn */ subnet_ ip 3;;
	
	
fun arpreq ip cb=
	let /* IPecho */ (if subnet ip then ip else netgateway) /* 0 1 */ -> ip in
	let listswitchstr larp ip -> mac in
	if mac!=nil then call cb [mac]
	else
	(
		sendarp ip;
		set larpreq=[ip time cb]::larpreq;	// ### attention √† la taille de la liste
		0
	);;

fun filterarp l dt =
	if l!=nil then let hd l->[ip t _] in if (time-t)>dt then filterarp tl l dt
	else
	(
		sendarp ip;
		(hd l)::filterarp tl l dt
	);;

fun arptime =
	set larpreq=filterarp larpreq 10;;

fun resetarp=
	set larp=nil;
	set larpreq=nil;
	0;;
// end of file arp.mtl //
// back to file STDIN, line 90
// file udp.mtl //
// file udp_protos.mtl //
proto cbnetudp 2 ;;
proto resetudp 0 ;;
proto udpsend 6 ;;
proto regudp 2 ;;
// end of file udp_protos.mtl //
// back to file udp.mtl, line 1
// file arp_protos.mtl already included

fun mkudp ipsrc ipdst portsrc portdst content=
	let strcatlist 
	"\$aa\$aa\$03\$00\$00\$00\$08\$00\$45\$00\$00\$00\$00\$00\$00\$00\100\17\0\0"::
	ipsrc::
	ipdst::
	"\0\0\0\0\0\0\0\0"::
	content::
	nil -> udp in
	(
		strputword udp 8+2 28+strlen content;
		strputword udp 8+20 portsrc;
		strputword udp 8+22 portdst;
		strputword udp 8+24 8+strlen content;
		strputchk udp 8+10 netChk udp 8 20 0;
		strputchk udp 8+26 netChk udp 8+20 (8+strlen content) netChk udp 8+24 2 netChk "\0\17" 0 nil netChk udp 8+12 8 0;
		udp
	);;

fun udpSend2 mac udp=
	Secho ">u";
//	dump udp;
	netSend udp 0 nil (MACecho mac 0 1) 0 1;;

fun udpsend local localp dst dstp content mac=
	let mkudp local dst localp dstp content -> udp in
	if mac!=nil then udpSend2 mac udp
	else let dst -> ip in	//	ajouter le test de passerelle
	arpreq ip fixarg2 #udpSend2 udp;;

var ludp;;

fun remudp l port=
	if l!=nil then let hd l ->[p _] in if p==port then remudp tl l port else (hd l)::remudp tl l port;;

fun regudp port cb=
	set ludp=[port cb]::remudp ludp port;;

fun unregudp port=
	set ludp=remudp ludp port;;

fun resetudp= set ludp=nil;;

fun cbnetudp src mac=
	//Secho "<u";
	let /*Iecholn*/ strgetword src 8+20+2 -> locp in
	let listswitch ludp locp -> cb in
	call cb [strsub src 8+20+8 nil mac strsub src 20 4];;

// file arp.mtl already included
// end of file udp.mtl //
// back to file STDIN, line 91
// file tcp.mtl //
// file tcp_protos.mtl //
proto cbnettcp 2 ;;
proto opentcp 5 ;;
proto writetcp 3 ;;
proto closetcp 1 ;;
proto tcptime 0 ;;
proto resettcp 0 ;;
// end of file tcp_protos.mtl //
// back to file tcp.mtl, line 1
// file arp_protos.mtl already included

const TFIN=0x01;;
const TSYN=0x02;;
const TRST=0x04;;
const TPUSH=0x08;;
const TACK=0x10;;
const TURGE=0x20;;

const STOFF=-1;;
const STSYN=0;;
const STEST=1;;
const STLISTEN=2;;
const STFIN=3;;

const CLIENT_SEQ_START="\0\0\1\0";;
const CLIENT_SEQ_NULL="\0\0\0\0";;

const TCPWRITE=0;;
const TCPREAD=1;;
const TCPCLOSE=-1;;
const TCPSTART=2;;

const TCPMAX=1024;;

// debug
fun Tcpw str = nil;; //Secholn strcatlist "[tcp] " :: str :: nil;;

type Tcp=[stateT locT dstT locpT dstpT seqT ackT cbT macT lastsentT retryT locksendT enableT];;

/**
	creates the full tcp frame
*/
fun mktcp t flag content=
	let strcatlist 
	"\$aa\$aa\$03\$00\$00\$00\$08\$00\$45\$00\$00\$00\$00\$00\$00\$00\100\6\0\0"::
	(t.locT)::
	(t.dstT)::
	"\0\0\0\0"::
	(t.seqT)::
	(t.ackT)::
	"\0\0\$16\$d0\0\0\0\0"::
	if flag&TSYN then "\2\4\5\$b4"::content::nil	// 5.b4 final : taille MSS
	else content::nil
	-> tcp in
	let strlen tcp ->len in
	(
		strputword tcp 8+2 len-8;
		strputword tcp 8+20 (t.locpT);
		strputword tcp 8+22 (t.dstpT);

		strset tcp 8+32 4*if flag&TSYN then 24 else 20;
		strset tcp 8+33 flag;

		strputchk tcp 8+10 netChk tcp 8 20 0;

		let strnew 2 -> s in
		(
			strputword s 0 len-28;
			strputchk tcp 8+36
			 netChk tcp 8+20 (len-28) netChk s 0 2 netChk "\0\6" 0 nil netChk tcp 8+12 8 0
		);
		tcp
	);;

fun resendtcp t=
	netSend t.lastsentT 0 nil (MACecho t.macT 0 1) 0 1;
	0;;

fun headerlen src=((strget src 8+32)>>4)<<2;;

fun datalength src=(strgetword src 10)-20-headerlen src;;

fun sendtcp t trame=
//	Secholn "tcpSend"; dump trame; 
	netSend trame 0 nil (/*MACecho*/ t.macT /*0 1*/) 0 1;
	let strget trame 8+33 -> flag in
	set t.seqT=netSeqAdd t.seqT (datalength trame)+(if flag&(TSYN|TFIN) then 1 else 0);
	0;;

fun sendtcpforretry t trame=
	set t.lastsentT=trame;
	set t.retryT=nil;
	sendtcp t trame;;


fun tcpSend2 mac tcp trame=
	set tcp.macT=mac;
	sendtcpforretry/*sendtcp*/ tcp trame;;

// List of all current tcp requests
var ltcp;;


fun remtcp t=set t.stateT=STOFF; set ltcp=remfromlist ltcp t;;

var counttcp;;

fun opentcp local localp dst dstp cb=
	let if localp==nil then 1024+set counttcp=((if counttcp==nil then time_ms else counttcp)+1)&16383 else localp -> localp in
	let [stateT:STSYN locT:local dstT:dst locpT:localp dstpT:dstp seqT:CLIENT_SEQ_START ackT:CLIENT_SEQ_NULL cbT:cb enableT:1] -> tcp in
	let mktcp tcp TSYN nil -> trame in
	let dst -> ip in	//	ajouter le test de passerelle
	(
		set ltcp=tcp::ltcp;
		arpreq ip fixarg2 fixarg3 #tcpSend2 trame tcp;
		tcp
	);;

fun listentcp localp cb=
	let [stateT:STLISTEN locpT:localp cbT:cb enableT:1] -> tcp in
	(
		set ltcp=tcp::ltcp
	);;
	
fun findtcp l localp dstp src=
	if l!=nil then let hd l-> t in
	if t.locpT==localp && t.dstpT==dstp && (!vstrcmp src 8+16 t.locT 0 4)&& (!vstrcmp src 8+12 t.dstT 0 4)
	then t
	else if t.stateT==STLISTEN && t.locpT==localp then t
	else findtcp tl l localp dstp src;;

fun sendclose t=
	Tcpw "## sendclose";
	sendtcp t mktcp t TFIN+TACK nil;
	set t.stateT=STFIN;
	0;; 

fun cbnettcp src mac=
	//Secho "t";
	let /*Iecholn*/ strgetword src 8+20+2 -> locp in
	let /*Iecholn*/ strgetword src 8+20+0 -> dstp in
	let findtcp ltcp locp dstp src -> t in
	if t!=nil && t.enableT then let t.stateT -> st in
		let /*Iecholn*/ strget src 8+33 -> flag in
		let /*SEQecho*/ (strsub src 8+24 4) /*0 1*/-> rseq in
		let /*SEQecho*/ (strsub src 8+28 4) /*0 1*/-> rack in
		if st==STSYN then
		(
			Tcpw "stsyn";
			if (flag==TSYN+TACK) && !vstrcmp (SEQecho(t.seqT)0 1) 0 rack 0 4 then
			(
				set t.ackT=SEQecho (netSeqAdd rseq 1) 0 1;
				sendtcp t mktcp t TACK nil;
				set t.stateT=STEST;
				set t.lastsentT=nil;
				Tcpw "call TCPWRITE";
				call t.cbT [t TCPWRITE nil]
			)
			else
			(
				Tcpw "TSRT+TACK";
				sendtcp t mktcp t TRST+TACK nil;
				remtcp t;
				nil
			)
		)
		else if st==STEST then
			if !vstrcmp t.ackT 0 rseq 0 4 then
			let strgetword src 10 -> iplen in
			let ((strget src 8+32)>>4)<<2 -> tcplen in
			let datalength src -> datalen in
			(
				if datalen then
				(
	//				dump src;
	//				Iecholn iplen;
	//				Iecholn tcplen;
//					Secho "update ackT : add ";
					set t.ackT=netSeqAdd t.ackT datalen
				);
				if (flag&TFIN) then
				(
					set t.ackT=netSeqAdd t.ackT 1;
					nil
				)
				else if (!vstrcmp t.seqT 0 rack 0 4) then
				(
//					Tcpw "acquittement de l'envoi";
					set t.lastsentT=nil;	// acquittement de l'envoi
					if t.locksendT==1 then
					(
						set t.locksendT=0;
						call t.cbT [t TCPWRITE nil]
					)
					else if t.locksendT==2 then
					(
						sendclose t;
						nil
					)
				)
				else (Tcpw "##bad ack"; /* SEQecho t.seqT 0 1;SEQecho rack 0 1; */ nil);
				if datalen then
					let 8+20+headerlen src -> start in
					let strsub src start datalen -> data in
					call t.cbT [t TCPREAD data];
				if (datalen || (flag&TFIN)) then				
					sendtcp t mktcp t TACK nil;
				if (flag&TFIN) then
				(
					Tcpw "tcp : sender closes";
					//Iecholn t.stateT;
					sendtcp t mktcp t TFIN+TACK nil;
					remtcp t;	
					call t.cbT [t TCPCLOSE nil]
				)
			)
			else (/*SEQecho(t.ackT)0 1; SEQecho rseq 0 1;*/Secho "##bs/";sendtcp t mktcp t TACK nil; nil)
		else if st==STFIN then
			(
				Tcpw "STFIN";
				set t.ackT=SEQecho (netSeqAdd rseq 1) 0 1;
				sendtcp t mktcp t TACK nil;
				remtcp t;
				nil
			)
		else if (st==STLISTEN) then
			if (flag&TSYN) then
			(
				let [stateT:STEST locT:(strsub src 8+16 4) dstT:(strsub src 8+12 4) locpT:locp dstpT:dstp
				seqT:CLIENT_SEQ_START ackT:(netSeqAdd rseq 1) cbT:t.cbT macT:mac  enableT:1] -> tcp in
				(
					set ltcp=tcp::ltcp;
					sendtcpforretry tcp mktcp tcp (TACK+TSYN) nil;
					call tcp.cbT [tcp TCPSTART nil]
				)
			)
	;;


fun writetcp t msg i=
	if t.stateT!=STEST then nil
	else if t.lastsentT!=nil then
	(
		Tcpw "locksend";
		set t.locksendT=1;
		i
	)
	else let strsub msg i TCPMAX -> content in
	let mktcp t TACK content -> trame in
	(
		Tcpw strcatlist "writetcp. len: " :: (itoa (strlen msg)) :: nil;
		sendtcpforretry t trame;
		let i+strlen content -> ni in
		(
			if ni!=strlen msg then set t.locksendT=1;
			ni
		)
	);;


fun closetcp t=
	if t.stateT!=STEST then 0
	else if t.lastsentT!=nil then
	(
		set t.locksendT=2;
		0
	)
	else sendclose t;
	0;;

fun tcpcb t cb= set t.cbT=cb;;

fun enabletcp t v= set t.enableT=v;;
fun enabledtcpP t= t.enableT;;

fun tcptime =
	for l=ltcp;l!=nil;tl l do let hd l-> t in
	if (nil != t.lastsentT) then
	(
		if (nil != t.retryT) then
		(
			set t.retryT = (1+t.retryT);
			if (t.retryT>10) then
			(
				remtcp t;
				Tcpw "TCP > 10 send retries => closing";
				call t.cbT [t TCPCLOSE nil];
				nil
			)
			else resendtcp t
		)
		else set t.retryT=0
	);
	0;;

fun resettcp=
	set ltcp=nil;
	0;;
// end of file tcp.mtl //
// back to file STDIN, line 92
// file dhcp.mtl //
// file dhcp_protos.mtl //
proto startdhcp 0 ;;
proto startdhcpserver 0 ;;
// end of file dhcp_protos.mtl //
// back to file dhcp.mtl, line 1
// file dns_protos.mtl //
//proto addnewdns 2 ;;
proto startdnsclient 0 ;;
proto dnstime 0 ;;
//proto dnslistfromdhcp 1 ;;
//proto dnslisttostr 0 ;;// end of file dns_protos.mtl //
// back to file dhcp.mtl, line 2

const DHCP_DISCOVER=1;;
const DHCP_OFFER=2;;
const DHCP_REQUEST=3;;
const DHCP_DECLINE=4;;
const DHCP_ACK=5;;
const DHCP_NACK=6;;


/* 1 if the dhcp client is running */
var dhcp_client_started=0;;

/* length, in seconds, of the dhcp lease */
var dhcp_lease_len=0;;

/* the time when we received the lease */
var dhcp_lease_start=0;;

/* if 1, then the dhcp has been granted for an infinite time */
var dhcp_infinite_lease=0;;

/***
	According to the DHCP RFC (1541 and 2132), the leases are timed from
  the time of the request sending, and one should try to renew the lease
	with the previous host from t1 = (start_time+lease_duration*0.5) to t2 =
  (start_time+lease_duration*0.875). After t2, the dhcp request is to be
	asked to every reachable server (broadcasting).

	TODO for the moment only t1 is used and all messages are broadcasted
*/
var dhcp_lease_t1=0;;

// debug
fun Dhcpw s = Secholn strcatlist "[dhcp] " :: s :: nil ;;

/**
	Updates the var dhcp_lease_t1, that contains the time of the dhcp renewal time
*/
fun updatedhcpleasetimes leaselen =
	if (leaselen == -1) then
	(
		 set dhcp_infinite_lease = 1;
		 Dhcpw "Infinite DHCP lease !"
	)
	else
	(
		set dhcp_lease_t1 = dhcp_lease_start + leaselen/2;
		Dhcpw strcatlist "Next dhcp renewal in " :: (itoa (dhcp_lease_t1 -time )) :: "seconds"::nil
	);
	0
;;

fun mkdhcp op netip hostip newip =
	let 236+16+14->n in
	let strnew n -> b in
	(
		for i=0;i<n do strset b  i 0;
		strcpy b 0 "\1\1\6" 0 3;
		strcpy b 12 netip 0 4;
		strcpy b 12+16 mymac 0 6;
		strcpy b 236 "\99\130\83\99\53\1" 0 6; // magic cookie + champ op
		strset b 236+6 op; // op
		strcpy b 236+7 "\61\7\1" 0 3; // id unique.
		strcpy b 236+10 mymac 0 6;    // id unique
		strcpy b 236+16 "\12\7Pabcdef\55\3\1\3\6" 0 14; // nom d'hote : Pabcdef. Options demand√©es en retour: 1 (masque de sous-reseau), 3 (addr routeur), 6 (addr dns)
		if op==DHCP_REQUEST then
			(strcatlist b:: ((if nil != hostip then strcatlist "\54\4"::hostip::nil else "")::(if nil != newip then strcatlist "\50\4"::newip::nil else "")::"\255"::nil))
		else
			(strcat b "\255")
	)
;;

fun mkdhcpans op tid newip dmac=
	let 236+7->n in
	let strnew n -> b in
	(
		for i=0;i<n do strset b  i 0;
		strcpy b 0 "\2\1\6" 0 3;
		strcpy b 4 tid 0 4;
		strcpy b 16 newip 0 4;
		strcpy b 12+16 dmac 0 6;
		strcpy b 236 "\99\130\83\99\53\1" 0 6;
		strset b 236+6 op;
		strcatlist b::"\54\4"::newip::"\51\4\0\1\$51\$80\1\4"::netmask::"\3\4"::netip::"\6\4"::netip::"\15\4home\255"::nil
	);;

/**
	returns a list of the ip adresses contained in src from start to start + len
*/
fun extractdhcp_helper_dnslist src start len =
	if (len < 4) then
		nil
	else
		(strsub src start 4) :: (extractdhcp_helper_dnslist src (start+4) (len-4))
	;;

fun extractdhcp src i type lease submask dnslist gateway mac=
	if i<strlen src then
	let strget src i -> c in
	if c==255 then [type lease submask dnslist gateway mac]
	else let strget src i+1 -> len in
	let i+2->i in
	if c==53 then extractdhcp src i+len (strget src i) lease submask dnslist gateway mac
	else if c==51 then extractdhcp src i+len type (strgetnum src i len) submask dnslist gateway mac
	else if c==1 then extractdhcp src i+len type lease (strsub src i 4) dnslist gateway mac
	else if c==6 then extractdhcp src i+len type lease submask (extractdhcp_helper_dnslist src i len) gateway mac
	else if c==3 then extractdhcp src i+len type lease submask dnslist (strsub src i 4) mac
	else if c==61 then extractdhcp src i+len type lease submask dnslist gateway (strsub src i+1 6)
	else extractdhcp src i+len type lease submask dnslist gateway mac;;

fun mkdhcpip mac=
	let strnew 4 -> s in
	(
		strcpy s 0 netip 0 4;
		strset s 3 ((strget mac 5)&0x7f)+100;
		s
	);;

fun cbnetdhcp src macfrom hostip=
	Secholn "<dhcp"; MACecho macfrom 0 1;
	let strget src 0 -> x in
	let MACecho (strsub src 28 6)0 1 -> mac in
	if x==2 && !strcmp mac mymac then
	(
		let IPecho (strsub src 16 4) 0 1-> newip in
		let extractdhcp src 240 0 nil nil nil nil nil->[type lease submask dnslist gateway _] in
		if type==DHCP_OFFER then
		(
			Secholn ">>>>>>>>>>>>>>>OFFER";
			udpsend netip 68 ipbroadcast 67 (mkdhcp DHCP_REQUEST netip hostip newip) macbroadcast;
			nil
		)
		else if type==DHCP_ACK then
		(
			Secholn ">>>>>>>>>>>>>>>ACK";
			Secho "server    ";IPecho hostip 0 1;
			Secho "ip        ";IPecho set netip=newip 0 1;
			Secho "type      ";Iecholn type;
			Secho "leasetime ";Iecholn lease; updatedhcpleasetimes lease;
			Secho "submask   ";IPecho set netmask=submask 0 1;
			Secho "dns       "; dnslistfromdhcp dnslist; Secholn dnslisttostr;
			Secho "gateway   ";IPecho set netgateway=gateway 0 1;
			nil
		)
		else if type==DHCP_NACK then
		(
			// TODO
			Dhcpw "DHCP_NACK"; nil
		)
	);;

fun cbnetdhcp67 src macfrom hostip=
	Secholn "<dhcp"; MACecho macfrom 0 1;
	let strget src 0 -> x in
	let MACecho (strsub src 28 6)0 1 -> mac in
	if x==1 /*&& !strcmp mac mymac*/ then
	(
		let extractdhcp src 240 0 nil nil nil nil nil ->[type _ _ _ _ dmac] in
		let strsub src 4 4 -> tid in
		let mkdhcpip macfrom -> newip in
		if type==DHCP_DISCOVER then
		(
			Secholn ">>>>>>>>>>>>>>>DISCOVER";
//			dump src;
			udpsend netip 67 ipbroadcast 68 (mkdhcpans DHCP_OFFER tid newip dmac) macbroadcast;
			nil
		)
		else if type==DHCP_REQUEST then
		(
			Secholn ">>>>>>>>>>>>>>>REQUEST";
//			dump src;
			udpsend netip 67 ipbroadcast 68 (mkdhcpans DHCP_ACK tid newip dmac) macbroadcast;
			nil
		)
	);;


/**
	checks if the dhcp lease is about to expire and checks if the rabbit
  should ask for a renewal
*/
fun checkdhcp force =
	if (force || (dhcp_client_started && dhcp_lease_t1 != 0 && time > dhcp_lease_t1 && !dhcp_infinite_lease)) then
	(
		Dhcpw "checkdhcp";
		/* ask to renew the lease */
		udpsend netip 68 ipbroadcast 67 (mkdhcp DHCP_REQUEST netip nil nil) macbroadcast;
		set dhcp_lease_start=time;
		if (0 != dhcp_lease_t1) then
			// if the request fails, try again in 10 seconds
			set dhcp_lease_t1=dhcp_lease_t1+10;
		0
	)
;;


/**
	Starts a dhcp client if needed, sending a DHCP_DISCOVER request.
	As the boot will have ran before, we should always already have done
	a dhcp request during the boot and therefore already have a ip.
*/
fun startdhcp=
	Dhcpw "startdhcp";
	if (confGetDhcp && !dhcp_client_started) then
	(
		Dhcpw "really do startdhcp";
		regudp 68 #cbnetdhcp;
		if (!strcmp netip netip_empty) then
			udpsend netip 68 ipbroadcast 67 (mkdhcp DHCP_DISCOVER netip nil nil) macbroadcast
		else
			checkdhcp 1;
		set dhcp_client_started=1
	);
0;;


fun startdhcpserver=
	regudp 67 #cbnetdhcp67;
	0;;

// file dns.mtl //
// file dns_protos.mtl already included

/*
	R√©ponse DNS. voir http://www.zytrax.com/books/dns/ch15/

	Section |	Meaning/Use
-----------------------------
Section 1 |	Message Header
Section 2 |	The DNS question being asked
Section 3 |	The Resource Record(s) which answer the question
Section 4 |	The Resource Record(s) which point to the domain authority
Section 5 |	The Resource Record(s) which may hold additional information
*/

// TYPE ET LISTE POUR LES REPONSES SRV
type SrvAnswer = [SrvPriority SrvWeight SrvPort SrvTargetS];;
var SrvAnswerL = nil;;

// port local pour le dns
const DNSLOCAL=1597;;

// debug
fun Dnsw s = Secholn strcatlist "[dns] " :: s :: nil ;;


// skippe une question dans la section 2.
// 
//  s: la r√©ponse dns
//  i: le d√©but de la partie qu'on doit skipper dans s
//
//  -> la position de ce qui suit cette question dans s
fun parsequ s i= let strfind s i "\0" 0 nil -> j in	j+5;;

// skippe la section 2 d'une r√©ponse DNS (qui r√©capitule la
// requ√™te), qui ne nous int√©resse pas.
// 
//  s: la r√©ponse dns
//  i: le d√©but de la partie qu'on doit skipper dans s
//  n: le nombre de questions restantes √† skipper
//
//  -> la position de la fin de la section 2 dans s.
fun parsequs s i n=	if n<=0 then i else parsequs s parsequ s i n-1;;

// passe la partie "nom" de la section 3 d'une r√©ponse dns
//
//  s: la r√©ponse dns
//  i: o√π commencer √† lire (o√π commence le nom)
//
//  -> la position de la fin du nom dans s.
fun skipname s i=
	let strgetword s i -> x in
	if (x&0xc000)==0xc000 then i+2
	else (strfind s i "\0" 0 nil)+1;;

// ON PARSE LES REPONSES A PARTIR DE i

// parse les r√©ponses dns.
//  s: la reponse dns
//  i: la position a partir de laquelle on doit commencer dans s
//     (on est dans la section 3)
//  n: le nombre de reponses qu'il reste a parser
//
//  -> un couple [ ip ttl ], ou nil, selon le type de message
fun parseans s i n=
	if n<=0 then nil
	else let skipname s i -> j in	// Passe le nom de la requete
	let strgetword s j -> typ in (
		if typ==1 then
		(
			let strgetword s j+4 -> TTLh in
			let strgetword s j+6 -> TTLl in
			let TTLl + 65536 * TTLh -> ttl in
			let strcatlist (itoa strget s j+10)::"."::(itoa strget s j+11)::"."::(itoa strget s j+12)::"."::(itoa strget s j+13)::nil -> ip in
			(
				Dnsw strcatlist "DNS: parsed an answear. TTLl = " :: (itoa TTLl) :: ", TTLh = " :: (itoa TTLh) :: ", so TTL = " :: (itoa ttl) :: " and ip = " :: ip :: nil;
				[ ip ttl ]
			)
		)
		else if typ==33 then ( // ON PARSE LES REQUETES SRV (les r√©ponses)
			Dnsw "DNS: parsing a SRV answear";
			let strsub s j+2 nil -> SrvAns in
			let strgetword s j+2 -> Class in
			let strgetword s j+4 -> TTLh in
			let strgetword s j+6 -> TTLl in
			let strgetword s j+8 -> Len in
			let j+10+Len -> End in
			let strgetword s j+10 -> Priority in
			let strgetword s j+12 -> Weight in
			let strgetword s j+14 -> Port in
			let strsub s j+16 (Len - 6) -> tmp in
			let 0 -> k in
			let strnew (Len - 8) -> Location in
			(
				set j=0; // ON REFORME LA TARGET
				strset Location (Len - 9) (strget tmp (Len - 8));
				for i=0; i<(Len-8) do (
					if j == 0 then (
						set j = strget tmp i;
						if i > 0 then
							strset Location i-1 '.'
					)
					else (
						set j = j - 1;
						strset Location i-1 (strget tmp i)
					)
				);

				parseans s End n-1; // ON RELANCE LE TRAITEMENT (Pour toutes les r√©ponses)
				
				let [SrvPriority:Priority SrvWeight:Weight SrvPort:Port SrvTargetS:Location] -> AnswerSrv in (
					if SrvAnswerL == nil then set SrvAnswerL = AnswerSrv::nil	// ON AJOUTE DANS LA LISTE DES REPONSES
					else set SrvAnswerL = AnswerSrv::SrvAnswerL;
					nil
				)
			)
		)
		else parseans s (j+10+strgetword s j+8) n-1
	);;

fun parsemsg s=
	let strgetword s 0 -> id in
	let strgetword s 2 -> code in
	let strgetword s 4 -> nbqu in
	let strgetword s 6 -> nbans in
	if nbans==0 then nil
	else let parsequs s 12 nbqu -> i in
		parseans s i nbans
;;

fun filterdns src=
	let strfind src 0 "." 0 nil ->i in
	if i!=nil then
		strcat
			strcat ctoa i strsub src 0 i
			filterdns strsub src i+1 nil
	else strcat ctoa strlen src src;;

/**
	makes a dns request
*/
fun question id dns=
	strcatlist (itobin2 id)::"\$01\$00\$00\$01\$00\$00\$00\$00\$00\$00"::(filterdns dns)::"\$00\$00\$01\$00\$01"::nil;;

var dnsid=0;;

type Dns=[idD domainD reqD timeoutD cbD idxDnsD ];;
var ldnsreq;;


// liste contenant un cache dns. Les √©l√©ments de la liste sont des
// tuples [ nomdedomaine [ ip time_valid ] ]
// un element de la liste est p√©rim√© lorsque time > time_valid
var ldns;;


// aide pour dnsremoveipfromcache
fun dnsremoveipfromcacheR l iptoremove =
	if nil!=l then
	(
		let hd l -> [ ip _ ] in
			if iptoremove==ip then
				tl l
			else
				hd l :: (dnsremoveipfromcacheR tl l iptoremove) :: nil
	)
	else
		l
;;

// retire une ip du cache contenu dans ldns
//  ip: l'ip a retirer
fun dnsremoveipfromcache iptoremove =
	Dnsw strcatlist "DNS: CACHE: cache for ip " :: iptoremove :: " has expired. removing it" :: nil;
	set ldns = dnsremoveipfromcacheR ldns iptoremove
;;

// recherche l'url associ√©e √† un nom de domaine et appelle le callback une fois trouv√©
// 
//  domain: le domaine √† rechercher
//  cb: le callback √† appeler
fun dnsreq domain cb=
	Dnsw "dnsreq("; Secho domain; Secholn ")";
	set dnsid=(if dnsid==nil then time_ms else (dnsid+1));
	let listswitchstr ldns domain -> [ ip time_valid ] in
		if (ip!=nil && time < time_valid)
			then (Dnsw "ip dans le cache"; call cb[ip])
	else let dump question dnsid domain -> tramedns in
	(
		Dnsw strcatlist "on fait une requete dns pour le domaine " :: domain :: nil;
		if (nil!=ip) then // il y a une reponse dans le cache mais elle est p√©rim√©e
			dnsremoveipfromcache ip;
		let listnth netdnslist 0 -> netdns in
			udpsend netip DNSLOCAL netdns 53 tramedns nil;
		set ldnsreq=[idD:dnsid domainD:domain reqD:tramedns timeoutD:time+5 cbD:cb idxDnsD:0]::ldnsreq;
		nil
	);
	0;;

/**
	Tells, for a (failed) dns request, if there is another dns server that could possibly answear the request
*/
fun dnsHasAnotherServer x =
	(listlen netdnslist) > (x.idxDnsD+1)
;;


/**
	Replaces the id at the beginning of the trame by a new one
*/
fun dnsChangeIdInTrame oldTrame newId =
	strcatlist (itobin2 newId)::(strsub oldTrame 2 nil) :: nil;;

/**
	Asks the next dns server in the list the dns request contained in x. It is assumed that there _is_ a next server, ie dnsHasAnotherServer has been called and returned != 0
*/
fun dnsAskNextServer x =
	Dnsw strcatlist ("DNS -- pas de reponse pour la requete " :: (itoa x.idD) :: " donc on en essaie un autre. dns numero " :: (itoa x.idxDnsD+1) :: " -> " :: (webip listnth netdnslist (x.idxDnsD+1)) :: nil);
	let (listnth netdnslist (x.idxDnsD+1)) -> netdns in
	let (dnsChangeIdInTrame x.reqD (set dnsid=(dnsid+1))) -> newtrame in
	(
		Dnsw strcatlist ("la nouvelle requete a le numero " :: (itoa dnsid) :: nil);
		udpsend netip DNSLOCAL netdns 53 newtrame nil;
		set ldnsreq=[idD:dnsid domainD:(x.domainD) reqD:newtrame timeoutD:(time+5) cbD:(x.cbD) idxDnsD:(x.idxDnsD+1)]::ldnsreq
	);
	nil
;;

/**
	Helper func for select in cbnetdns
*/
fun selectbyid d v= d.idD==v;;

// callback appel√© pour chaque paquet udp qui arrive 
// sur le port DNSLOCAL (sett√© dans startdnsclient)
fun cbnetdns msg mac ipfrom= 
	Dnsw strcatlist "cbnetdns [" :: msg :: "]" :: nil; 
	let strgetword msg 0 -> id in
	let parsemsg msg -> [ ip ttl ] in
	let hd select ldnsreq id #selectbyid -> x in
	if x!=nil then
	(
		Dnsw strcatlist ("on recoit une reponse pour une question dns, id " :: (itoa id) :: ", ip = " :: (if nil!=ip then ip else "nil") :: " pour le domaine " :: x.domainD :: nil);
		Dnsw strcatlist ("cette requete etait avec le serveur numero " :: (itoa x.idxDnsD) :: ", c'est a dire l'ip " :: (webip listnth netdnslist (x.idxDnsD)) :: nil);

		set ldnsreq=listrem ldnsreq x;

		// check if the answear is empty. if it is, we should try to ask the next dns server
		if (ip == nil && ttl == nil && (dnsHasAnotherServer x)) then
			( dnsAskNextServer x; nil)
		else
		(
			if ip!=nil then
				set ldns = [ x.domainD [ ip (time + ttl)] ]::ldns	// ### attention √† la taille de la liste
			else
				(Dnsw "ip est nil"; nil);
			call x.cbD [ip]
		)
	)
	else
		(Dnsw "x nil"; 0);
	0;;

/**
	Removes from the list l the dns requests that have done a timeout
*/
fun filterdnsdead l=if l!=nil then let hd l-> d in if d.timeoutD==nil then filterdnsdead tl l else (hd l)::filterdnsdead tl l;;

/**
	Checks if any dns request has timeouted and either relays the
	request to the next dns server available or calls the callback with	
	a null answear.
*/
fun dnstime=
	for l=ldnsreq;l!=nil;tl l do let hd l-> d in
	if time-d.timeoutD>=0 then
	(
		set d.timeoutD=nil;
		Dnsw strcatlist "dnstime, timeout pour la requete d'id " :: (itoa d.idD) :: nil;
		// s'il y a un dns "de secours", on l'utilise. sinon, on appelle la cb avec nil
		if (dnsHasAnotherServer d) then
			( dnsAskNextServer d; 0 )
		else
			(call d.cbD [nil] ; 0)
	);
	set ldnsreq=filterdnsdead ldnsreq;
	0;;


// d√©marre le client dns. en particulier, sette le callback qui sera
// appel√© pour tous les paquets udp entrants sur le port DNSLOCAL
fun startdnsclient=

	// on ajoute les dns "de secours" s'ils ne sont pas d√©j√† dans la liste
	addnewdns confGetNetdns 0;

	regudp DNSLOCAL #cbnetdns;
	set ldnsreq=nil;
	set ldns=nil;
	0;;

fun isip s i=
	if i>=strlen s then 1
	else let strget s i -> c in
	if (c<'0' || c>'9')&&c!='.' then 0
	else isip s i+1;;

fun DnsSrvCb2 ip Params=
	let Params -> [Port cb] in
	(
		call cb [ip Port]
	)
;;

// CALLBACK DU DnsSrv
fun DnsSrvCb NotUse cb=
	Dnsw "DnsSrvCb";
	if SrvAnswerL != nil then (			// Si le callback a ete appele et qu'il n'y a aucun parametre, on passe en BOSH
		Dnsw "Reponse pas nil";
		let hd SrvAnswerL -> Actuel in	//  ON TENTE SUR LE PREMIER de la liste : REGLE SRV A FAIRE ICI
		(
			if isip Actuel.SrvTargetS 0 then				// Si on a une ip, on lance la connexion directement
				call cb [Actuel.SrvTargetS Actuel.SrvPort]	// SI C'est une IP
			else (
				Dnsw strcatlist ("On a recu " :: Actuel.SrvTargetS :: " et on enchaine donc sur une requete dns" :: nil);
				dnsreq Actuel.SrvTargetS fixarg2 #DnsSrvCb2 [Actuel.SrvPort cb];

			0); // Sinon on lance la resolution en donnant le callback
			set SrvAnswerL = tl SrvAnswerL;	// On vide la liste petit √† petit, il faudra vider cette chaine dans le callback (sinon on empilera les dns)
			0
		)
	)else(
		Dnsw "SrvAnswerL nil";
		call cb [nil nil];
		0
	)
;;

// REQUETE DNS SRV
fun DnsSrv Request CallBack=
	set dnsid=if dnsid==nil then time_ms%9999 else dnsid+1;	// ON MET l'ID pour identifier par la suite
	Dnsw strcatlist "requete DNS SRV. dnsid=" :: (itoa dnsid) :: nil;
	Dnsw dnslisttostr;
	let filterdns Request -> domain in
	let strcatlist (itobin2 dnsid)::"\$01\$00\$00\$01\$00\$00\$00\$00\$00\$00"::domain::"\$00\$00\$21\$00\$01"::nil -> dnssrvquestion in
	let dump dnssrvquestion -> tramedns in // Creation de la question
	(
		let listnth netdnslist 0 -> netdns in (
		  Dnsw webip netdns;
			udpsend netip DNSLOCAL netdns 53 tramedns nil) ; // On lance la requete sur le DNS
		set ldnsreq=[idD:dnsid domainD:Request reqD:tramedns timeoutD:time+7 cbD:fixarg2 #DnsSrvCb CallBack idxDnsD:0]::ldnsreq;
		nil
	);
0;;



/**
	Helper func for addnewdns_r.
*/
fun removedns_r dns lst =
	if (nil != lst) then	
	(
		if !(ipcmp dns hd lst) then
			(tl lst)
		else
			(hd lst) :: (removedns_r dns tl lst)
	)
	else
		nil
;;

/**
	Helper func for addnewdns.
*/
fun addnewdns_r dns lst front =
	if (front) then
		dns :: (removedns_r dns lst)
	else
		(
			if (nil!=lst) then
				(
					if (!ipcmp dns (hd lst)) then
						// dns is present, nothing to do
						lst
					else
						(hd lst) :: (addnewdns_r dns tl lst 0)
				)
			else
				dns :: nil
		)
;;

/**
	Adds a new dns server in list of dns servers.
	Skips if dns is "0.0.0.0".

	If the dns is already in the list and front si set, the dns is moved
  to the front of the list. Otherwise nothing is done.

	dns: the dns to add
	front: if 1 the dns will be added in front, else at the back
*/
fun addnewdns dns front =
	if !(strcmp dns "\0\0\0\0") then
		netdnslist
	else
		set netdnslist = addnewdns_r dns netdnslist front
;;

/**
	Adds a list of new dns servers in front of the existing list of dns servers
*/
fun addnewdnslist dnslist =
	set netdnslist = conc dnslist netdnslist
;;

/**
	Helper func for dnslisttostr
*/
fun dnslisttostr_r l =
	if (nil != l) then
		(webip hd l) :: " " :: (dnslisttostr_r tl l)
	else
		nil
;;

/**
	Returns a string representation of the ip in the dns list
*/
fun dnslisttostr =
	strcatlist "(" :: (itoa listlen netdnslist) :: ") - " :: (dnslisttostr_r netdnslist)
;;


/**
	Called when receiving a new list of dns servers from dhcp. Updates the current dns list.
*/
fun dnslistfromdhcp dnslist =
	set netdnslist = dnslist;
	addnewdns confGetNetdns 0
;;
// end of file dns.mtl //
// back to file dhcp.mtl, line 223
// end of file dhcp.mtl //
// back to file STDIN, line 93
// file net.mtl //
// file net_protos.mtl //
proto netstart 0 ;;
proto nettime 0 ;;
proto netSend2 2 ;;
// end of file net_protos.mtl //
// back to file net.mtl, line 1
// file net_vars.mtl already included

// file tcp_protos.mtl already included
// file udp_protos.mtl already included
// file arp_protos.mtl already included

//proto cbnetarp 2 ;;

fun net src mac=
	let strget src 7 -> p in
	(
		if p==6 then cbnetarp src mac // ARP
		else if p==0 then
			let strget src 17 -> ip in
			if ip==6 then cbnettcp src mac
			else if ip==17 then cbnetudp src mac;
		0
	);
// 	buttoncheckevent; // don't understand why there should be a buttoncheckevent here, it's already in the loop !
	0;;

fun netstart=
	netCb #net;
	resetarp;
	resettcp;
	resetudp;
	0;;

fun nettime=
	arptime;
	tcptime;
	0;;


/**
	Simplified version of the builtin netSend.
*/
fun netSend2 trame mac =
	netSend trame 0 nil mac 0 1
;;

// file tcp.mtl already included
// file udp.mtl already included
// file arp.mtl already included
// end of file net.mtl //
// back to file STDIN, line 94

// file dns.mtl already included

// file http.mtl //
const HTTP_NORMAL=0;;
const HTTP_STREAM=1;;
const HTTP_DIRECT=2;;

const HTTP_SOLVE=0;;
const HTTP_REACH=1;;
const HTTP_CONNECTED=2;;

var lasthttpevent;;

// type Httpreq contenant l'√©tat d'une requ√™te
//  - sonH : requ√™te fille s'il y a (cas des 302 o√π on a fait une redirection via une nouvelle requ√™te)
type Httpreq=[cnxH inputH outputH indexH cbH typeH stateH aliveH sonH redirLevelH];;

proto httprequest 5;;
proto httpabort 1;;

//## retourne le code r√©ponse HTTP d'une r√©ponse
//  - s est une chaine, le d√©but de la r√©ponse http
fun httpgetcode s =
	// le code est sur la premi√®re ligne, de type "HTTP/1.? XXX etc..." o√π XXX est le code
	let strstr s " " 0 -> i in
		let strstr s " " i -> j in
			atoi strsub s i+1 j ;;


//## g√®re le cas o√π on a re√ßu une 302 ("moved temporarly") en r√©ponse
//  - cnx la socket de connection de httptcpread
//  - httpreq la request qui nous dit qu'il faut forwarder
// On cherche la nouvelle Location, et on cr√©e un fils √† la requ√™te courante.
fun httphandletmpredirect cnx httpreq =
	httpabort httpreq;
	Xw "HTTP - redirection temporaire";
	if (httpreq.redirLevelH > 2) then // on arrive √† la 3eme redirection, c'est trop
		( Xw "HTTP - trop de niveaux de redirection : stop"; call httpreq.cbH [httpreq nil] ; nil )
	else
		// reconstruire toute la chaine de r√©ponse, elle ne doit pas √™tre bien longue
		let strcatlist rev httpreq.inputH nil -> reponse in
		(
			let strstr reponse "\13\nLocation: " 0 -> i in
				if nil == i then // pas de location -> erreur
					(
						Xw "HTTP - Could not follow redirection, no 'Location:' found.";
						call httpreq.cbH [httpreq nil] ;
						nil
					)
				else
					let strstr reponse "\13\n" (i+2) -> finloc in
					(
					let strsub reponse (i+12) (finloc-i-11) -> newurl in
					// ici on a l'url vers laquelle on veut rediriger dans newurl.
					(
						Xw "HTTP - Following redirection. new url [" ; Xw newurl; Xw "]";
						let httprequest "GET" newurl nil httpreq.cbH httpreq.typeH -> newReq in
						(
							set newReq.redirLevelH = httpreq.redirLevelH + 1;
							set httpreq.sonH = newReq;
							set httpreq.cbH = nil
						);
					nil
					)
					)
		);
nil;;


// callback de lecture sur la socket d'une requ√™te
fun httptcpread cnx input httpreq=
//	Xw "in httptcpread. input=["; Xw input; Xw "]";
	if input==nil ||0==strlen input then	// erreur ou fin
	(	closetcp cnx;	// on ferme la socket
		if httpreq.typeH==HTTP_NORMAL then
		(
			let rev httpreq.inputH nil -> l in
			let strcatlist l -> s in
			let httpgetcode s -> code in
				if code == 200 then
					call httpreq.cbH [httpreq strcatlist rev httpreq.inputH nil]	// on retourne ce qui a √©t√© re√ßu
				else if code == 302 then
					httphandletmpredirect nil httpreq
				else // 404 ? autre ?
					call httpreq.cbH [httpreq nil]
		)
		else
			call httpreq.cbH [httpreq nil] // HTTP_STREAM or HTTP_DIRECT
	)
	else
	(
//		dump input;
		set lasthttpevent=time;
		set httpreq.aliveH=time_ms;
		if httpreq.typeH==HTTP_NORMAL then
			set httpreq.inputH=input::httpreq.inputH	// on bufferise ce qui a √©t√© re√ßu
		else if httpreq.typeH==HTTP_DIRECT then
		(
			call httpreq.cbH [httpreq input];
			nil
		)
		else
		(
			let strcat hd httpreq.inputH input -> s in
			let strstr s "\13\10\13\10" 0 -> i in
			if i==nil then
				set httpreq.inputH=s::nil
			else
			(
				let httpgetcode s -> code in
				if code == 200 then
				(
					set httpreq.inputH=nil;
					set httpreq.typeH=HTTP_DIRECT;
					call httpreq.cbH [httpreq strsub s 0 i];
					if i+4<strlen s then call httpreq.cbH [httpreq strsub s i+4 nil];
					nil
				)
				else if code == 302 then
				(
					set httpreq.inputH = s::nil;
					httphandletmpredirect cnx httpreq;
					nil
				)
				else // 404 ? autre ?
				( call httpreq.cbH [httpreq input]; nil )
			);
			nil
		);
		nil
	);;

// callback d'√©criture sur la socket d'une requ√™te
fun httptcpwrite cnx httpreq=
	set httpreq.stateH=HTTP_CONNECTED; 
	set httpreq.aliveH=time_ms;	
	if httpreq.outputH!=nil then	// s'il y a des choses √† envoyer (notamment la premi√®re fois)
	(
		Secholn "httptcpwrite";
		set httpreq.indexH=writetcp cnx httpreq.outputH httpreq.indexH;	// envoyer ce qui peut l'√™tre
		if httpreq.indexH==nil then	// si erreur lors de l'envoi
		(	closetcp cnx;	// on ferme la socket
			call httpreq.cbH [httpreq nil]	)	// on retourne nil
		else if httpreq.indexH>=strlen httpreq.outputH then	// sinon si tout a √©t√© envoy√©
		(	set httpreq.indexH=nil;	// purger les donn√©es d'√©mission
			set httpreq.outputH=nil;
			nil
		)
	);;

const http_prefurl="http://";;	// en-t√™te normal (mais ici facultatif) d'une requ√™te http


// d√©couper une url en [host port path].
// host est de la forme ip:port
// path ne commence pas par /
fun cuturl url =
	if !strcmp (strsub url 0 strlen http_prefurl) http_prefurl then cuturl strsub url strlen http_prefurl strlen url
	else let strstr url "/" 0 -> i in
		let if i==nil then url else strsub url 0 i -> addr in
		let strstr addr ":" 0 -> j in
		let if j==nil then [addr 80]
			else [strsub addr 0 j atoi strsub addr j+1 strlen addr] -> [host port] in
		let if i==nil then "/" else strsub url i strlen url -> path in
		[host port path];;

fun _httptcpevent t val msg sock=
	if val==TCPWRITE then httptcpwrite t sock
	else if val==TCPCLOSE then httptcpread t nil sock
	else httptcpread t msg sock;
	0;;


fun httpsendreq ip x=
	Secho "found ip="; Secholn ip;
	let x->[port httpreq] in
	if ip==nil then (call httpreq.cbH [httpreq nil]; nil)
	else
	(
		set httpreq.cnxH=opentcp netip nil useparamip ip port fixarg4 #_httptcpevent httpreq;
		set httpreq.stateH=HTTP_REACH;
		nil
	);
	0;;


//##> cr√©ation d'une requ√™te http
// param√®tres : verb=verbe de la requ√™te url=url de la requ√™te postdata=donn√©es suppl√©mentaires (nil si aucune) cb=callback de retour
fun httprequest verb url postdata cb type=
	Secho "HTTPREQUEST url=";Secholn url;
	let cuturl url ->[host port path] in	// d√©codage de l'url de la requ√™te
	let if confGetProxy then strcatlist "http://"::host::":"::(itoa port)::path::nil else path -> path in //Icy-MetaData:1\13\n
	let strcatlist verb::" "::path::" HTTP/1.0\13\nUser-Agent: MTL\13\nPragma: no-cache\13\nIcy-MetaData:1\13\nHost: "::host::"\13\n"::
			if postdata==nil then "\13\n"::nil
			else "Content-length: "::(itoa strlen postdata)::"\13\n\13\n"::postdata::nil
		-> request in	// cr√©ation de la cha√Æne requ√™te
	let if confGetProxy then webip confGetProxyip else host -> host in
	let if confGetProxy then confGetProxyport else port -> port in
	let [outputH:request indexH:0 cbH:cb typeH:type stateH:HTTP_SOLVE aliveH:time_ms sonH:nil redirLevelH:0] -> httpreq in	// cr√©ation de la structure requ√™te
	(
		if isip host 0 then httpsendreq host [port httpreq]
		else
		(
			dnsreq host fixarg2 #httpsendreq [port httpreq];
			nil
		);
		httpreq	// on retourne la structure requ√™te pour pouvoir √©ventuellement l'interrompre en cours de route
	);;

//##> interruption d'une requ√™te en cours
// on interromp la requ√™te et son fils (si elle en a un)
fun httpabort httpreq=
	if (nil != httpreq.sonH) then httpabort httpreq.sonH;
	closetcp httpreq.cnxH;;	// on ferme la socket de la requ√™te

fun httpenable httpreq v=
	enabletcp httpreq.cnxH v;;
fun httpenabledP httpreq=
	enabledtcpP httpreq.cnxH;;

fun httpstate httpreq = httpreq.stateH;;

fun httpinactive httpreq = time_ms-httpreq.aliveH;;


const http_sep="\13\n\13\n";;	// s√©parateur entre l'en-t√™te et le corps de la r√©ponse √† une requ√™te

	

//##> retourne le header d'une r√©ponse √† une requ√™te
fun httpgetheader res =
	let strstr res http_sep 0 -> i in
	if i==nil then res
	else strsub res 0 i+strlen http_sep;;

//##> retourne le contenu d'une r√©ponse √† une requ√™te (sans header)
fun httpgetcontent res =
	let strstr res http_sep 0 -> i in
	if i==nil then nil
	else strsub res i+strlen http_sep strlen res;;

// end of file http.mtl //
// back to file STDIN, line 99


/**
	Les diffÈrents Ètats de la boucle principale.
*/
type Run= configstartRun | configwaitRun _ | interactiveReqWaitRun _ |
	rscLoadNextRun | rscLoadWaitRun _ | chorCmdRun _ |streamCmdRun _ | waitCmdRun _ | cmdEvalOne _ | idleRun | sleepRun |
	recordRun |earResetWaitRun _| recordStartRun | xmppLoginRun | xmppReconnectRun _ ;;

var run;;

/**
	Returns a string representation of the run variable
*/
fun runToStr run =
	match run with
    ( configstartRun -> "configStartRun")
  | (configwaitRun _ -> "configWaitRun")
	| (interactiveReqWaitRun _ -> "interactiveReqWaitRun")
	| (rscLoadNextRun -> "rscLoadNextRun" )
	| (rscLoadWaitRun _ -> "rscLoadWaitRun" )
	| (chorCmdRun _ -> "chorCmdRun" )
	| (streamCmdRun _ -> "streamCmdRun" )
	| (waitCmdRun _ -> "waitCmdRun" )
	| (cmdEvalOne _ -> "cmdEvalOne" )
	| (idleRun -> "idleRun" )
	| (sleepRun -> "sleepRun" )
	| (recordRun -> "recordRun" )
	| (earResetWaitRun _ -> "earResetWaitRun" )
	| (recordStartRun -> "recordStartRun" )
	| (xmppLoginRun -> "xmppLoginRun" )
	| (xmppReconnectRun _ -> "xmppReconnectRun" )
;;


//------------------- MOT DE PASSE POUR LE PROTOCOLE XMPP
const XMPP_PASSWORD_CHECK = 1;;
const XMPP_PASSWORD_LENGTH = 12;;

// get the password which is in the configuration of the nabaztag
fun GetXmppPassword =
	let "n" -> PasswordSet in
	let "d" -> PasswordCheck in
	let load PasswordSet 0 "conf.bin" (CONF_LENGTH) XMPP_PASSWORD_CHECK -> tmp1 in
	(
		if (strstr PasswordSet PasswordCheck 0) == 0 then (
			let strnew XMPP_PASSWORD_LENGTH -> PasswordGet in
			let load PasswordGet 0 "conf.bin" (CONF_LENGTH+XMPP_PASSWORD_CHECK) XMPP_PASSWORD_LENGTH -> tmp1 in
				PasswordGet
		)
		else
			nil
	)
;;

// Set a new random password in the configuration of the nabaztag
fun GenXmppPassword =
	srand time_ms;
	let strsub (md5 strcatlist (itoa rand)::(fullwebmac netMac)::(itoa time_ms)::nil) 1 XMPP_PASSWORD_LENGTH -> NewPassword in
		NewPassword
;;
	
// Set a new random password in the configuration of the nabaztag
fun SetXmppPassword NewPassword=
	let strcatlist "d"::NewPassword::nil -> PasswordAndDone in
		save PasswordAndDone 0 "conf.bin" (CONF_LENGTH) (XMPP_PASSWORD_LENGTH+XMPP_PASSWORD_CHECK)
;;

// Set a new random password in the configuration of the nabaztag
fun ResetXmppPassword =
	let "zeyzjsuzjsu" -> PasswordAndDone in
		save PasswordAndDone 0 "conf.bin" (CONF_LENGTH) (XMPP_PASSWORD_LENGTH+XMPP_PASSWORD_CHECK)
;;



//DEBUG

var NOWREGISTER = 0;;


proto boshurl 1;;
proto earInit 0;;
proto sendmailxmppurl 2;;


// ---------------------------------------------------------
// XMPP Configuration
// ---------------------------------------------------------
const XmppTcpIdleTime = 8;;							// Si il ne se passe rien pendant 8 secondes sur le flux, on le maintient ouvert en envoyant un " "
var XmppGlobalSession = nil;;							// La session Xmpp

const XmppVioletPlatformComponent = "xmpp.platform.violet.net";;
const XmppVioletObjectsComponent = "xmpp.objects.violet.net";;
const XmppVioletAppletComponent = "xmpp.applet.violet.net";;
const XmppVioletPlatformClient = "net.violet.platform";;

const TcpServerNoResponseTimeOut = 2;;	// When opentcp don't response after x sec, try another server

const XmppTcpOpenStream1 = "<?xml version='1.0' encoding='UTF-8'?>\n<stream:stream to='";;
const XmppTcpOpenStream2 = "' xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'>\n";;
var XmppTcpCloseStream = "</stream:stream>";;


const XmppBoshHttpTimeOut = 30;;

// the delay between two 'ping' packets
const XmppPingDelay = 60;;
// the maximum number of seconds that we can wait between sending a ping request and getting the response
const XmppPingMaxReponseDelay = 5;;



const XmppBoshEncapsulation1 = "<body rid='";;
const XmppBoshEncapsulation2 = "' sid='";;
const XmppBoshEncapsulation3= "' xmlns='http://jabber.org/protocol/httpbind'>";;
const XmppBoshEncapsulation4 = "</body>";;

const XmppBoshOpenStream1 = "<body content='text/xml; charset=utf-8' hold='15' rid='";;
const XmppBoshOpenStream2 = "' to='";;
const XmppBoshOpenStream3 = "' route='xmpp:";;
const XmppBoshOpenStream4 = "' secure='true' wait='7' xml:lang='en' xmpp:version='1.0' xmlns='http://jabber.org/protocol/httpbind' xmlns:xmpp='urn:xmpp:xbosh'/>";;

const XmppBoshReOpenStream1 = "<body rid='";;
const XmppBoshReOpenStream2 = "' sid='";;
const XmppBoshReOpenStream3 = "' to='";;
const XmppBoshReOpenStream4 = "' xml:lang='en' xmpp:restart='true' xmlns='http://jabber.org/protocol/httpbind' xmlns:xmpp='urn:xmpp:xbosh'/>";;


// Variables diverses
var SendTry = 0;;	// Permet de compter le nombre de tentative d'envoie d'une requete defectueuse
	


// ---------------------------------------------------------
// XMPP SESSION
// ---------------------------------------------------------

const XmppSessionReadTimeout = 60;; // temps maximum tolÈrÈ au bout duquel on n'entend plus parler du serveur.

proto XmppSessionStart 2;;	// Open a session (call one time)
proto XmppSessionStop 1;;
proto XmppSessionIdle 0;;	// Always called
proto XmppSessionRun 0;;	// Always called 
proto XmppSessionSend 2;;
proto XmppSessionResponseSend 2;;
proto XmppSessionResponseSendErrorFeatureNotImplemented 3;; // to answear some unhandled requests
proto XmppSessionRead 2;;
proto XmppSessionSendButtonMsg 3;;
proto XmppSessionSendEarMsg 2;;
proto XmppSessionRequestResource 1;;
proto XmppSessionUnreachable 1;; 	// Can't open a session (example after trying in bosh)
proto XmppSessionIsDisconnected 1;; // We don't know where we are but we seem to be disconnected
proto XmppSessionProcess 2;;		// Process for the CTED!!! RESTART? WE ARE connexion, deals with all type of messages
proto XmppSessionProcessR 3;;		// Process for the CTED!!! RESTART? WE ARE connexion, deals with all type of messages
proto XmppSessionUpdate 1;;			// When the status is changed



type tXmppSessionStreamState = ssRegister1 | ssRegister2 | ssBind | ssUnBind | ssStartSession | ssGetSource | ssFree | ssLogging | ssPresence ;;
// ss >> Stream State
// Register1 > PremiËre phase de l'enregistrement
// Register2 > Seconde phase de l'enregistrement
// Bind > Acquisition de la Ressource
// UnBind > Rendre la Ressource
// Session > Creation d'une session
// Source > RecupÈration des sources
// Free > Libre pour des actions
// ssLogging > On est en train de se connecter
// ssPresence > Juste apres un session idle sinon bloquant en tcp si on a nextressource != nil
type tXmppSessionStanzaTypes = stanzaIQGet | stanzaIQSet | stanzaIQResult _ | stanzaMessage | stanzaPresence | stanzaIQError _;;
type tXmmpSessionClient = [clINT clASR clPPT clRFID clITMODE clSOURCES];;
// Etats de la session:
// sOpening: Ètat initial.
// sLogging: on essaye de se connecter (on a bien un compte ou on pense qu'on a bien un compte)
// sLoggedin: on a passÈ l'identification (succËs sur le mot de passe)
// sOpened: connectÈ (i.e., on a passÈ la phase identification & l'ouverture de session)
// sClosed: la sessions est fermÈe (on ne passe jamais dans cet Ètat)
// sRegistrationError: Ètat final, le lapin est en rouge (jusqu'au reboot)
type tXmppSession_Status = sOpening | sLogging  | sLoggedin | sOpened | sClosed | sRegistrationError;;
type tXmppSession = [/*GATE*/ sGate sStatus /*SASL*/ sNonce sCnonce sRealm sUsername sPassword sQop sAlgo sCharset sDomain /* Stream State */ sJID sPreviousResource sNextResource sNextResourceBinding sResource sState sInQueue sOutQueue sStanzaID /* Divers */ sClients sDisplayLeds sLastIOTime sLastReadTime sLastStreamState sNextRestart sPacketQueue sDataToSend sLastPingTime sLastPingIqId];;
// NextResourceBinding sert que si on est en train de faire un bind et qu'on souhaite rechanger vers un autre aprËs

// ---------------------------------------------------------
// XMPP GATE > CONNECT, SEND, IDLE in TCP or BOSH
// ---------------------------------------------------------
proto XmppGateConnect 1;;	// Try to connect to the server (will we don't get a <stream:stream>
proto XmppGateSend 2;;		// Try to send something to the server
proto XmppGateRead 2;;		// Receive something from the server
proto XmppGateIdle 1;;		// Observe Xmpp stream
proto XmppGateOpenStream 1;;// Send the data to open stream with server
proto XmppGateStreamOpened 1;;	// le stream a bien ÈtÈ ouvert
proto XmppGateStreamClosed 2;; // if the stream has been closed

type tXmppGate_Mode = pTcp | pBosh;;		// 2 Mode : BOSH (port 80) or Normal Tcp (port 5222)
type tXmppGate_Status = pOpening | pOpen | pInStream | pClosing | pClose;;	// Opening (try to open port), Open (try to send <stream:stream>)
type tXmppGate = [pParent pMode pStatus pTry pTcpV pBoshV pBuffer pSId pActualMode];;
// pParent > xSession
// pMode (pTcp / pBosh)
// pStatus (pOpening, pOpen...)
// pTry (3 to 1 > Normal TCP, 0 > Bosh)
// pTcpV = struct for tcp
// pBoshV = struct for Bosh

// ---------------------------------------------------------
// XMPP TCP > SEND, READ_CB, IDLE
// ---------------------------------------------------------
proto XmppTcpOpen 3;;	// Try to open the tcp (opentcp...)
proto XmppTcpSend 2;;
proto XmppTcpRead 4;;
proto XmppTcpIdle 1;;	// Check if the stream works
proto XmppTcpOpenStream 1;; // Send the data to open the stream

type tXmppTcp = [xParent xSocket xHost xPort];;

// ---------------------------------------------------------
// XMPP BOSH > SEND, READ_CB, IDLE
// ---------------------------------------------------------
proto XmppBoshSend 2;;
proto XmppBoshRead 3;;
proto XmppBoshIdle 1;;
proto XmppBoshOpenStream 1;; // Send the data to open the stream in BOSH
proto XmppBoshReOpenStream 1;; // Send the data to reopen the stream in BOSH
proto XmppBoshSetUp 2;;		// Configure the ip of the server

type tXmppTcp = [yParent yHttpList yMsgId yServerIp yMaxRequest];;

// ---------------------------------------------------------
// JID utils
// ---------------------------------------------------------
proto xmpps_JIDNode 1 ;;
proto xmpps_JIDResource 1 ;;
proto xmpps_JIDPlatform 1 ;;
proto xmpps_PlatformJID 2 ;;
proto xmpps_ServerJID 1 ;;
proto xmpps_OurJID 1 ;;
proto xmpps_BindJID 2 ;;

// ---------------------------------------------------------
// XMPP utils
// ---------------------------------------------------------
proto xmppStateToStr 1 ;;



// AFAIRE 

proto xmpps_createStanza 5;;
















// ---------------------------------------------------------
// XMPP TCP
// ---------------------------------------------------------

/*
 * Appelle XmppTcpOpen sur le port 5222
 */
fun XmppTcpOpen5222 ip xSession =
		XmppTcpOpen ip 5222 xSession
;;

/* 
 * Ouvre un port TCP pour une session particuliere
 */
fun XmppTcpOpen ip port xSession =
	Xw strcatlist "XmppTcpOpen, back from dnssrvcb "::ip::":"::(itoa port)::nil;
	if ip != nil && port != nil then // Si on a une ip et un port valide, on supprime les anciens et on tente d'ouvrir le port en initialisant le tout
	(
		set xSession.sLastReadTime = time;
		if xSession.sGate.pTcpV != nil then			// On supprime et ferme tout si quelque chose avant existait
		(
			closetcp xSession.sGate.pTcpV.xSocket;	// Fermeture du socket
			set xSession.sGate.pTcpV = nil			// Suppression de la variable
		);

		Xw "Open the tcp Socket";
		let [xParent:xSession xSocket:nil xHost:ip xPort:port] -> newTcp in
		(
			set xSession.sGate.pTcpV = newTcp;
			set newTcp.xSocket = opentcp netip nil (useparamip ip) port fixarg4 #XmppTcpRead xSession	// On ouvre le socket
		);
		0
	)
	else(	// on est a la fin des entrees srv et on a pas reussi a se connecter -> on essaie le domaine xmpp tout court, et si ca ne fonctionne pas on retombera en BOSH
		Xw ( strcatlist "No more SRV answears. let's try to connect directly to " :: xSession.sDomain :: nil );
		dnsreq xSession.sDomain fixarg2 #XmppTcpOpen5222 xSession;
		0)
	;;


/*
 * Rouvre un port TCP pour une session 
 */
fun XmppTcpReOpen ip port xSession =
	//Xw strcatlist "BACK FROM DNS SRV! "::ip::":"::(itoa port)::nil;
	if ip != nil && port != nil then // Si on a une ip et un port valide, on supprime les anciens et on tente d'ouvrir le port en initialisant le tout
        (
		if xSession.sGate.pTcpV != nil then                     // On supprime et ferme tout si quelque chose avant existait
                (
			closetcp xSession.sGate.pTcpV.xSocket;  // Fermeture du socket
                        set xSession.sGate.pTcpV = nil                  // Suppression de la variable
                );

                //Xw "Open the tcp Socket";
                let [xParent:xSession xSocket:nil xHost:ip xPort:port] -> newTcp in
                (
                        set xSession.sGate.pTcpV = newTcp;
                        set newTcp.xSocket = opentcp netip nil (useparamip ip) port fixarg4 #XmppTcpRead xSession       // On ouvre le socket
                );
		0
	)
	else
		XmppTcpOpen ip port xSession;;


/*
	Effectue l'envoi effectif les donnÈes mises en attente sur la
  connection tcp.
	Regarde s'il y a des donnÈes en attente d'Ítre envoyÈes, et
  si c'est le cas, essaie d'en envoyer le plus possible. La socket
	est peut etre dÈja occupÈe, dans ce cas on pourra envoyer 0 donnÈe
	mais ce n'est pas (encore) une erreur.

	retourne le nombde d'octets envoyÈs ce coup si, ou nil s'il y a un
	vrai problËme sur la socket.
*/
fun XmppTcpActuallySendData xSession =
	let xSession.sDataToSend -> [ data index nbTries ] in
	if (nil == data) then
		(Xw "XmppTcpActuallySendData rien a ecrire"; 0)
	else
		(
			let xSession.sGate.pTcpV.xSocket -> socket in
			let writetcp socket data index -> newIndex in
				if (nil != newIndex) then
					(
						set xSession.sLastIOTime = time;	// Mise ‡ jour
						set xSession.sLastReadTime = time;	// SuccËs de l'Ècriture.

						if (newIndex != index) then
							(
								set xSession.sDataToSend =
										[
											(if (newIndex < strlen data) then data else nil)
											(if (newIndex < strlen data) then newIndex else 0)	
											0
										];
								(newIndex - index)
							)
							else
								(
									if (nbTries < 10) then
										(set xSession.sDataToSend = [ data index (nbTries + 1) ] ; 0)
									else
										(set xSession.sDataToSend = [ nil 0 0 ] ; nil)
								)
					)
				else
					(
						Xw "on a un probleme...";
						set xSession.sDataToSend = [ nil 0 0 ];
						nil
					)
		)
;;


/* 
	Envoie un ÈlÈment sur la connexion TCP de la session Xmpp.
	Retourne le nombre de bytes Ècrit : nil problem, autre "OK"
	Met ‡ jour le xSession.sLastIOTime

	Les donnees ne sont pas forcement envoyees tout de suite, elles
	peuvent etre mises en attente si la file d'envoi tcp n'est pas vide.
	Si la file n'est pas vide, alors c'est qu'un envoi est en cours
	(l'envoi des donnÈes actuellement dans la file), et pas terminÈ.
	XmppTcpRead va donc recevoir des avertissements TCP_WRITE lorsque
	la socket sera de nouveau disponible pour Ècrire la suite.
 */
fun XmppTcpSend xSession Data =
	let xSession.sDataToSend -> [ oldData oldIndex nbTries ] in
	if (nil != oldData) then
	(
		// ajouter les donnees qu'on veut envoyer aux donnees qu'il va falloir envoyer
			Xw "envoi differe";
			set xSession.sDataToSend =
				[
					( strcatlist oldData :: Data :: nil )
					( oldIndex )
					nbTries
				];
		0
	)
	else
	(
		Xw "envoi direct";
		set xSession.sDataToSend = [ Data 0 0 ];
		XmppTcpActuallySendData xSession
		// on ne checke pas le retour. Dans tous les cas :
		//  - soit la donnÈe est bien partie, pas de pb
		//  - soit il y a de l'attente, elle sera envoyÈe au prochain passage dans XmppTcpRead
		//  - soit il y a un pb dÈfinitif, de toutes maniËres on l'aura encore au prochain passage dans XmppTcpRead
	)
;;


/*
 * Lecture par TCP
 * Met ‡ jour le xSession.sLastIOTime et sLastReadTime
 * Si il y a des Stanzas ‡ lire > 	XmppGateRead
 * Si on ouvre la session > 		XmppGateStreamOpened
 * Si le flux est fermÈ > 			XmppGateStreamClosed
 */
fun XmppTcpRead t val msg xSession =
	Secholn "XmppTcpRead";
	if xSession.sGate.pTcpV != nil then if xSession.sGate.pTcpV.xSocket == t then // La requete n'est plus valable
	(
		if val == TCPWRITE then (					// succËs de l'ouverture du socket
			Secholn "TCPWRITE";
			match xSession.sGate.pStatus with
			  ( pInStream -> Secholn "pInStream"; nil )
			| (_ -> // Si on est pas deja dans le flux...
				// Dans se cas on vient d'ouvrir le tcp!
				set xSession.sGate.pStatus = pOpen;		// on change alors les status
				set xSession.sLastIOTime = time;			// et sinon met ‡ jour pour une action plus rapide
				set xSession.sGate.pTry = 3;
				nil
			);
			// envoi des donnes xmpp en attente d'envoi si on en a
			if (nil == XmppTcpActuallySendData xSession) then
				XmppSessionIsDisconnected xSession;
			0
		)else if val == TCPREAD then (		// Le serveur dÈclenche une action

			set xSession.sLastIOTime = time;	// Mise ‡ jour
			set xSession.sLastReadTime = time;
			
			
			/* DEUX MODE : - ON EST EN TRAIN D'Ouvrir >> on attend le <stream:stream
			               - ON EST DANS <stream:stream> */
			match xSession.sGate.pStatus with
			(pInStream -> // Now we are in the stream so normal parsing
				set xSession.sGate.pBuffer = strcatlist xSession.sGate.pBuffer::msg::nil;	// Mise ‡ jour du buffer d'entrÈe
				
				let strstr xSession.sGate.pBuffer "</stream:stream>" 0 -> stream_end in		// Si on a une fermeture du stream
					if stream_end != nil then
						XmppGateStreamClosed xSession pTcp;

			0) | ( _ -> // Si on est dans un autre mode
				
				set xSession.sGate.pBuffer = strcatlist xSession.sGate.pBuffer::msg::nil;
				
				let strstr msg "<stream:stream" 0 -> stream_pos in	// on dÈtecte la balise stream
				if (stream_pos != nil) then (
					let strstr msg ">" stream_pos -> stream_close_pos in		// on dÈtecte la fermeture de cette balise
					let (strstr msg "id='" stream_pos)+4 -> stream_id_pos in	// on cherche l'attribut id
					let strstr msg "'" stream_id_pos -> stream_idend_pos in		// on cherche l'attribut id
					if (stream_close_pos != nil) then (							// si on a bien la fermeture de la balise
						if stream_id_pos != nil && stream_idend_pos != nil then	// on enregistre l'id
							set xSession.sGate.pSId = strsub msg stream_id_pos (stream_idend_pos-stream_id_pos);
						set xSession.sGate.pBuffer = strsub msg (stream_close_pos + 1) nil;
						XmppGateStreamOpened xSession	// le flux est ouvert
					)						
				);
			0);

			while ( if xSession.sGate.pBuffer == nil then 0						// Si on a rien dans le buffer, il ne se passe rien
				else (
					let ParseXMLPacket xSession.sGate.pBuffer -> xmlStanza in	// Sinon on parse ce qu'il y a dans le buffer, et on envoie
					(
						set xSession.sGate.pBuffer = xmlStanza.EndStrS;			// On met le reste qui n'a pas ete traite dans le buffer
						if xmlStanza.inXml != nil then (
							XmppGateRead xSession xmlStanza.inXml;					// On dÈclenche l'action
							1
						) else 0
					)
				)
			) do nil;

			0
		)else if val == TCPCLOSE then ( 	// Le Socket est fermÈ, on est dÈconnectÈ
			XmppGateStreamClosed xSession pTcp;
			0
		)else if val == TCPSTART then 0		// JAMAIS UTILISE
		else (Xw strcatlist "TCPVAL : "::(itoa val)::nil; 0);
		0
	);
	0
;;

/*
 * Idle pour le TCP
 * Maintien la connexion
 */
fun XmppTcpIdle xSession =
	// Si la derniere action est inferieur au time out : on maintient la connexion avec l'envoie d'un espace
	if time - xSession.sLastIOTime > XmppTcpIdleTime then (
		XmppGateSend xSession " "
	);
0;;


/*
 * On envoie l'ouverture du flux <stream:stream...
 */
fun XmppTcpOpenStream xSession =
	set xSession.sGate.pActualMode = 1; //TCP
	set xSession.sGate.pStatus = pOpening;	// changement d'etat de la connexion
	let strcatlist XmppTcpOpenStream1::xSession.sDomain::XmppTcpOpenStream2::nil -> phrase in
		XmppGateSend xSession phrase;
0;;













// ---------------------------------------------------------
// XMPP BOSH > SEND, READ_CB, IDLE
// ---------------------------------------------------------
/*
 * On lance une requete http vers le serveur jabber
 */
fun XmppBoshSend xSession xData =
	if xSession.sGate.pBoshV.yServerIp != nil then
	(
		set xSession.sLastIOTime = time;					// Mise ‡ jour
		let xSession.sGate.pBoshV.yServerIp -> ip in	// rÈcupËre l'ip
		let xSession.sGate.pBoshV.yMsgId -> id in		// rÈcupËre l'id du message
		let httprequest "POST" (boshurl ip) (strcatlist XmppBoshEncapsulation1::(itoa id)::XmppBoshEncapsulation2::xSession.sGate.pSId::XmppBoshEncapsulation3::xData::XmppBoshEncapsulation4::nil) fixarg3 #XmppBoshRead xSession HTTP_NORMAL -> lasthttp in
			set xSession.sGate.pBoshV.yHttpList = [lasthttp time xData id]::xSession.sGate.pBoshV.yHttpList; // On ajoute la requete ‡ la liste de requete
		set xSession.sGate.pBoshV.yMsgId = xSession.sGate.pBoshV.yMsgId + 1			// On incremente l'id du message
	);
0;;

/*
 * Lecture a partir du serveur
 * XmppGateRead
 * XmppSessionIsDisconnected
 * XmppGateStreamOpened
 */
fun XmppBoshRead httpreq res xSession =
	match xSession.sGate.pStatus with
	(pOpening -> set xSession.sGate.pStatus = pOpen; 0)
	|(_ -> 0);
	let hd xSession.sGate.pBoshV.yHttpList -> hdhttp in
	let tl xSession.sGate.pBoshV.yHttpList -> tlhttp in
	let 0 -> Process in
	let "" -> DataSent in
	let nil -> UpdatedList in
	(
		while hdhttp != nil do (							// Mise ‡ jour de la liste de requete
			let hdhttp -> [Req Time xData Id] in
			(
				if Req != httpreq then (
					set UpdatedList = hdhttp::UpdatedList;	// Ce n'est pas la bonne requete, elle n'est pas encore revenue
				0)else(
					set DataSent = xData;
					set Process = 1;
				1)
			);
			set hdhttp = hd tlhttp;
			set tlhttp = tl tlhttp
		);
		
		set xSession.sGate.pBoshV.yHttpList = UpdatedList;
		
		set xSession.sLastReadTime = time;
		if Process == 1 then (	// Si on a bien reÁu les donnÈes

			if (strlen httpgetcontent res) <= 0 then (
				// Ici on a un resultat vide... pas normal!
				if DataSent != nil then (
					if (!strcmp DataSent " ") then (
						XmppSessionIsDisconnected xSession;
						Xw "Mistake in maintening connexion"
					)
					else if (strlen DataSent) <= 0 then
						Xw "Nothing sent... nothing in return?"
					else (
						Xw strcatlist "This request ("::DataSent::") return a empty string, send again..."::nil;
					
						set SendTry = SendTry + 1;
						if SendTry > 15 then
							XmppSessionIsDisconnected xSession	// On a un probleme, on a tentÈ trop souvent
						else
							XmppGateSend xSession DataSent;
						Xw "_sent"
					)
				) else
					Xw "Nothing sent before...";
				
			0)else (
				
				set SendTry = 0;	// On a pas de probleme, on met ‡ jour le sendTry
				
				set xSession.sLastIOTime = time;	// Mise ‡ jour
				
				let strstr httpgetcontent res "</stream:stream>" 0 -> stream_end in		// Si on a une fermeture du stream
					if stream_end != nil then
						XmppGateStreamClosed xSession pBosh;
	
				let ParseXMLPacket httpgetcontent res -> xmlStanza in // On a le paquet dans le <body
					if (xmlStanza.inXml == nil) then (
						nil;
					0) else (
						match xmlStanza.inXml with	// On recupere le contenu de la balise body
						(ContentElement Balise ->
							
							if !strcmp Balise.nameS "body" then // Si on est bien dans une balise body
							(
								let hd Balise.attribute -> tete in				// premier attribut
								let tl Balise.attribute -> queu in				// reste des attributs
								(	while tete != nil do
									(	if !strcmp tete.tagS "sid" then			// on sauvegarde l'attribut de session
											set xSession.sGate.pSId = tete.valueS;
										if !strcmp tete.tagS "xmlns:stream" then // On est dans l'ouverture de stream
											XmppGateStreamOpened xSession;
										if !strcmp tete.tagS "requests" then // le nombre de requete max
											set xSession.sGate.pBoshV.yMaxRequest = atoi(tete.valueS);
										if !strcmp tete.tagS "type" then ( // le nombre de requete max
											if !strcmp tete.valueS "terminate" then
											(
												Xw "Stream TERMINATE! Restart! : ";
												Xw httpgetcontent res;
												XmppSessionIsDisconnected xSession // la session a ete terminee, on redemarre
											)
										);
										set tete = hd queu;
										set queu = tl queu )
								);
								
								let 0 -> i in
								let hd Balise.content -> tete in			// On parcourt tous les ÈlÈments
								let tl Balise.content -> queu in
								(
									while tete != nil do (
										match tete with
										(ContentElement Balise -> // Si il s'agit bien d'une balise, on la traite comme une requete normale
											set i = i + 1;
											XmppGateRead xSession tete;
										0)|
										(ContentText Texte -> 0) | ( _ -> 0 );
										set tete = hd queu;
										set queu = tl queu;
									0);
								0)
							) else (
								Xw "Not in a balise body";
								XmppSessionIsDisconnected xSession	// Se n'est pas une balise body, on redemarre
							)
						
						)|(ContentText Texte -> 0) | ( _ -> 0 );
					0)
			)
		) else (
			Xw httpgetcontent res;
			if(httpgetcontent res) == nil then (
				set xSession.sNextRestart = time + 22;
				// TODO FIGER EN VERT
				Xw "Send Presence to see if we are connected... (reconnect in 22 sec)";
				set xSession.sState = ssFree;
				xmpps_createStanza xSession
					xSession.sJID /* FROM */
					nil /* TO */
					stanzaPresence /* Type = iq & get */
					nil
				//XmppSessionIsDisconnected xSession;
			);
			0
		)	// On a un problËme, on a tentÈ trop souvent) // On a des donnÈes d'une socket qui ne nous appartient pas (ou le socket a ÈtÈ supprimÈ)
	);
	if (xSession.sGate.pBoshV.yHttpList == nil) then (
		set xSession.sNextRestart = -1
	);
0;;

// FUNCTION TO OPEN THE STREAM TO THE SERVER
fun XmppBoshOpenStream xSession =
	if xSession.sGate.pBoshV.yServerIp != nil then
	(
		//Xw "Open Xmpp Stream (BOSH)";
		set xSession.sGate.pActualMode = 2; //BOSH
		set xSession.sGate.pStatus = pOpening;
		set xSession.sLastIOTime = time;		// Mise ‡ jour
		let xSession.sGate.pBoshV.yServerIp -> ip in
		let xSession.sGate.pBoshV.yMsgId -> id in
		let httprequest "POST" (boshurl ip) (strcatlist XmppBoshOpenStream1::(itoa id)::XmppBoshOpenStream2::(xSession.sDomain)::XmppBoshOpenStream3::(boshurl ip)::XmppBoshOpenStream4::nil) fixarg3 #XmppBoshRead xSession HTTP_NORMAL -> lasthttp in
			set xSession.sGate.pBoshV.yHttpList = [lasthttp time nil id]::xSession.sGate.pBoshV.yHttpList; // On ajoute la requete ‡ la liste de requete
		set xSession.sGate.pBoshV.yMsgId = xSession.sGate.pBoshV.yMsgId + 1
	);
0;;

// FUNCTION TO REOPEN THE STREAM TO THE SERVER
fun XmppBoshReOpenStream xSession =
	if xSession.sGate.pBoshV.yServerIp != nil then
	(
		//Xw "ReOpen Xmpp Stream (BOSH)";
		set xSession.sGate.pActualMode = 2; //BOSH
		set xSession.sLastIOTime = time;		// Mise ‡ jour
		set xSession.sGate.pStatus = pOpening;
		let xSession.sGate.pBoshV.yServerIp -> ip in
		let xSession.sGate.pBoshV.yMsgId -> id in
		let httprequest "POST" (boshurl ip) (strcatlist XmppBoshReOpenStream1::(itoa id)::XmppBoshReOpenStream2::(xSession.sGate.pSId)::XmppBoshReOpenStream3::xSession.sDomain::XmppBoshReOpenStream4::nil) fixarg3 #XmppBoshRead xSession HTTP_NORMAL -> lasthttp in
			set xSession.sGate.pBoshV.yHttpList = [lasthttp time nil id]::xSession.sGate.pBoshV.yHttpList; // On ajoute la requete ‡ la liste de requete
		set xSession.sGate.pBoshV.yMsgId = xSession.sGate.pBoshV.yMsgId + 1
	);
0;;


fun XmppBoshSetUp ip xSession = 
	if ip != nil then (
		set xSession.sLastIOTime = time - TcpServerNoResponseTimeOut;
		set xSession.sGate.pBoshV.yServerIp = ip;
	0)else (
		XmppSessionUnreachable 0);
0;;


fun XmppBoshIdle xSession =

	// Suppression des requetes trop longues
	let hd xSession.sGate.pBoshV.yHttpList -> hdhttp in
	let tl xSession.sGate.pBoshV.yHttpList -> tlhttp in
	let nil -> UpdatedList in
	(
		while hdhttp != nil do (							// Mise ‡ jour de la liste de requete
			let hdhttp -> [Req Time xData Id] in
			(
				if time - Time > XmppBoshHttpTimeOut then // Requete trop longue, on a supprime
					(httpabort Req; 0)
				else
					(set UpdatedList = hdhttp::UpdatedList; 0)
			);
			set hdhttp = hd tlhttp;
			set tlhttp = tl tlhttp
		);
		set xSession.sGate.pBoshV.yHttpList = UpdatedList
	);

	// Si la liste est vide, on envoie une espace.
	if xSession.sGate.pBoshV.yHttpList == nil then
			XmppGateSend xSession " ";	// si il n'y a plus rien dans la liste, on maintient la connexion
0;;































// ---------------------------------------------------------
// XMPP > CONNECT, SEND, IDLE in TCP or BOSH
// ---------------------------------------------------------

fun XmppGateInfo xSession =
	Xw "***************************************";

	// DEBUG AFFICHAGE DE LA QUEUE
	Xw "INQUEUE : ";
	let hd xSession.sInQueue -> hdM in
	let tl xSession.sInQueue -> tlM in
	(
		while hdM != nil do (
			XMLPrintContent hdM 5;
			Xw "-------------------------------";
			set hdM = hd tlM;
			set tlM = tl tlM
		)
	);
	
	// DEBUG AFFICHAGE DE LA QUEUE
	Xw "OUTQUEUE : ";
	let hd xSession.sOutQueue -> hdM in
	let tl xSession.sOutQueue -> tlM in
	(
		while hdM != nil do (
			let hdM -> [NextState To Type Content] in
			(
				Xw match NextState with (ssLogging -> "Logging") | (ssBind -> "Bind") | (ssStartSession -> "UnBind") | (_ -> "Autre");
				Xw strcatlist To::"-"::nil;
				Xw Content;
				Xw "-------------------------------"
			);
			set hdM = hd tlM;
			set tlM = tl tlM
		)
	);
	Xw strcatlist "JID Actuel : "::xSession.sJID::nil;
	Xw strcatlist "Previous Resource : "::xSession.sPreviousResource::nil;
	Xw strcatlist "Ressource : "::xSession.sResource::nil;
	Xw strcatlist "Next Resource : "::xSession.sNextResource::nil;
	Xw strcatlist "Stream State : ":: (xmppStateToStr xSession.sState ) :: nil;
	Xw strcatlist "gBusy : "::(itoa gBusyState)::nil;
	dumpStatus;
	Xw "***************************************";
	Xw " ";Xw " "
;;


//## fonction appellÈe quand on a ÈtÈ dÈconnectÈ du serveur xmpp et qu'on veut se reconnecter.
fun XmppGateReconnect xSession displayLeds =
	Xw "XmppGateReconnect";
	// On reinitialise la session.
	set xSession.sStatus = sOpening;
	set xSession.sNonce = nil;
	set xSession.sDisplayLeds = displayLeds;
	set xSession.sState = ssLogging;
	set xSession.sLastIOTime = time;
	set xSession.sNextRestart = -1;
	set xSession.sAlgo = nil;
	if xSession.sGate.pActualMode == nil then 	
	(
		if xSession.sGate.pTcpV != nil then (
			set xSession.sGate.pBoshV = nil;
			set xSession.sGate.pMode = pTcp;
			set xSession.sGate.pTry = 3; 
			set xSession.sGate.pActualMode = 1 // Mode TCP  
		)else (
			set xSession.sGate.pTcpV = nil;
			set xSession.sGate.pMode = pBosh;
			set xSession.sGate.pTry = 1; 
			set xSession.sGate.pActualMode = 2 // Mode BOSH 
		)
	); 
	//Xw strcatlist "TRY TOO LONG... TRY("::(itoa xSession.sGate.pTry)::") ON NEXT SERVER"::nil;
	set xSession.sGate.pTry = xSession.sGate.pTry - 1;		// on met ‡ jour le nombre d'essais
	set xSession.sLastIOTime = time;					// on met ‡ jour la derniere action
	if xSession.sGate.pTry >= 0 then					// on continue de tester sur en tcp sur le 5222
	(
		if xSession.sGate.pActualMode == 1 then (	
			set xSession.sGate.pStatus = pOpening;
			DnsSrvCb nil fixarg3 #XmppTcpReOpen xSession	// on appel le callback DNS qui contient les autres serveurs ‡ tester
		)
		else (
			set xSession.sGate.pStatus = pOpening;
			dnsreq xSession.sDomain fixarg2 #XmppBoshSetUp xSession              // On cherche l'ip du port 80
		);
		0
	)else(	// on passe en BOSH ou en TCP suivant le mode duquel en vient!
		if xSession.sGate.pActualMode == 1 then (	
			//Xw "Now we try in BOSH";
			set xSession.sGate.pActualMode = 2;
			set xSession.sGate.pTry = 1;
			set xSession.sGate.pTcpV = nil;		// On supprime le tcp
			set xSession.sGate.pMode = pBosh;	// On passe en Bosh
			set xSession.sGate.pStatus = pOpen;
			let [yParent:xSession yHttpList:nil yMsgId:((time_ms*time)%1000) yServerIp:nil] -> newBosh in
	 			set xSession.sGate.pBoshV = newBosh;	// On dÈclare la nouvelle structure bosh
		dnsreq xSession.sDomain fixarg2 #XmppBoshSetUp xSession;		// On cherche l'ip du port 80
			set xSession.sLastIOTime = time;          // Mise ‡ jour
			0
		)else(
			//Xw "Now we try in TCP";
			set xSession.sGate.pActualMode = 1;	
			set xSession.sGate.pTry = 3; // on remet le nombre d'essais ‡ faire en TCP ‡ 3	
			set xSession.sGate.pMode = pTcp;
			set xSession.sGate.pBoshV = nil;
			set xSession.sGate.pStatus = pOpening;
			DnsSrvCb nil fixarg3 #XmppTcpReOpen xSession;	// on appel le callback DNS qui contient les autres serveurs ‡ tester
			0	
		);
		0
	);
	0	
;;

// Is executed while we don't reach the stream
fun XmppGateConnect xSession =
	Xw "XmppGateConnect";
	if xSession.sGate == nil then // New Session, Create the Gate
	(
		Xw strcatlist "gate nil. DNS SRV REQUEST ON : "::xSession.sDomain::nil;
		let [pParent:xSession pMode:pTcp pStatus:pOpening pTry:3 pTcpV:nil pBoshV:nil pActualMode:nil] -> newGate in		// On crÈe la structure XmppGate
		(
			set xSession.sGate = newGate;										// on la sauvegarde
			DnsSrv strcatlist "_xmpp-client._tcp."::xSession.sDomain::nil fixarg3 #XmppTcpOpen xSession		// et on lance la premiËre requÍte
		);
		set xSession.sLastIOTime = time;											// on met ‡ jour la derniere action
		0
	)else
	(
		match xSession.sGate.pStatus with
		(pOpening -> // On essai d'atteindre le serveur
			Xw "pOpening";
			if (time - xSession.sLastIOTime) > TcpServerNoResponseTimeOut then	// Si on dÈpasse le temps d'attente
			(
				Xw "timeout";
				// On se reconnecte
				set xSession.sGate.pStatus = pClose;
				set xSession.sStatus = sClosed;
				XmppGateReconnect xSession xSession.sDisplayLeds
			);
		0)|(pOpen -> // On envoie le stream
			if (time - xSession.sLastIOTime) > TcpServerNoResponseTimeOut then	// Si on a bien envoyÈ le stream, on ne fait rien
			(
				set xSession.sLastIOTime = time;		// Mise ‡ jour
				XmppGateOpenStream xSession		// Ouverture de stream
			);
		0)|(pInStream -> // On est dans le stream
			// ON ATTEND POUR FAIRE LE LOGIN
			Secho "___";
		0)|(pClose -> // On est dans la boucle d'attente
                        // ON ATTEND POUR FAIRE LE LOGIN
                        Secho "___";
		0)|(_ -> Xw "ERREUR!!"; 0)
	)
	;;

// Call the function to open the xmpp stream
fun XmppGateOpenStream xSession =
	match xSession.sGate.pMode with
	(pTcp -> XmppTcpOpenStream xSession ) | (pBosh -> XmppBoshOpenStream xSession );
0;;

fun XmppGateReOpenStream xSession =
	if xSession.sGate.pActualMode == 2 then (
		 XmppBoshReOpenStream xSession
	)
	else (
		XmppTcpOpenStream xSession
	);	
0;;

// Is called when a the stream is opened
fun XmppGateStreamOpened xSession =
	set xSession.sGate.pStatus = pInStream;
	let [clINT:"int" clASR:"asr" clPPT:"ppt" clRFID:"rfid" clITMODE:"itmode" clSOURCES:"sources"] -> newsCl in
	(
		set xSession.sState = ssLogging;
		set xSession.sOutQueue = nil;
		set xSession.sInQueue = nil;
		set xSession.sStanzaID = 0;
		set xSession.sClients = newsCl
	);
0;;

fun XmppGateStreamClosed xSession Mode =
	// la connection a dÈconnÈ. On pourrait essayer de gentiment relancer la connection, mais le plus efficace est de simplement rebooter le bunny.
	Xw "gate stream closed, rebooting";
	reboot 0x0407FE58 0x13fb6754
;;

// SEND SOMETHING IN TCP OR BOSH
fun XmppGateSend xSession xData =
	Xw strcatlist "Sending : "::xData::"(end)"::nil;
	//if (match xSession.sGate.pMode with
	//(pTcp -> XmppTcpSend xSession xData ) | (pBosh -> XmppBoshSend xSession xData )) == nil then // Si on a un retour nil, il y a un probleme
	//		XmppGateStreamClosed xSession xSession.sGate.pMode;	// Stream Closed, problem!
	match xSession.sGate.pMode with
	(pTcp ->
		if ( (XmppTcpSend xSession xData) == nil ) then 
			XmppGateStreamClosed xSession xSession.sGate.pMode;     // Stream Closed, problem!
		nil
	) | (pBosh ->
		if ( (XmppBoshSend xSession xData) == nil ) then (
			Xw "We are deconnected (stream closed in Bosh)";
			XmppSessionIsDisconnected xSession
		);
		nil);
0;;


/**
	Called by XmppSessionIdle (which is called at the end of each "loop" turn) if the xmpp session is "up & running"
*/
fun XmppGateIdle xSession=
	if (nil != doPing) then
	(
		// "ping" stuff
		// send a ping packet, to know reliably if we're still connected with the server
		// if there is an ping packet sent, check if the reply did not timeout
		if (nil != xSession.sLastPingIqId) then // there is a ping packet sent, check timeout
		(
			if (time - xSession.sLastPingTime > XmppPingMaxReponseDelay) then
					XmppSessionIsDisconnected xSession
		)
		else if (time - xSession.sLastPingTime > XmppPingDelay) then
		(
			 Pingw "PING time to send a ping";
			 XmppGateSend xSession (xmpps_createStanza xSession (xmpps_OurJID xSession) (xmpps_ServerJID xSession) stanzaIQGet "<ping xmlns='urn:xmpp:ping'/>");
			 set xSession.sLastPingIqId = xSession.sStanzaID
  	)
	)
	;

	// other stuff, protocol specific
	match xSession.sGate.pMode with
	(pTcp -> XmppTcpIdle xSession ) | (pBosh -> XmppBoshIdle xSession );
0;;



/** XEP-0199, ping.  This packet can be a packet related to ping,
 either a ping packet, or an answear to one of our ping packet.

 - xSession: xmpp session
 - xData: incoming stanza

 Returns 1 if xData was a ping-related packet and has been handled,
 0 otherwise.
*/
fun XmppGateHandlePingPackets xSession xData =
	(match (xData) with
	  (ContentElement xmlStanza ->
		  if ((!strcmp xmlStanza.nameS "iq")
				  && (let (Xml_FindFirstElementNamed xmlStanza "ping") -> ping in
               (nil != ping && (!strcmp Xml_GetElementAttribute ping "xmlns" "urn:xmpp:ping"))
             )
         ) then
			(
				// It _is_ a ping packet. Is it an answear or a request ?
				Pingw "PING received a ping packet";
				if (!strcmp (Xml_GetElementAttribute xmlStanza "type") "result") then
				( // answear
				  Pingw "PING  an answear";
				  if (!strcmp (Xml_GetElementAttribute xmlStanza "id") (itoa xSession.sLastPingIqId)) then
						( Pingw "PING and YEAH"; set xSession.sLastPingTime = time; set xSession.sLastPingIqId = nil )
					else
					  // not sure it should be this type of error sent, but I can't find anywhere in the xmpp spec
					  ( Pingw "PING and booooo...";  
						  XmppSessionResponseSendErrorFeatureNotImplemented xSession
                                                                (Xml_GetElementAttribute xmlStanza "from")
																																(Xml_GetElementAttribute xmlStanza "id")
						)
				)
   			else if (!strcmp (Xml_GetElementAttribute xmlStanza "type") "get") then
				( // request
					if (!strcmp (Xml_GetElementAttribute xmlStanza "to") (xmpps_OurJID xSession)) then
					(
						 XmppGateSend xSession (xmpps_createStanza xSession  // xSession
                                                       (Xml_GetElementAttribute xmlStanza "to")   // From
							 																				 (Xml_GetElementAttribute xmlStanza "from") // To
																											 (stanzaIQResult (Xml_GetElementAttribute xmlStanza "id"))   // Type
																											 "<ping xmlns='urn:xmpp:ping'/>") // content
					)
					else
					(
						XmppSessionResponseSendErrorFeatureNotImplemented xSession
																															(Xml_GetElementAttribute xmlStanza "from")
																															(Xml_GetElementAttribute xmlStanza "id")
					)
				)
				else
				( // probably invalid
						XmppSessionResponseSendErrorFeatureNotImplemented xSession
																															(Xml_GetElementAttribute xmlStanza "from")
																															(Xml_GetElementAttribute xmlStanza "id")
				)
			)
			else
			(
				0 // not a ping packet
			)
		) // end "ContentElement"
		| (_ -> 0 )  // not a ping packet nor a response to a ping packet
	)
;;


/**
	First "xmpp" function reading incoming stanzas
*/
fun XmppGateRead xSession xData =
	Xw "Receive : ";
	if xData != nil then (
		XMLPrintContent xData 0;

		if (! XmppGateHandlePingPackets xSession xData) then
			 XmppSessionRead xSession xData;
		0
	)else ( Xw "NOTHING!"; 0 );
0;;




// NETTOIE CE QU'il FAUT AVANT LA SUPRESSION DU XSESSION
// TODO : SEPARER EN DEUX FONCTION (idle bosh & tcp);
fun XmppGateClear xSession =

	match xSession.sGate.pMode with
	(pBosh ->

		let hd xSession.sGate.pBoshV.yHttpList -> hdhttp in
		let tl xSession.sGate.pBoshV.yHttpList -> tlhttp in
		(
			while hdhttp != nil do (
				let hdhttp -> [Req Time xData Id] in
				(
					httpabort Req
				);
				set hdhttp = hd tlhttp;
				set tlhttp = tl tlhttp
			)
		);
		set xSession.sGate.pBoshV.yHttpList = nil;
		nil
	) | (_-> nil)
;;


















// ----- SASL
// parse realm="somerealm",nonce="OA6MG9tEQGm2hh",qop="auth",charset=utf-8,algorithm=md5-sess
// en "realm"::"somerealm"::"nonce"::"OA6MG9tEQGm2hh"...
fun _Sasl_challengeStr2List str l=
	if ((strlen str) == 0) then l
	else
		let 0 -> startPos in
		let strget str startPos -> char1 in
		let nil -> closingPos in (
			if char1 == 34 /* DOUBLE_QUOTE */ then (
				// quote : skip first and find last quote
				set startPos = 1;
				set closingPos = strstr str "\"" 1
			) else (
				// find = or ,
				let strstr str "=" 0 -> equalPos in
				let strstr str "," 0 -> commaPos in (
					set closingPos = equalPos;
					if (closingPos == nil) then set closingPos = commaPos else if (commaPos != nil && commaPos < closingPos) then set closingPos = commaPos
				)
			);
			if closingPos == nil then
				// not found : return all
				str::l
			else (
				let (strsub str startPos (closingPos - startPos)) -> souschaine in
				let (strsub str (closingPos + (if char1 == 34 then 2 else 1)) nil) -> remaining in
				// recurse
				_Sasl_challengeStr2List remaining souschaine::l
			)
	);;

fun Sasl_challengeStr2List str=
	ReverseElements _Sasl_challengeStr2List str nil;;

fun SechoListWithSlash stringlist=
	Secho "/";
	for l=stringlist;l!=nil;tl l do ( Secho (hd l); Secho "/");;
		
// Creation d'une chaine alÈatoire
const gSasl_RandomStringChars = "0123456789528460";; // 16 chars
fun Sasl_randomString nbChars=
	let strnew (nbChars+1) -> res in (
		for i=0; i<nbChars do ( strset res i (strget gSasl_RandomStringChars rand&15) );
		strset res nbChars 0;
		res
	);;

fun Sasl_response_value xSession authstring=
	// compute the response_value
	let strcatlist "xmpp/"::xSession.sDomain::nil -> digest_uri in
	let (md5bytes strcatlist xSession.sUsername::":"::(if (xSession.sRealm != nil) then xSession.sRealm else "")::":"::xSession.sPassword::nil) -> A11 in
	let strcatlist ":"::xSession.sNonce::":"::xSession.sCnonce::nil -> A12 in
	let strcatlist A11::A12::nil -> A1 in
	(
		//Secho "HEX(A11)="; Secho md5tohex A11;
		//Secho "HEX(A1)="; Secho md5tohex A1 ;						
		let strcatlist authstring::":"::digest_uri::nil -> A2 in
		let strcatlist (md5tohex (md5bytes A1))::":"
						::xSession.sNonce::":"
						::"00000001"::":"
						::xSession.sCnonce::":"
						::xSession.sQop::":"
						::(md5tohex (md5bytes A2))
						::nil -> theValue in
			 md5tohex md5bytes theValue
	);;

// Protocole challenge_response DIGEST_MD5
// challengeText est la chaine codÈe
fun Sasl_processChallenge xSession challengeText=
	let nil -> xmlpacket in (
	if challengeText != nil then
	let B64toS challengeText -> decoded in if decoded != nil then // realm="somerealm",nonce="OA6MG9tEQGm2hh",qop="auth",charset=utf-8,algorithm=md5-sess
	let Sasl_challengeStr2List decoded -> decodedList in if decodedList != nil then (
		// Step One of http://www.ietf.org/rfc/rfc2831.txt
		
		let 0 -> phase in
		let 0 -> error in (
			let decodedList -> ll in
			while (ll != nil && !error) do (
				let hd ll -> tok in
				let hd tl ll -> val in (
					if (!strcmp tok "nonce") then (
						// only once
						if xSession.sNonce != nil then (
							Xw "nonce already set ! : error";
							set error = 1
						) else (set xSession.sNonce = val;set phase = 1;0)
					)
					else if (!strcmp tok "realm") then (set xSession.sRealm = val;0)
					else if (!strcmp tok "charset") then (set xSession.sCharset = val;0)
					else if (!strcmp tok "qop") then (set xSession.sQop = val;0)
					else if (!strcmp tok "algorithm") then (
						// only once
						if xSession.sAlgo != nil then (
							Xw "algorithm already set ! : error";
							set error = 1
						) else (set xSession.sAlgo = val;0)
					) else if (!strcmp tok "rspauth") then (
						set phase = 2;
						Xw "rcv rspauth:";
						let Sasl_response_value xSession "" -> myval in
						if (!strcmp myval val) then (
							Secholn "rspauth ok, snd response";
							set xmlpacket = "<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>";
							0
						) else (
							Secholn "BAD rspauth='"; Secho val; Secho "', myval='"; Secho myval; Secho "'";0
						);
						0
					)
				);
				
				// next doublon
				set ll = tl tl ll
			); // while

			if (!error) then
			if (phase == 1) then (
				if (!strcmp xSession.sAlgo "md5-sess") then // check algorithm = md5-sess
				if (!strcmp xSession.sQop "auth") then // check qop = auth
				if (!strcmp xSession.sCharset "utf-8") then // check charset = utf-8 
				(
					Xw "rcv challenge:";
					
					// compute a new sCnonce
					set xSession.sCnonce = Sasl_randomString 13;
					//Secholn "cnonce='"; Secho gXmpps_cur.sCnonce; Secho "'";
					
					// compute the response_value
					let Sasl_response_value xSession "AUTHENTICATE" -> response_value in
					let strcatlist "xmpp/"::xSession.sDomain::nil -> digest_uri in
					let strcatlist
						"username=\""::xSession.sUsername::"\","::
						(if (xSession.sRealm != nil) then (strcatlist "realm=\""::xSession.sRealm::"\","::nil) else "")::
						"nonce=\""::xSession.sNonce::"\","::
						"cnonce=\""::xSession.sCnonce::"\","::
						"nc=00000001"::",":: // ?? only one answer
						"qop="::xSession.sQop::","::
						"digest-uri=\""::digest_uri::"\","::
						"response="::response_value::",":: // 
						"charset="::xSession.sCharset::
						nil			
						-> response in
					(
						Xw "snd response"; // ='"; Secho response; Secho "'";
						set response = StoB64 response;
						// send response
						set xmlpacket = strcatlist "<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>"::response::"</response>"::nil;
						0
					)
				) // if
			)
		) // let error
		);
	xmlpacket) // let xmlpacket
;;























// ----- JID utils
// JID = [ node "@" ] domain [ "/" resource ]
fun xmpps_JIDNode jid=
	let strstr jid "@" 0 -> arobPos in
	if (arobPos != nil) then strsub jid 0 arobPos;;
	
fun xmpps_JIDResource jid=
	let strstr jid "/" 0 -> slashPos in
	if (slashPos != nil) then strsub jid slashPos+1 nil;;

fun xmpps_JIDPlatform jid=
	let strstr jid "@" 0 -> arobPos in
	let strstr jid "/" arobPos -> slashPos in
	(
		Iecholn arobPos; Iecholn slashPos;
		Secholn strsub jid (arobPos+1) (slashPos - arobPos -1);
		if ((nil!=arobPos) && (nil!=slashPos)) then
			strsub jid (arobPos+1) (slashPos - arobPos -1)
		else
			nil
	)
;;

/**
 * Retourne le JID de la plateforme, pour une resource donnÈe.
 */	
fun xmpps_PlatformJID xSession resource =
	strcatlist resource ::"@"::XmppVioletObjectsComponent::"/"::resource::nil;;

/**
 * Retourne le JID du serveur
 */	
fun xmpps_ServerJID xSession =
	xSession.sDomain;;

/**
 * Retourne notre JID courant.
 */	
fun xmpps_OurJID xSession =
	xSession.sJID;;

/**
 * Retourne un JID pour le bind.
 */	
fun xmpps_BindJID xSession resource =
	strcatlist xSession.sUsername::"@"::xSession.sDomain::"/"::resource::nil;;

// -----------------------------------



















// -----------------------------------
// requetes Stanza (IQ / MESSAGE / PRESENCE)

/* 
 * RÈcupËre l'id en cours
 * IncrÈmente l'ID courant
 */
fun xmpps_getNextStanzaId xSession =
	set xSession.sStanzaID = xSession.sStanzaID + 1;	// update stanza id
	itoa xSession.sStanzaID
;;

/* 
 * CrÈation de la chaine ‡ envoyer pour un IQ / Message / Presence
 *
 * xSession	session courante
 * From		from (jid complet) ou nil (pas d'attribut from)
 * To		jid complet ou nil (pas d'attribut to)
 * Type		type du stanza: stanzaIQGet, stanzaIQSet, stanzaMessage, stanzaPresence
 * Content	contenu de la stanza ou nil (pas de sous-ÈlÈment)
 */
fun xmpps_createStanza xSession From To Type Content =
	let (match Type with							// Si on a un iq (set, get), presence ou message
		(stanzaIQGet -> ["iq" " type='get'"])
		|(stanzaIQSet -> ["iq" " type='set'"])
		|(stanzaIQResult _Request_id -> ["iq" " type='result'"])	//<iq to="" from="" id="" type="result" />
		|(stanzaMessage -> ["message" ""])
		|(stanzaPresence -> ["presence" ""])
		|(stanzaIQError _Request_id -> ["iq" " type='error'"])
		)-> [ElementType Attributes] in
	let (match Type with
		(stanzaIQResult Request_id -> Request_id)
		|(stanzaIQError Request_id -> Request_id)
		|(_ -> (xmpps_getNextStanzaId xSession))) -> Id in
	(
		strcatlist "<"::ElementType::""::
			(if(From != nil) then strcatlist " from='"::From::"'"::nil else "")::
			(if(To != nil) then strcatlist " to='"::To::"'"::nil else "")::
			Attributes::" id='"::Id::"'>"::Content::"</"::ElementType::">"::nil
	)
;;

/**
 * CrÈe un paquet IQ pour faire un bind vers une nouvelle ressource.
 * Retourne la chaine.
 */
fun XmppCreateBindIQ xSession newRes =
	strcatlist "<iq "::
		//"from=\""::(xmpps_BindJID xSession newRes)::"\" "::
		"from=\""::(xmpps_BindJID xSession xSession.sPreviousResource)::"\" "::
		"to=\""::(xmpps_ServerJID xSession)::"\" "::
		"type='set' id='"::(xmpps_getNextStanzaId xSession)::"'><bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'><resource>"::newRes::"</resource></bind></iq>"::nil
;;

fun XmppCreateXmlPacket xSession from to type content resource =
	let "" -> xmlPacket in (
	if (resource != nil) then (
		let "" -> strFrom in
		if (resource != "") then (
			if (xSession.sPreviousResource!=nil) then set strFrom = (xmpps_BindJID xSession xSession.sPreviousResource)
			else
				if (xSession.sResource!=nil) then set strFrom = (xmpps_BindJID xSession xSession.sResource)
				else set strFrom = (xmpps_BindJID xSession resource);
			set xmlPacket = strcatlist "<iq "::
					"from=\""::strFrom::"\" "::
					"to=\""::(xmpps_ServerJID xSession)::"\" "::
					"type='set' id='"::(xmpps_getNextStanzaId xSession)::"'><bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'><resource>"::resource::"</resource></bind></iq>"::nil 
		)
		else set xmlPacket = nil
	)
	else (
		if (from == nil ) && (to == nil) && (type == nil) && (content == nil) then set xmlPacket = " "	
		else 
		let (match type with                                            // Si on a un iq (set, get), presence ou message
		(stanzaIQGet -> ["iq" " type='get'"])
		|(stanzaIQSet -> ["iq" " type='set'"])
		|(stanzaIQResult _Request_id -> ["iq" " type='result'"])        //<iq to="" from="" id="" type="result" />
		|(stanzaMessage -> ["message" ""])
		|(stanzaPresence -> ["presence" ""])
		)-> [ElementType Attributes] in
			let (match type with
				(stanzaIQResult Request_id -> Request_id)
				|(_ -> (xmpps_getNextStanzaId xSession))) -> id in
			(
				set xmlPacket = strcatlist "<"::ElementType::""::
					(if(from != nil) then strcatlist " from='"::from::"'"::nil else "")::
					(if(to != nil) then strcatlist " to='"::to::"'"::nil else "")::
					Attributes::" id='"::id::"'>"::content::"</"::ElementType::">"::nil
			)
	);
	xmlPacket
	)
;;


/*
 * Send Iq
 * Permet d'envoyer ou de mettre en liste d'attente un iq
 */
fun xmpps_sendStanza xSession NextState To Type Content =
	// On recupere le dernier xSession de la liste si celui donnÈ en parametre est nul
	if xSession != nil then (
		if (	// condition pour l'ajout en queue de l'iq
			match xSession.sState with
			(ssFree ->
				if xSession.sOutQueue == nil then ( // si la queue est vide, on envoie
					//let xmpps_createStanza xSession (xmpps_OurJID xSession) To Type Content -> XML in	// on construit la requete
					//(
					let xmpps_OurJID xSession -> From in
					(
						if NextState != nil then
							set xSession.sState = NextState;	// On verrouille
						XmppSessionSend xSession [xSession From To Type Content nil] //XML
					);
				0 )else 1	// 1 pour ajout en queue
			)|(_ -> 1 )
			
		) == 1 then ( // Si on doit faire un ajout en queue -- cas ou il y a le verrou, ou que la queue n'est pas vide
			let [NextState To Type Content] -> tlQueue in
				set xSession.sOutQueue = conc xSession.sOutQueue tlQueue::nil
		)
	)else
		if XmppGlobalSession != nil then
			xmpps_sendStanza XmppGlobalSession NextState To Type Content
;;































// ---------------------------------------------------------
// XMPP SESSION
// ---------------------------------------------------------


// This open a new Xmpp Session
fun XmppSessionStart domain displayChor=
	Xw strcatlist "Xmpp Session Start on : "::domain::nil;
	if displayChor == 1 then setleds RGB_GREEN;		// DISPLAY STATUS WITH LIGHT TODO
	if XmppGlobalSession != nil then XmppSessionStop XmppGlobalSession;
	let [sStatus:sOpening sUsername:(webmac netMac) sPassword:GetXmppPassword sDomain:domain/*"xmpp-dev.nabaztag.com"*/ sDisplayLeds:displayChor sState:ssLogging sLastIOTime:time sNextRestart:-1 sPacketQueue:nil sDataToSend:[nil 0 0] sLastPingTime:time sLastPingIqId:nil ] -> NewSession in
	(
		set XmppGlobalSession = NewSession
	);;

// Delete the Xmpp Session from the chain.
fun XmppSessionStop XmppSession=
	set XmppGlobalSession = nil;
	0;;


// Send Something
fun XmppSessionSend xSession data=
	if (xSession.sPacketQueue == nil) then	
		set xSession.sPacketQueue = [xSession.sState data]::nil 
	else
		let [xSession.sState data] -> newPacket in
			set xSession.sPacketQueue = newPacket::xSession.sPacketQueue;
0;;

// Envoie un message immÈdiatement
fun XmppSessionResponseSend xSession data=
	if (data!=nil) then 
		XmppGateSend xSession data;
0;;


// envoie un message de type iq error feature not implemented
fun XmppSessionResponseSendErrorFeatureNotImplemented xSession to id =
	XmppSessionResponseSend
		xSession
		(xmpps_createStanza
			xSession
			xSession.sJID /* FROM */
			to /* To */
			(stanzaIQError id)
			( strcatlist
			// TODO en premier lieu il faudrait (SHOULD)  mettre le xml qu'on a recu
				"<error type='cancel'>"
				:: "<feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>"
				:: "</error>" :: nil)
		)
;;



// Send the message for one button
fun XmppSessionSendButtonMsg btn withEvent eventValue=
	Xw strcatlist "XmppSessionSendButtonMsg btn="::(itoa btn)::nil;
	if (withEvent) then (Xw strcatlist " eventValue="::(itoa eventValue)::nil);
	
	/*
	let "" -> message in
	let "" -> packet in
	let "" -> from in
	let "" -> to in
	(
		set from = xmpps_OurJID XmppGlobalSession;
		Xw from;
		set to = xmpps_PlatformJID XmppGlobalSession XmppGlobalSession.sClients.clINT;
		Xw to;
		set message = strcatlist "<button xmlns=\"violet:nabaztag:button\"><clic>"::(itoa btn)::"</clic>"::(if withEvent then (if eventValue != nil then strcatlist "<event>"::(itoa eventValue)::"</event>"::nil else "<event/>") else "")::"</button>"::nil;
		Xw message;
		set packet = XmppCreateXmlPacket XmppGlobalSession from to stanzaMessage message nil;
		Xw packet;
		XmppGateSend XmppGlobalSession packet 
	);
	Xw "End of XmppSessionSendButtonMsg";
	*/
	
	xmpps_sendStanza
		XmppGlobalSession
		nil // Next State 
		xmpps_PlatformJID XmppGlobalSession XmppGlobalSession.sClients.clINT
		stanzaMessage /* Type */
		strcatlist "<button xmlns=\"violet:nabaztag:button\"><clic>"::(itoa btn)::"</clic>"::
		(if withEvent then (if eventValue != nil then strcatlist "<event>"::(itoa eventValue)::"</event>"::nil else "<event/>") else "")::
		"</button>"::nil;

0;;

// Send the message when a ears is moved
fun XmppSessionSendEarMsg leftValue rightValue=	
	Xw strcatlist "XmppSessionSendEarMsg l="::(itoa leftValue)::" r="::(itoa rightValue)::nil;
	
	/* SEND THE EAR POSITION NOW */
	xmpps_sendStanza
		XmppGlobalSession
		nil /* Next State */
		xmpps_PlatformJID XmppGlobalSession XmppGlobalSession.sClients.clINT
		stanzaMessage /* Type */
		strcatlist "<ears xmlns=\"violet:nabaztag:ears\"><left>"::(itoa leftValue)::"</left><right>"::(itoa rightValue)::"</right></ears>"::nil;
0;;

/**
 * Initie l'acquisition d'une nouvelle ressource en envoyant un paquet bind.
 */
fun XmppSessionRequestResource newRes =
	Xw strcatlist "RequestResource!"::newRes::nil;
	/* REQUEST RESOURCE NOW */
	let XmppGlobalSession -> xSession in
		if (xSession.sNextResource == nil) then (
			if (strcmp newRes xSession.sResource) then ( // Si on n'a pas deja cette nouvelle ressource
				match xSession.sState with
				(ssFree -> // on est libre, on peux faire l'acquisition de la nouvelle ressource
					set xSession.sPreviousResource = xSession.sResource;
					set xSession.sNextResource = newRes;
					set xSession.sState = ssBind;
					XmppSessionSend xSession [xSession nil nil nil nil newRes]; 
					0
				)|(_ -> set xSession.sNextResource = newRes; 0)
			) // Sinon il ne se passe rien (parce qu'on a deja la ressource)
		) else (
			match xSession.sState with
			(ssBind -> // On est en train de faire un bind, mettre le prochain bind dans NextRessource serai ÈcrasÈ lors du retour du success
				set xSession.sNextResourceBinding = newRes
			)|(_ -> set xSession.sNextResource = newRes);	// Sinon, on peut mettre la ressource, elle sera traitÈ au prochain ssFree
			0
		);
0;;

// Manage xmpp packet queue
fun XmppSessionRunR xSession xPacketQueue =
	if (xPacketQueue!=nil) then (
		let XmppSessionRunR xSession tl xPacketQueue -> s in 
		let hd xPacketQueue -> [xState xData] in 
		let xData -> [theSession theFrom theTo theType theContent theResource] in
			if (xState==xSession.sState) then strcatlist s::(XmppCreateXmlPacket theSession theFrom theTo theType theContent theResource)::nil
			else nil
	)
;;


fun sendPkts pktList state =
	if nil==pktList then [ nil nil ]
	else
		let hd pktList -> pkt in
		let pkt -> [pktState pktData] in
			if pktState==state then
				let sendPkts tl pktList state -> [ newList data2send ] in 
				let pktData -> [theSession theFrom theTo theType theContent theResource] in
					[ newList strcatlist (XmppCreateXmlPacket theSession theFrom theTo theType theContent theResource)::data2send::nil ]
			else (
				set XmppGlobalSession.sState = pktState; // On change de statu
				[ pktList nil ]
			) 
;;


fun XmppSessionRun=
	if (XmppGlobalSession.sPacketQueue!=nil) then (
		let sendPkts rev XmppGlobalSession.sPacketQueue nil XmppGlobalSession.sState -> [ newList data2send] in
		(
			set XmppGlobalSession.sPacketQueue = newList;
			XmppGateSend XmppGlobalSession data2send
		)	
	)
;;	



var lastIdle = 0;;
var tmpi=0;; //DEBUG

// Manage all Xmpp Session
fun XmppSessionIdle=
	let time_ms - lastIdle -> Checking in
	(
		if (Checking < 0 || Checking > 100) then // ON TEST TOUTES LES 100ms
		(
			set lastIdle = time_ms;
			let XmppGlobalSession -> xSession in 
			let nil -> UpdateXmppSession in
			(
					match xSession.sStatus with 
					(sOpening -> // We are trying to open a connexion (jabber is not reached yet)
					// on ne renvoie rien.
						XmppGateConnect xSession;	// Try to connect (TCP or BOSH)
						if (xSession.sDisplayLeds == 1) then
							leds_set_state (if (xSession.sGate != nil) then (match xSession.sGate.pMode with (pTcp -> LEDS_STATE_XMPP_OPENING_XMPP_TCP) | (pBosh -> LEDS_STATE_XMPP_OPENING_XMPP_BOSH)) else LEDS_STATE_XMPP_OPENING_XMPP);				
					0)|(sLogging ->
						Xw "TRY TO LOGGIN";
						if xSession.sNextRestart < time then
							XmppSessionIsDisconnected xSession
						else ( Iecho time; Secho " "; Iecho xSession.sNextRestart; 0);
					0)|(sLoggedin ->
						Xw "LOGGED IN";
						if xSession.sNextRestart < time then
							XmppSessionIsDisconnected xSession;
					0)|(sOpened -> /*Debug if (time%5 == 0) then (if tmpi == 1 then (XmppGateInfo xSession; set tmpi = 0)) else set tmpi = 1; */
						XmppGateIdle xSession ;
						if xSession.sLastReadTime + XmppSessionReadTimeout < time then (
							// On n'a pas eu de nouvelle du serveur depuis XmppSessionReadTimeout 
							XmppSessionIsDisconnected xSession
						) else (
							if xSession.sNextRestart > 0 then (
								if xSession.sNextRestart > time then
									XmppSessionIsDisconnected xSession
							)
						);
					0)|(sClosed -> // la session est fermee...
					0)|(sRegistrationError -> setleds RGB_RED; nil; // TODO Xw "HERRRRE IN ERROR";
					0)|(_ -> 0);
				0
			)
		)
	);;

fun XmppSessionUnreachable id =
	if id == 0 then
		Xw "Can't reach the server on port 80";
0;;

fun XmppSessionSetStatus xSession xStatus =
	set xSession.sStatus = xStatus;
	XmppSessionUpdate xSession;
0;;


// dÈfinie tout ‡ la fin
proto stopEverythingAndResetToIdle 0;;

// le nombre de secondes maximum qu'on peut attendre avant d'essayer de se reconnecter
// au serveur xmpp si on a ÈtÈ dÈconnectÈ
const XMPP_MAX_NB_SECS_BEFORE_TRYING_TO_RECONNECT = 30;;

fun XmppSessionIsDisconnected xSession=

	// on arrÍte tout ce qu'on est en train de faire, afin de ne pas
  // avoir un problËme avec l'Ètat du lapin : on gËre mal de ne pas
	// Ítre en idle ‡ la reconnection...
	stopEverythingAndResetToIdle;

	match getRunState with
	(xmppReconnectRun _ -> 0)
	|(
		_ ->
			// on attend au moins 5 secondes, plus un temps alÈatoire entre 0 et 30 secondes, avant de se
			// reconnecter, ceci afin d'Èviter, en cas de crash du serveur, que tous les lapins se reconnectent
			// en mÍme temps
			let random XMPP_MAX_NB_SECS_BEFORE_TRYING_TO_RECONNECT -> randomWaitTimeInSecs in
				setRunState (xmppReconnectRun [(time_ms + 5000 + 1000 * randomWaitTimeInSecs) xSession getRunState]);
	0);
	set xSession.sStatus = sClosed;
	set xSession.sGate.pStatus = pClose;
0;;


fun XmppSessionUpdate xSession =
	
	match xSession.sStatus with		// XmppSessionUpdate should be called when we want to change the status of the connexion
	(sOpening ->	set xSession.sNextRestart = time + 12;	// Update for the next restart
	0)|(sLogging ->	set xSession.sNextRestart = time + 12;	// Update for the next restart
	0)|(sLoggedin -> set xSession.sNextRestart = time + 12;	// Update for the next restart
		if gEarInited != 1 then (
			set gEarInited = 1;
			earInit						// we init the ears
		);
		setRunState idleRun;		// On s'est connectÈ.
	0)|(sOpened -> set xSession.sNextRestart = -1;	// Update for the next restart
	0)|(sClosed ->
		/* TODO!! */
		//restart session after 10 seconds
		//let XmppSession.sCnx.xDomain -> xdomain in
			//Xmpps_setwaitAndRestartSessionRun xdomain 10; // restart session after 10 seconds*/
	0)|(sRegistrationError ->
		/* TODO!!*/
		// restart session after 5mn
		//set Xmpps_closedSince = time;
		//let XmppSession.sCnx.xDomain -> xdomain in (
			//XmppSessionStop;
			// just to be sure that all is clean
			//set gRegistrationError = 1;
			//Secho "Xmpp Session error : waiting 5mn and restart"; Secho "domain="; Secholn xdomain; 
			//if (xdomain != nil) then
			//	set run = waitAndRestartSessionRun [time+(5*60) xdomain]
		//);
	0)|(_->0);
0;;


















/**
 * Fonction qui lit les paquets entrants.
 */
fun XmppSessionRead xSession PaquetXml =

	set xSession.sInQueue = conc xSession.sInQueue PaquetXml::nil; // Ajout en queue du dernier element
	
	/*
	// DEBUG AFFICHAGE DE LA QUEUE
	Xw "INQUEUE : ";
	let hd xSession.sInQueue -> hdM in
	let tl xSession.sInQueue -> tlM in
	(
		while hdM != nil do (
			XMLPrintContent hdM 5;
			Xw "-------------------------------";
			set hdM = hd tlM;
			set tlM = tl tlM
		)
	);
	
	// DEBUG AFFICHAGE DE LA QUEUE
	Xw "OUTQUEUE : ";
	let hd xSession.sOutQueue -> hdM in
	let tl xSession.sOutQueue -> tlM in
	(
		while hdM != nil do (
			let hdM -> [NextState To Type Content] in
			(
				Xw match NextState with (ssLogging -> "Logging") | (ssBind -> "Bind") | (ssStartSession -> "UnBind") | (_ -> "Autre");
				Xw strcatlist To::"-"::nil;
				Xw Content;
				Xw "-------------------------------"
			);
			set hdM = hd tlM;
			set tlM = tl tlM
		)
	);*/
	
	// Traitement des retours du serveur
	let 0 -> dowhile in
	while match xSession.sState with (ssFree -> 1)|(_-> set dowhile = dowhile + 1; if dowhile == 1 then 1 else 0 ) && xSession.sInQueue != nil  do (
		let XmppSessionProcessR xSession xSession.sInQueue nil -> NextOne in
		(
			if NextOne == nil then	(Xw "Erreur in XmppSessionRead(0)"; 0) // Pas logique car ProcessR, le retour n'est jamais nul
			else
			(
				let NextOne -> [NextState StrXml] in
				(
					if NextState != nil then
						set xSession.sState = NextState;
					if StrXml != nil then
						XmppGateSend xSession StrXml
				)
			)
		)
	);
	
	match xSession.sState with
	(ssFree -> // On est prÍt a executer les commandes souhaitÈes
		
		if xSession.sNextResource != nil then (	// Si on doit changer de ressource
			if (!strcmp xSession.sNextResource xSession.sResource) then ( // Si les ressouces sont identiques il ne se passe rien
				set xSession.sNextResource = nil;	// UPDATE
			0)else (
				set xSession.sPreviousResource = xSession.sResource;	// On sauvegarde notre ressource actuelle qui va etre liberee
				set xSession.sState = ssBind;
				XmppGateSend xSession (XmppCreateBindIQ xSession xSession.sNextResource); 
			0)
		);
		
		if xSession.sNextResource == nil then ( // sinon (finalement, il n'y a pas de NexResource
			let hd xSession.sOutQueue -> hdOutQueue in
			let tl xSession.sOutQueue -> tlOutQueue in
			(
				while match xSession.sState with (ssFree -> 1)|(_->0) && hdOutQueue != nil  do (
					let hdOutQueue -> [NextState To Type Content] in
					(
						if NextState != nil then
							set xSession.sState = NextState;
						if Type != nil then
							XmppGateSend xSession (xmpps_createStanza xSession (xSession.sJID) To Type Content) 
					);
					set hdOutQueue = hd tlOutQueue;
					set tlOutQueue = tl tlOutQueue
				);
				set xSession.sOutQueue = tlOutQueue // Mise ‡ jour de la queue
			);
			0
		);
		
	1)|(_ -> 0)
;;


fun XmppGetRsc xSession =
	xSession.sResource
;;


fun XmppSessionProcessR xSession Liste Acc =
	let hd Liste -> PaquetXml in
	let tl Liste -> tlListe in
	let XmppSessionProcess xSession PaquetXml -> R in
	(
		if R != nil then (	// Si on a quelque chose a executer avant de faire le reste de la liste des elements reÁus
			set xSession.sInQueue = conc Acc tlListe;	// Ceux qui sont arrivee en premier et non traitee :: reste de la liste
			R
		) else	// R = nil > le paquet traitee n'est pas le bon, on le laisse dans la pile et on passe au suivant
		(
			if (hd tlListe) == nil then ( // il n'y a plus d'actions ‡ faire
				if (hd Acc) != nil then
					set xSession.sInQueue = conc Acc PaquetXml::nil // On met a jour la liste des actions encore a traiter
				else
					set xSession.sInQueue = PaquetXml::nil; // On met a jour la liste des actions encore a traiter
				[nil nil] // On a traiter tous ÈlÈments de la liste de retour, on reste dans le mÍme Ètat et on passe ‡ la suite
			)else ( // il nous reste encore des actions ‡ faire
				if (hd Acc) != nil then
					set Acc = conc Acc PaquetXml::nil
				else
					set Acc = PaquetXml::nil;
				XmppSessionProcessR xSession tlListe Acc
			)
		)
	)
;;


proto XmppSessionProcessHandleStanzaIq 2;;


/**
 * Fonction qui traite un paquet entrant.
 */
fun XmppSessionProcess xSession PaquetXml =
	if PaquetXml == nil then (
		
		if (match xSession.sStatus with (sLoggedin ->1)|(_->0)) then (
			// In logging phase, try to reopen while negociating (base XMPP protocol)
			Secholn "ReOpenStreamXmpp";
			XmppGateReOpenStream xSession;
			/* ETAT SUIVANT */
			[nil nil]	// on ne renvoie rien.
		) else (
			XmppSessionIsDisconnected xSession;	// server closed stream
			/* ETAT SUIVANT */
			[nil nil] // on ne renvoie rien.
		)
		
	) else (
		match PaquetXml with
		(ContentElement xmlStanza ->
			
			// On a vraiment reÁu quelque chose
			match xSession.sStatus with (sOpened -> set xSession.sNextRestart = -1) | (_ -> 0);
			
			//type tXmppSessionStreamState = ssRegister1 | ssRegister2 | ssBind | ssUnBind | ssStartSession | ssGetSource | ssFree | ssLogging;;
			// ss pour Stream State
			// Register1 > PremiËre phase de l'enregistrement
			// Register2 > Seconde phase de l'enregistrement
			// Bind > Acquisition de la Ressource
			// UnBind > Rendre la Ressource
			// Session > Creation d'une session
			// Source > RecupÈration des sources
			// Free > Connected, pret a faire les action
			// Logging > Process de loggin (auth, challenge, ...)
			match xSession.sState with
			
			
			
			
			
			
			
			
			
			
			(ssRegister1 -> // PremiËre phase d'enregistrement
			  Xw "State : Register // Step 1";			  	
			  	if !strcmp xmlStanza.nameS "iq" then (	// On a bien un iq
			  	
			  		let Xml_GetElementAttribute xmlStanza "id" 		-> id in	// On recupere l'ID
					let Xml_GetElementAttribute xmlStanza "type" 	-> type in	// et le type
					(
						if (!strcmp type "result") then ( // Si on a un resultat, on continue
							
							Xw "Go to state : Register // Step 2 -- start register";
							set xSession.sPassword = GenXmppPassword;	// On genere le mot de passe
							
							// RETOURNE [ETATSUIVANT XML]
							[ssRegister2 /* ETAT SUIVANT */
								(xmpps_createStanza xSession
								nil /* PAS DE FROM*/
								(xmpps_ServerJID xSession) /* Vers le Serveur */
								stanzaIQSet /* Type dy stanza Envoyee */
								(strcatlist "<query xmlns=\"violet:iq:register\"><username>"::xSession.sUsername::"</username><password>"::(XorHexStr xSession.sPassword xSession.sUsername)::"</password></query>"::nil))]
						)else if (!strcmp type "error") then (
							
							Xw "Error registering phase1";
							httprequest "GET" (sendmailxmppurl xSession.sDomain "FailureRegister1") nil nil HTTP_NORMAL;
							
							// TODO : Gestion de l'erreur
							XmppSessionSetStatus xSession sRegistrationError;
							[	ssFree /* Pas d'etat suivant */
								nil /* Pas de retour */
							]
						)else (
							Xw strcatlist "Type unwanted : "::type::"!!!"::nil;
							nil	// On retourne rien, donc on met dans la queue
						)
					)
			  	)else nil	// stanza non souhaitÈ, mise en attente
			
			
			
			
			
			
			
			
			
			
			)|(ssRegister2 -> // Seconde phase d'enregistrement
				
				Xw "State : Register // Step 2";
				
				if !strcmp xmlStanza.nameS "iq" then (	// On a bien un iq
			  	
			  		let Xml_GetElementAttribute xmlStanza "id" 		-> id in	// On recupere l'ID
					let Xml_GetElementAttribute xmlStanza "type" 	-> type in	// et le type
					(
						if (!strcmp type "result") then ( // Si on a un resultat, on continue
							Xw "Register succeeded";
							SetXmppPassword xSession.sPassword;
									
							// NOT DISPLAYED! Xw strcatlist "snd start login, user='"::xSession.sUsername::"', pwd='"::xSession.sPassword::"'"::nil;
							Xw "snd start login";
									
							XmppSessionSetStatus xSession sLogging; // Change the status
							
							/* ETAT SUIVANT */
							[ssLogging "<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='DIGEST-MD5'/>"]
						) else if (!strcmp type "error") then (
							
							Xw "XML in=["; XMLPrintContent PaquetXml 0; Xw "]";
							Xw "error registering phase2";
							
							httprequest "GET" (sendmailxmppurl xSession.sDomain "FailureRegister2") nil nil HTTP_NORMAL;
							
							XmppSessionSetStatus xSession sRegistrationError;
							/* ERREUR, ON LIBERE */
							[ssFree nil]
						) else nil // stanza non souhaitÈ, mise en attente
					)
				)else nil	// stanza non souhaitÈ, mise en attente
			
			
			
			
			
			
			
			
			
			
			
			)|(ssBind -> // On a lancÈ une demande de ressource
				Xw strcatlist "State : Binding From : ":: xSession.sResource::" To : ":: xSession.sNextResource::" -- "::xSession.sPreviousResource::nil;
				
				if !strcmp xmlStanza.nameS "iq" then (	// On a bien un iq
			  	
			  		let Xml_GetElementAttribute xmlStanza "id" 		-> id in	// On recupere l'ID
					let Xml_GetElementAttribute xmlStanza "type" 	-> type in	// et le type
					(
						if (!strcmp type "result") then (
							let (Xml_FindFirstElementNamed xmlStanza "bind") -> bind in if (bind != nil) then 
							let Xml_GetElementAttribute bind "xmlns" -> xmlns in if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-bind") then
							let (Xml_FindFirstElementNamed bind "jid") -> jid in if (jid != nil) then
							let (Xmp_GetTextContent jid) -> jidstr in if (jidstr != nil) then (		// Nouveau JID reÁu par le BIND

								set xSession.sNextResource = nil; // on a reussit ‡ arriver dans cette Ètat
								set xSession.sJID = jidstr;	// Sauvegarde les JID et ressources
								set xSession.sResource = xmpps_JIDResource xSession.sJID;
							
								Xw "Bind Done!";
								Xw strcatlist "JID="::xSession.sJID::nil;
								Xw strcatlist "Resource="::xSession.sResource::nil;
								
								// Attention, si il y a eu un request ressource pendant l'etat bind, cette nouvelle ressource est dans sNextResourceBinding
								// on la met donc dans sNextResource si cette variable n'est pas vide (cela permettra de passer dans la ressource requise au
								// bon moment
								if xSession.sNextResourceBinding != nil then (
									set xSession.sNextResource = xSession.sNextResourceBinding;
									set xSession.sNextResourceBinding = nil
								);
								set xSession.sState = ssStartSession;
								[ssStartSession
									xmpps_createStanza xSession xSession.sJID (xmpps_ServerJID xSession) stanzaIQSet "<session xmlns='urn:ietf:params:xml:ns:xmpp-session'/>"]
							)
						) else if (!strcmp type "error") then (
							Xw "XML in=["; XMLPrintContent PaquetXml 0; Xw "]";
							Xw "error binding";
							[ssFree nil]	// on n'envoie rien.
						) else nil // stanza non souhaitÈ, mise en attente
					)
				)else nil // stanza non souhaitÈ, mise en attente
			
			
			
			
			
			
			
			
			
			
			)|(ssUnBind -> // On est en train de rendre une ressource
			
				Xw "State : UnBinding";
				
				if !strcmp xmlStanza.nameS "iq" then (	// On a bien un iq
			  	
			  		let Xml_GetElementAttribute xmlStanza "id" 		-> id in	// On recupere l'ID
					let Xml_GetElementAttribute xmlStanza "type" 	-> type in	// et le type
					(
						if (!strcmp type "result") then (
							Xw "Unbind done!";
							set xSession.sPreviousResource = nil;	// Reussite, on supprime alors l'ancienne ressource
							
							Xw strcatlist xSession.sJID::" : New Session"::nil;
					
							/* ETAT SUIVANT */
							[ssFree nil]

						) else if (!strcmp type "error") then (
							Xw "XML in=["; XMLPrintContent PaquetXml 0; Xw "]";
							Xw "error unbinding";
							
							/* ETAT SUIVANT */
							[ssFree nil]
						) else nil // stanza non souhaitÈ, mise en attente
					)
				)else nil	// stanza non souhaitÈ, mise en attente
			
			
			
			
			
			
			
			
			
			
			)|(ssStartSession -> // On est en train d'ouvrir une session
				
				Xw "State : Opening a session";
				
				if !strcmp xmlStanza.nameS "iq" then (	// On a bien un iq
			  	
			  		let Xml_GetElementAttribute xmlStanza "id" 		-> id in	// On recupere l'ID
					let Xml_GetElementAttribute xmlStanza "type" 	-> type in	// et le type
					(
						if (!strcmp type "result") then (
							
							set xSession.sNextRestart = -1;
							XmppSessionSetStatus xSession sOpened;
							leds_set_state LEDS_STATE_XMPP_CONNECTED ;
							
							Xw "Session opened!";

							if (!strcmp xSession.sResource "boot") then (
								// request initial sources to="sources@xmpp.objects.violet.net/sources"
								Xw "Request for sources";
								/* ETAT SUIVANT */
								[
									ssGetSource
									xmpps_createStanza xSession
										xSession.sJID /* FROM */
										(strcatlist ( XmppVioletPlatformClient :: "@" :: (xmpps_ServerJID xSession) :: "/sources" :: nil))
										stanzaIQGet /* Type = iq & get */
										"<query xmlns=\"violet:iq:sources\"><packet xmlns=\"violet:packet\" format=\"1.0\"/></query>"
								]
							) else (
								Xw "Send Presence";
								/* ETAT SUIVANT */
								[	ssPresence
									xmpps_createStanza xSession
									xSession.sJID /* FROM */
									nil /* TO */
									stanzaPresence /* Type = iq & get */
									nil
								]
							)
						)else if (!strcmp type "error") then (
							Xw "XML in=["; XMLPrintContent PaquetXml 0; Xw "]";
							Xw "error opening session";
							
							/* ETAT SUIVANT */
							[ssFree nil]
						) else nil // stanza non souhaitÈ, mise en attente
					)
				)else nil	// stanza non souhaitÈ, mise en attente
			
			
			
			
			
			
			
			
			
			
			)|(ssPresence ->
				if (!strcmp xmlStanza.nameS "presence") then (		// Si on reÁoit une prÈsence
					let Xml_GetElementAttribute xmlStanza "from" -> from in
						Xw strcatlist "Free now!  "::from::nil;
					/* ETAT SUIVANT */
					let (xmpps_BindJID xSession xSession.sPreviousResource) -> previousjid in
						if (previousjid == nil) then (
							[ssFree nil]
						) else (
                                                        [ssUnBind
                                                                 xmpps_createStanza xSession previousjid (xmpps_ServerJID xSession) stanzaIQSet strcatlist "<unbind xmlns='urn:ietf:params:xml:ns:xmpp-bind'><resource>"::xSession.sPreviousResource::"</resource></unbind>"::nil]
                                                 )
				)else
					nil // on empile si on a pas un presence
			
			
			
			
			
			
			
			
			
			
			)|(ssGetSource -> // On est en train de rÈcupÈrer les sources
			
				Xw "State : Getting Sources";
				
				if !strcmp xmlStanza.nameS "iq" then (	// On a bien un iq
			  	
			  		let Xml_GetElementAttribute xmlStanza "id" 		-> id in	// On recupere l'ID
					let Xml_GetElementAttribute xmlStanza "type" 	-> type in	// et le type
					(
						// verifier from plateforme xmpp.objects.violet.net
						let Xml_GetElementAttribute xmlStanza "from" -> from in
						if ( (strcmp (xmpps_JIDPlatform from) XmppVioletObjectsComponent) && (strcmp (xmpps_JIDNode from) XmppVioletPlatformClient) ) then (	// Si ce n'est pas la plateforme... Hacker?
							
							Xw "XML in=["; XMLPrintContent PaquetXml 0; Xw "]";
							Xw strcatlist "Error : received msg from ":: from ::" dropped (" :: (xmpps_JIDPlatform from) :: ")" :: nil;
							
							/* ETAT SUIVANT */
							[xSession.sState nil]
							
						) else if (!strcmp type "result") then ( // Si on a un result
						
							// EXECUTION DE LA TRAME DE RETOUR
							let (Xml_GetElementAttribute xmlStanza "to") -> to in if (to != nil) then
							let xmpps_JIDResource to -> resourceName in
							let (Xml_FindFirstElementNamed xmlStanza "query") -> query in if (query != nil) then 
							let Xml_GetElementAttribute query "xmlns" -> xmlns in if (!strcmp xmlns "violet:iq:sources") then
							let (Xml_FindFirstElementNamed query "packet") -> packet in if (packet != nil) then
							let Xml_GetElementAttribute packet "xmlns" -> xmlns_packet in if (!strcmp xmlns_packet "violet:packet") then
							let Xml_GetElementAttribute packet "format" -> format in if (!strcmp format "1.0") then
							let Xml_GetElementAttribute packet "ttl" -> ttl in
							let (Xmp_GetTextContent packet) -> data_64 in if (data_64 != nil) then
							// decode trame
							let B64toS data_64 -> ping_trame in (
								//Xw "ping_trame_64="; Xw data_64;
								processIncomingTrame ping_trame resourceName ttl
							);
							
							Xw "We have the sources!";
							
							/* ETAT SUIVANT */
							[ssFree nil] // On repasse en libre
						) else if (!strcmp type "error") then (
							Xw "Error getting sources";
							Xw "XML in= ";
							XMLPrintContent PaquetXml 0;
							
							// Pas de resource donc on relance le process de connexion 
							XmppSessionIsDisconnected xSession;	
	
							// TODO : RELANCER 10 SECONDES APRES
							//xmpps_scheduleIQ xSession (time + 10) iqSources xSession.sClients.clSOURCES "get" "<query xmlns=\"violet:iq:sources\"><packet xmlns=\"violet:packet\" format=\"1.0\"/></query>";
							// Pour le moment on libËre
							[ssFree nil]
						) else nil	// stanza non souhaitÈ, mise en attente
					)
				)else nil	// stanza non souhaitÈ, mise en attente
			
			
			
			
			
			
			
			
			
			
			
			)|(ssLogging ->	// On n'est pas encore connectÈ
				
				Xw "State Logging";
				
				if (!strcmp xmlStanza.nameS "stream:features") then (	// Si on a du dÈtail sur le flux				
					// stream:features
					// teste si on a un element 'mechanisms'. Si non, on stoppe tout de suite
					Xw "Receive stream:features";
					
					// Ici, on exploite le fait que stream:features est ouvert avant authentification et
					// aprËs (une fois que Áa a marchÈ).
					
					// mechanisms
					let (Xml_FindFirstElementNamed xmlStanza "mechanisms") -> mechanisms in
					if (mechanisms != nil) then (
						let Xml_GetElementAttribute mechanisms "xmlns" -> xmlns in
						if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-sasl") then (
							// On devrait tester register / login ?
							Xw "Receive mechanisms";
							
							// Register ou login ?
							if (NOWREGISTER == 1 || xSession.sPassword == nil) then (
								Xw "No password (or not good) : start register";
								
								/* ETAT SUIVANT */
								[ssRegister1
								xmpps_createStanza xSession xSession.sJID nil stanzaIQGet "<query xmlns='violet:iq:register'/>"]
							)else(
								//Xw strcatlist "Start login, user ='"::xSession.sUsername::"', pass='"::xSession.sPassword::"'"::nil;
								Xw "Start login";
								XmppSessionSetStatus xSession sLogging;
								
								/* ETAT SUIVANT */
								[ssLogging
								"<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='DIGEST-MD5'/>"]
							)
						
						) else (
							Xw "No SASL!";
							/* ETAT SUIVANT */
							[ssLogging nil]
						)
					) else (
						// bind: seconde ouverture de stream:features.
						let (Xml_FindFirstElementNamed xmlStanza "bind") -> bind in
						if (bind != nil) then (	// Si on reÁoit bien un bind
							let Xml_GetElementAttribute bind "xmlns" -> xmlns in
							if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-bind") then (
								Xw "Receive Bind (in Logging)";
								
								set NOWREGISTER = 0;
								
								set xSession.sPreviousResource = nil;	// Pas de ressource prÈcÈdente
								/* ETAT SUIVANT */
								[ssBind
								XmppCreateBindIQ xSession "boot"]
								
							) else
								[ssFree nil] // xmlns incorrect. TODO: envoyer une erreur.
						) else
							[ssFree nil] // ni mechanism ni sasl. TODO: envoyer une erreur.
					)
				
				
				) else if (!strcmp xmlStanza.nameS "challenge") then (
					let (Xmp_GetTextContent xmlStanza) -> Text in
						/* ETAT SUIVANT */
						[ssLogging Sasl_processChallenge xSession Text]
								
				
				) else if (!strcmp xmlStanza.nameS "failure") then (
					let Xml_GetElementAttribute xmlStanza "xmlns" -> xmlns in
					if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-sasl") then (
						
						Xw "Failure to login. Warn server and re-register";
						httprequest "GET" (sendmailxmppurl xSession.sDomain "FailureLogin") nil nil HTTP_NORMAL;
						// first reset all values set by login
						set xSession.sNonce = nil;
						set xSession.sCnonce = nil;
						set xSession.sRealm = nil;
						set xSession.sQop = "auth";
						set xSession.sAlgo = nil;
						set xSession.sCharset = nil;
						
						set NOWREGISTER = 1;
						
						XmppSessionIsDisconnected xSession;
						
						// On s'enregistre a nouveau
						/* ETAT SUIVANT */
						[ssLogging nil /*xmpps_createStanza xSession xSession.sJID nil stanzaIQGet "<query xmlns='violet:iq:register'/>"*/]
					)else (
						/* ETAT SUIVANT */
						[ssLogging nil]
					)
				
				
				) else if (!strcmp xmlStanza.nameS "success") then (
					let Xml_GetElementAttribute xmlStanza "xmlns" -> xmlns in
						if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-sasl") then (
							Xw "rcv success, snd reopen stream";
							// On doit rÈouvrir le stream
							// TODO REVOIR
							XmppSessionSetStatus xSession sLoggedin;
							XmppGateReOpenStream xSession
						);
					[ssLogging nil]
				) else	nil // stanza non souhaitee, on empile
			
			
			
			
			
			
			
			
			
			
			
			)|(ssFree -> // On est libre de faire les actions venant de la plateforme
				Xw "State : we are free and ready";

				if !strcmp xmlStanza.nameS "iq" then (	// SI ON A UN IQ
					XmppSessionProcessHandleStanzaIq xSession xmlStanza 
				) else if	(!strcmp xmlStanza.nameS "message") then ( 			// Si on a un message
					Xw "We got a message";
					
					let  Xml_GetElementAttribute xmlStanza "id" -> id in
					let (Xml_FindFirstElementNamed xmlStanza "packet") -> packet in
					if (packet != nil) then (
						let (Xml_GetElementAttribute xmlStanza "to") -> to in if (to != nil) then
						let xmpps_JIDResource to -> resourceName in
						let Xml_GetElementAttribute packet "xmlns" -> xmlns in if (!strcmp xmlns "violet:packet") then
						let Xml_GetElementAttribute packet "format" -> format in if (!strcmp format "1.0") then
						let Xml_GetElementAttribute packet "ttl" -> ttl in
						let (Xmp_GetTextContent packet) -> data_64 in if (data_64 != nil) then
						let B64toS data_64 -> ping_trame in 
							processIncomingTrame ping_trame resourceName ttl	// EXECUTION DE LA TRAME
					);
					
					/* ETAT SUIVANT */
					[nil nil] //on ne change pas d'etat car si cela est fait dans processIncomingTrame (par exemple ssBind, on se fait avoir en l'enlevant)
				
				
				) else if (!strcmp xmlStanza.nameS "presence") then (		// Si on reÁoit une prÈsence
					let Xml_GetElementAttribute xmlStanza "from" -> from in
						Xw strcatlist "rcv presence from "::from::nil;
					/* ETAT SUIVANT */
					[nil nil]
				) else if (!strcmp xmlStanza.nameS "stream:error") then (
					Xw "Erreur dans le flux!";
					[nil nil]
				) else /* ETAT SUIVANT */ [nil nil] /* Si il s'agit d'autre chose, on ne le prend pas en compte */
			
			
			
			
			)|(_ -> // On est dans un Ètat inconnu ici, pas normal
			
				Xw "State : starting?";
				Xw "State : UNKNOWN!!";
				[nil nil]
			
			)

		) | ( ContentText Texte ->
			Xw strcatlist "Received text:'"::Texte::"', dropping"::nil;
			[nil nil] // on n'envoie rien.
		) | (_ -> nil)
	)
;;



proto XmppSessionProcessHandleStanzaIqSet 2;;
proto XmppSessionProcessHandleStanzaIqGet 2;;
proto XmppSessionProcessHandleStanzaIqError 1;;


/**
	UtilisÈ pour le getrunningstate, convertit un etat du lapin sous forme textuelle
*/
fun xmppStateToStr state = 
//			match xSession.sStatus with (sOpened -> set xSession.sNextRestart = -1) | (_ -> 0);
	match state with
			( ssRegister1 -> "ssRegister1" )
		|	( ssRegister2 -> "ssRegister2" )
		|	( ssBind -> "ssBind" )
		|	( ssUnBind -> "ssUnbind" )
		|	( ssStartSession -> "ssStartSession" )
		|	( ssGetSource -> "ssGetSource" )
		|	( ssFree -> "ssFree" )
		|	( ssLogging -> "ssLogging" )
		|	( ssPresence -> "ssPresence" )
;;


/**
 GËre la rÈponse ‡ apporter ‡ un IQ

  xSession: les infos de session xmpp
  xmlStanza: l'iq reÁu

  --> le couple [ action nouvel_etat ] pour savoir o˘ aller dans la machine ‡ Ètat fini
*/
fun XmppSessionProcessHandleStanzaIq xSession xmlStanza =
	// check that message from xmpp.objects.violet.net or xmpp.platform.violet.net
	let Xml_GetElementAttribute xmlStanza "from" -> from in
	if ((strcmp (xmpps_JIDPlatform from) XmppVioletPlatformComponent)
			&& (strcmp (xmpps_JIDPlatform from) XmppVioletObjectsComponent)
			&& (strcmp (xmpps_JIDPlatform from) XmppVioletAppletComponent)) then (
		Xw strcatlist "Error : received msg from "::from::"dropped"::nil;
		[ssFree nil]
	)
	else
	(
		let Xml_GetElementAttribute xmlStanza "id" 		-> id in	// On recupere l'ID
		let Xml_GetElementAttribute xmlStanza "type" 	-> type in	// et le type
		let ( 
			if (!strcmp type "set") then
				XmppSessionProcessHandleStanzaIqSet xSession xmlStanza
			else if (!strcmp type "get") then
				XmppSessionProcessHandleStanzaIqGet xSession xmlStanza
			else
				XmppSessionProcessHandleStanzaIqError type
			) -> [ error answear newstate ] in
		(
			XmppSessionResponseSend xSession (xmpps_createStanza xSession
				xSession.sJID /* FROM */
				from /* To > Retour a l'envoyeur */
				(if 0==error then (stanzaIQResult id) else (stanzaIQError id))
				answear );
			newstate
		)
	)
;;


/**
	GËre un IQ de type "set"

  xSession: les infos de session xmpp
  xmlStanza: l'iq reÁu

	--> [ contenu_de_la_reponse [ action nouvel_etat ]]
*/
fun XmppSessionProcessHandleStanzaIqSet xSession xmlStanza = 
	let (
	// Si on reÁoit un paquet "addresses", on met ‡ jour les clients
	let (Xml_FindFirstElementNamed xmlStanza "addresses") -> addresses in
	let (Xml_FindFirstElementNamed xmlStanza "command") -> command in
	if (addresses != nil) then (
		let Xml_GetElementAttribute addresses "xmlns" -> xmlns in
		if (!strcmp xmlns "violet:iq:addresses") then (
			let addresses.content -> l in
			(
				while ((hd l) != nil) do (
					let (hd l) -> xmlPaqi in (
						match xmlPaqi with
							(ContentElement subXml ->
								if (!strcmp subXml.nameS "int") then (
									Secho "int=";
									set xSession.sClients.clINT = Secholn (Xmp_GetTextContent subXml)
								) else if (!strcmp subXml.nameS "asr") then (
									Secho "asr=";
									set xSession.sClients.clASR = Secholn (Xmp_GetTextContent subXml)
								) else if (!strcmp subXml.nameS "ppt") then (
									Secho "ppt=";
									set xSession.sClients.clPPT = Secholn (Xmp_GetTextContent subXml)
								) else if (!strcmp subXml.nameS "rfid") then (
									Secho "rfid=";
									set xSession.sClients.clRFID = Secholn (Xmp_GetTextContent subXml)
								) else if (!strcmp subXml.nameS "itmode") then (
									Secho "itmode=";
									set xSession.sClients.clITMODE = Secholn (Xmp_GetTextContent subXml)
								) else if (!strcmp subXml.nameS "sources") then (
									Secho "sources=";
									set xSession.sClients.clSOURCES = Secholn (Xmp_GetTextContent subXml)
								);
							0)|(_ -> 0)
					);
					set l = tl l
				)
			)
		);
		nil
	)
	else
	if nil != command then
	(
		let Xml_GetElementAttribute command "xmlns" -> xmlns in
		let Xml_GetElementAttribute command "node" -> node in
		let Xml_GetElementAttribute command "action" -> action in // action='execute'  est optionnel
		if (!strcmp xmlns "http://jabber.org/protocol/commands") then
			if (!strcmp node "getconfig") then
			( strcatlist
					"<command xmlns='http://jabber.org/protocol/commands' node='getconfig' status='completed'>"
					:: "<x xmlns='jabber:x:data' type='result'><item>"
					:: "<field var='bytecode_revision'><value>" :: getBytecodeRevision :: "</value></field>"
					:: "<field var='wifi_ssid'><value>" :: (StoB64 confGetWifissid) :: "</value></field>"
					:: "<field var='wifi_crypt'><value>" :: (itoa confGetWificrypt) :: "</value></field>"
					:: "<field var='net_dhcp'><value>" :: (itoa confGetDhcp) :: "</value></field>"
					:: "<field var='net_ip'><value>" :: (webip confGetNetip) :: "</value></field>"
					:: "<field var='net_mask'><value>" :: (webip confGetNetmask) :: "</value></field>"
					:: "<field var='net_gateway'><value>" :: (webip confGetNetgateway) :: "</value></field>"
					:: "<field var='net_dns'><value>" :: (webip confGetNetdns) :: "</value></field>"
					:: "<field var='server_url'><value>" :: confGetServerUrl :: "</value></field>"
					:: "<field var='login'><value>" :: (StoB64 confGetLogin) :: "</value></field>"
//				:: "<field var='passwd'><value>" :: (StoB64 confGetPwd) :: "</value></field>"
					:: "<field var='proxy_enabled'><value>" :: (itoa confGetProxy) :: "</value></field>"
					:: "<field var='proxy_ip'><value>" :: (webip confGetProxyip) :: "</value></field>"
					:: "<field var='proxy_port'><value>" :: (itoa confGetProxyport) :: "</value></field>"
					:: "</item></x>"
					:: "</command>"
					:: nil
			)
			else if (!strcmp node "getrunningstate") then
			( strcatlist
				"<command xmlns='http://jabber.org/protocol/commands' node='getrunningstate' status='completed'>"
					:: "<x xmlns='jabber:x:data' type='result'><item>"
					:: "<field var='connection_mode'><value>" :: (if (1 == xSession.sGate.pActualMode) then "tcp" else "bosh") :: "</value></field>"
					:: "<field var='net_ip'><value>" :: (webip netip) :: "</value></field>"
					:: "<field var='net_mask'><value>" :: (webip netmask) :: "</value></field>"
					:: "<field var='net_gateway'><value>" :: (webip netgateway) :: "</value></field>"
					:: "<field var='net_dns'><value>" :: dnslisttostr :: "</value></field>"
					:: "<field var='sState'><value>" :: (xmppStateToStr xSession.sState) :: "</value></field>"
					:: "<field var='sResource'><value>" :: xSession.sResource :: "</value></field>"
					:: "<field var='gItState'><value>" :: (itoa gItState) :: "</value></field>"
					:: "<field var='gSleepState'><value>" :: (itoa gSleepState) :: "</value></field>"
					:: "<field var='gStreamingState'><value>" :: (itoa gStreamingState) :: "</value></field>"
					:: "<field var='gProcessingState'><value>" :: (itoa gProcessingState) :: "</value></field>"
					:: "<field var='gProcessingWaitState'><value>" :: (itoa gProcessingWaitState) :: "</value></field>"
					:: "<field var='gBusyState'><value>" :: (itoa gBusyState) :: "</value></field>"
					:: "<field var='gItApp'><value>" :: gItApp :: "</value></field>"
					:: "<field var='run'><value>" :: (runToStr run) :: "</value></field>"
					:: "</item></x>"
					:: "</command>"
					:: nil
			)
		else
		(
			nil
		)
	)
	else
	(
		// si on reÁoit un paquet "packet", on execute la trame reÁue
		let (Xml_FindFirstElementNamed xmlStanza "packet") -> packet in
		if (packet != nil) then ( 
			let (Xml_GetElementAttribute xmlStanza "to") -> to in
			if (to != nil) then (
				let xmpps_JIDResource to -> resourceName in
				let Xml_GetElementAttribute packet "xmlns" -> xmlns in
				if (!strcmp xmlns "violet:packet") then (
					let Xml_GetElementAttribute packet "format" -> format in
					if (!strcmp format "1.0") then (
						let Xml_GetElementAttribute packet "ttl" -> ttl in
						let (Xmp_GetTextContent packet) -> data_64 in
						if (data_64 != nil) then (
							let B64toS data_64 -> ping_trame in
							 (processIncomingTrame ping_trame resourceName ttl ; nil)
						)
					)
				)
			)
		);
		nil
	)
	) -> s in [ 0 s [ nil nil ]]
;;


/**
	GËre un IQ de type "get"

  xSession: les infos de session xmpp
  xmlStanza: l'iq reÁu

	--> [ contenu_de_la_reponse [ action nouvel_etat ]]
*/
fun XmppSessionProcessHandleStanzaIqGet xSession xmlStanza =
	let (
		let (Xml_FindFirstElementNamed xmlStanza "query") -> query in
		if (nil!=query) then (
			let Xml_GetElementAttribute query "xmlns" -> xmlns in
			let Xml_GetElementAttribute query "node" -> node in
			// XEP-0092: Software Version (http://www.xmpp.org/extensions/xep-0092.html)
			if (!strcmp xmlns "jabber:iq:version") then
			(
				[ 0
					strcatlist
										"<query xmlns='jabber:iq:version'>"
										:: "<name>" :: "Nabaztag/tag" :: "</name>"
										:: "<version>" :: getBytecodeRevision :: "</version>"
										:: "</query>" :: nil
				]
			)
			// XEP-0030: Service Discovery (http://www.xmpp.org/extensions/xep-0030.html)
			// (support trËs trËs trËs partiel)
			else if (!strcmp xmlns "http://jabber.org/protocol/disco#info") then
			(
				if nil==node then
					[ 0
						strcatlist
							"<query xmlns='http://jabber.org/protocol/disco#info'>"
						  :: "<feature var='jabber:iq:version'/>"
							:: "<feature var='urn:xmpp:ping'/>"
							:: "</query>" :: nil
					]
				else if (!strcmp node "getconfig") then
					[
						0
						strcatlist
							"<query xmlns='http://jabber.org/protocol/disco#info' node='getconfig'>"
					    :: "<identity name='Gets the configuration of the rabbit' category='automation' type='command-node'/>"
							:: "<feature var='http://jabber.org/protocol/commands'/>"
							:: "<feature var='jabber:x:data'/>"
							:: "</query>" :: nil
					]
				else if (!strcmp node "getrunningstate") then
					[
						0
						strcatlist
							"<query xmlns='http://jabber.org/protocol/disco#info' node='getrunningstate'>"
					    :: "<identity name='Gets the running state of the rabbit' category='automation' type='command-node'/>"
							:: "<feature var='http://jabber.org/protocol/commands'/>"
							:: "<feature var='jabber:x:data'/>"
							:: "</query>" :: nil
					]
				else // node qu'on ne connait pas
					[
						1
						(strcatlist
							// TODO en premier lieu il faudrait (SHOULD)  mettre le xml qu'on a recu
							"<error type='cancel'>"
							:: "<feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>"
							:: "</error>" :: nil)
					]
			)
			else if (!strcmp xmlns "http://jabber.org/protocol/disco#items") then
			(
				if (!strcmp node "http://jabber.org/protocol/commands") then
					[ 0
						strcatlist
							"<query xmlns='http://jabber.org/protocol/disco#items' "
							:: "node='http://jabber.org/protocol/commands'>"
					    :: "<item jid='" :: xSession.sJID :: "' node='getconfig' name='Gets the configuration of the rabbit' />"
					    :: "<item jid='" :: xSession.sJID :: "' node='getrunningstate' name='Gets the running state of the rabbit' />"
							:: "</query>" :: nil
					]
				else
					// c'est un noeud qu'on ne connait pas : vide
					[ 0
						strcatlist
							"<query xmlns='http://jabber.org/protocol/disco#items' "
							:: "node='" :: node :: "' />"
							:: nil
					]
			)
			else (
				[ 1
					(strcatlist
					// TODO en premier lieu il faudrait (SHOULD)  mettre le xml qu'on a recu
					"<error type='cancel'>"
					:: "<feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>"
					:: "</error>" :: nil)
				]
			)
		)
		else
		 [ 1
			( strcatlist
					// TODO en premier lieu il faudrait (SHOULD)  mettre le xml qu'on a recu
					"<error type='cancel'>"
					:: "<feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>"
					:: "</error>" :: nil) 
			]
		) -> [ error answear ]
	in [ error answear [ nil nil ] ]
;;


/**
	GËre un IQ de type inconnu (non gÈrÈ)
*/
fun XmppSessionProcessHandleStanzaIqError type = 
	// ON A UN IQ quelque chose, mais on ne devrait pas en avoir ici!
	Xw strcatlist "!!! Get a iq "::type::"! Not allowed here"::nil;
	[ 1 nil [ nil nil ] ]
;;


// ---------------------------------------------------------
// END XMPP SESSION
// ---------------------------------------------------------



// file reclib.mtl //
var lrec;;
var recording=0;;

fun sqrt_ i i0 i1=
	let (i0+i1)>>1 -> m in
	if m==i0 then i0
	else if m*m>i then sqrt_ i i0 m else sqrt_ i m i1;;
fun sqrt i=sqrt_ i 0 256;;

var buff;;
var buffx;;
var buffy;;

fun cbrec s=
/*	if buff==nil then set buff=strnew 505*2;
	if buffx==nil then set buffx=strnew 505;
	if buffy==nil then set buffy=strnew 505*2;
	adp2wav buff 0 s 0 256;
//	wav2alaw buffx 0 buff 0 505*2 1;
//	alaw2wav buffy 0 buffx 0 505 1;
	set s=wav2adp strnew 256 0 buff 0 505*2;
*/
	Iecho strlen s; Secho "!";
	let 255-(Iecholn sqrt recVol s 0) -> vol in
	let 255-((vol*vol)>>8) -> vol in
	let vol<<16 -> vol in
	(
		led LED_BODY_LEFT vol; led LED_BODY_MIDDLE vol; led LED_BODY_RIGHT vol
	);
	set lrec=s::lrec;
	0;;

fun itobin4 i=
	let strnew 4 -> s in
	(
		strset s 0 i;
		strset s 1 i>>8;
		strset s 2 i>>16;
		strset s 3 i>>24;
		s
	);;

fun liststrlen l r=	if l==nil then r else liststrlen tl l r+strlen hd l;;

fun mkriff ldata=
	Secho "mkriff len=";
	let Iecholn liststrlen ldata 0 -> len in
	(strcatlist "RIFF"::(itobin4 len+52)::"WAVEfmt \$14\0\0\0\$11\0\1\0\$40\$1f\0\0\$d7\$0f\0\0\0\1\4\0\2\0\$f9\01"::
	"fact\4\0\0\0"::(itobin4 (len>>8)*505)::"data"::(itobin4 len)::nil)::ldata;;

fun recstart =
	recStop;
	Secholn "record";
	set recording=1;
	set lrec=nil;
	recStart 8000 0 #cbrec;;

fun recstop =
	set recording=0;
	recStop;;

fun recriff =
	let mkriff rev lrec nil -> res in
	(
		set lrec=nil;
		res
	);;
// end of file reclib.mtl //
// back to file STDIN, line 2976

// file audiolib.mtl //

// wav playback

const WAV_IDLE=0;;
const WAV_RUN=1;;
const WAV_EOF=2;;

const WAV_BUFFER_STARTSIZE=80000;;
const WAV_BUFFER_MAXSIZE=400000;;

const WAV_END_TIMEOUT=500;;
const WAV_NET_TIMEOUT=15000;;

var wav_end_timeout;;

var wav_http_cb=nil;;
var wav_state=0;;
var wav_http;;
var wav_fifo;;
var wav_buffering=0;;
var wav_buffering_since=0;;
var wav_index;;
var wav_lasttime;;
var wav_lastnet;;
var wav_zeros;;
var wav_curplayedbytes=0;;

var lastvol;;
var forcedvol=0;;
fun volfrombutton v=let 255-v -> v in 255-((v*v)>>8);;

// debug
fun Audiowln str = nil;; // Secholn strcatlist "[audio] " :: str :: nil ;;
fun Audiow str = nil;; // Secho str ;;


fun updatevol=
	let button3 -> v in
	if !forcedvol && v!=lastvol && (!recording) && (lastvol!=255 || v<250) then
	(
		set lastvol=v;
		sndVol volfrombutton v
	);;

fun forcevol v=
	sndVol volfrombutton (button3*v)>>8;
	set forcedvol=1;
	0;;
fun unforcevol=
	set forcedvol=0;
	set lastvol=nil;
	0;;

fun wavgetzeros=
	if wav_zeros==nil then
	(
		set wav_zeros=strnew 2048;
		for i=0;i<2048 do strset wav_zeros i 0
	);
	wav_zeros;;

fun wavstop =
	Audiowln "/wavstop/";
	
	if wav_state!=WAV_IDLE then
	(
		playStop;
		if wav_http!=nil then httpabort wav_http;
		set wav_http=nil;
		set wav_buffering = 0;
		set wav_state=WAV_IDLE
	);;

fun wavrunning =
	if wav_state==WAV_IDLE then 0
	else if wav_fifo==nil && wav_state==WAV_EOF && (time_ms-wav_lasttime>wav_end_timeout) then
	(
		Audiowln "###wav detected end";
		wavstop;
		0
	)
	else if wav_lasttime==nil then -1 else 1;;

// The main wav playback callback
// reads from wav_fifo and feeds playFeed
fun _wavplaycb i =
//Secho "p";
	set wav_lasttime=time_ms;			
//	Iecho i;Secho ":cbplay\n";
	if wav_fifo==nil then
	(
		// nothing in fifo
		if wav_state==WAV_EOF then playFeed nil nil nil
		else if !wav_buffering then (
			Audiowln ">>>>buffering";
			set wav_buffering=1;
			set wav_buffering_since = time_ms
		)
	)
	else
	(
		// was buffering ?
		if wav_buffering && (wav_state==WAV_EOF || (slistlen wav_fifo)>=WAV_BUFFER_STARTSIZE) then
		(
			Audiowln "<<<<end_buffering";
			set wav_buffering=0
		);
		if !wav_buffering then
		let hd wav_fifo -> sample in
		let strlen sample -> len in
		(			
			// push sample data
			// wav_index is the index within the current sample.
			if wav_index<len then (
				// send some bytes to the VM buffer.
				let (playFeed sample /*Iecho*/ wav_index nil) -> pushedbytes in (
					// this is how many bytes we sent.
					set wav_index=wav_index+pushedbytes;
					// compute wav_curplayedbytes
					set wav_curplayedbytes = wav_curplayedbytes + pushedbytes
				)
			);
			if wav_index>=len then
			(
				// we sent the whole first sample.
				// (in fact, wav_index cannot be bigger than len).
				// reset the counter on the sample and transition to the next sample.
				set wav_index=0;
				set wav_fifo=tl wav_fifo;
				// Secho "[b-:" ; Iecho (slistlen wav_fifo); Secho "]";
				if wav_http!=nil then if (slistlen wav_fifo)<WAV_BUFFER_MAXSIZE then if !(httpenabledP wav_http) then
				(
					Audiowln "##httpenable 1##";
					httpenable wav_http 1
				)
			)
		)
	);
	0;;

fun _wavstartnow =
	set wav_index=0;
	set wav_buffering=1;
	set wav_buffering_since = time_ms;
	set wav_curplayedbytes=0;
	playStart 1024 #_wavplaycb;;

fun wavstartlocalEx l timeout=
	wavstop;
	set wav_end_timeout=timeout;
	set wav_fifo=conc l (wavgetzeros)::nil;
	set wav_state=WAV_EOF;
	set wav_lasttime=time_ms;
	set wav_http=nil;
	_wavstartnow
	;;

fun wavstartlocal l=wavstartlocalEx l WAV_END_TIMEOUT;;
/*
fun itobin4 i=strcatlist (ctoa i)::(ctoa i>>8)::(ctoa i>>16)::(ctoa i>>24)::nil;;
fun itobin2 i=strcatlist (ctoa i)::(ctoa i>>8)::nil;;

fun mkwav freq channel bps=
	let strcatlist 
		"WAVEfmt "::(itobin4 0x12)::
			(itobin2 1)::(itobin2 channel)::
			(itobin4 freq)::(itobin4 freq*channel*bps/8)::
			(itobin2 channel*bps/8)::(itobin4 bps)::
		"data"::(itobin4 0)::nil -> c in
	strcatlist "RIFF"::(itobin4 (strlen c))::c::nil;;
*/

fun _wavcbhttp httpreq req=
	Audiow "w";
	set wav_lastnet=time_ms;
	if req==nil then
	(
		Audiowln ">>>>>>>>>>>>>>>>>>>>>>>>>>>>><end of file";
		set wav_state=WAV_EOF;
		if wav_fifo!=nil then set wav_fifo=conc wav_fifo (wavgetzeros)::nil;
		if wav_index==nil then
		(
			// had never started wav playback
			// check if something in fifo. If yes, play it, if not stop wav
			set wav_fifo=tl wav_fifo;
			if wav_fifo==nil then wavstop
			else _wavstartnow
		);
		0
	)
	else
	(
//		dump req;
		set wav_fifo=conc wav_fifo req::nil;
		let (slistlen wav_fifo) -> n in
		(
		// Secho "[b+:"; Iecho n ; Secho "]";
		if wav_index==nil && n>WAV_BUFFER_STARTSIZE then
		(
			// had never started wav playback : start it
			set wav_fifo=tl wav_fifo;
			_wavstartnow
		) else if n>WAV_BUFFER_MAXSIZE then (
			Audiowln "##httpenable 0##";
			httpenable httpreq 0
		);
		nil
		)
	);
	updatevol;
	0;;

fun wavstarthttp url cb=
	wavstop;
	set wav_http_cb = cb;
	set wav_end_timeout=WAV_END_TIMEOUT;
	set wav_fifo=nil;
	set wav_state=WAV_RUN;
	set wav_index=nil;
	set wav_buffering=1;
	set wav_buffering_since = time_ms;
	set wav_lasttime=nil;
	set wav_lastnet=time_ms;
	set wav_http=httprequest "GET" url nil #_wavcbhttp HTTP_STREAM;;

fun wavtime =
	// Check timeout against wav_buffering_since
	if (wav_http!=nil && wav_state==WAV_RUN && wav_buffering && (time_ms - wav_buffering_since > WAV_NET_TIMEOUT)) then (
		Audiowln "wavhttp timeout";
		wavstop;
		if (wav_http_cb != nil) then call wav_http_cb []
	);
	0;;
// end of file audiolib.mtl //
// back to file STDIN, line 2980

// file ears.mtl //

/*
 Ears management.

 The link with the hardware is done via two methods: motorget and
 motorset.

 The ear is controlled via an engine that we can start in both
 directions and stop. To get feedback, there is a sensor that returns
 the number of holes it has seen so far. An ear has EARS_HOLES holes,
 with the same space between each hole except for one where the space
 is twice the size. It helps us know the absolute position of the ear.

 Two native methods help us access the hardware:

 * motorget motornum : where motornum is 0 or 1, returns the number of
 holes seen so far.

 * motorset motornum dir : where motornum is 0 or 1 and dir is -1 (go
 backward), 0 (stop), or 1 (go forward).

*/

// file leds_protos.mtl already included

const EARSMODE_RESET=0;; // ears go to ref pos
const EARSMODE_WAIT=1;;
const EARSMODE_WAITANDDETECT=2;;
const EARSMODE_DETECT=3;;

const EARS_HOLES=17;; // number of holes in the ear that can help us track the moves
const EARS_TIMEOUT=2000;; // delay (in ms) to wait when detecting ear movement (if there is no move for EARS_TIMEOUT ms, then consider the move done and do whatever there is to do)
const EARS_OFFZERO=2;; // "offset" between hardware position zero (where there is a missing hole) and "real" position zero (ears pointing to the sky)

// ears echo debug
fun Earsw str = nil;; // Secholn strcatlist "[ears] " :: str :: nil;;

/**
 - numE: the ear number, 0 for right, 1 for left.
 - dirE: the direction in which the ear should move: 0: forward. !=0: backward.
 - targetE: the position we try to go to.
 - targetLoopE: the number of full loops to do before stopping at targetE pos. positive or negative depending on dirE.
 - posE: the last position we know the ear was in, 0 <= posE < EARS_HOLES.
 - lvalE: the last value returned by motorget e.numE
 - delayE: delay (in ms) between two motor holes.
 - ltimeE: last time (in ms) lvalE was updated.
 - countE: ?? (used when returning to previous position after having detected an ear move)
 - brokenE: if 1, the ear has been detected broken (did not respond to instructions). It can no longer be used.
*/
type Ear=[numE dirE targetE targetLoopE posE lvalE ldelayE ltimeE countE brokenE];; // v16 +targetLoopE

var ears;; // tab of two structs type Ear
var earsmode;;
var earslastmove;;	// somme des deux compteurs
var earslastmovetime;;	// heure du dernier mouvement, lors de la d√©tection (=nil=> acquisition en cours)

var earsInited = 0;; // 1 √† partir du moment o√π les oreilles sont initialis√©es

var earevent;;

// position d√©sir√©es des oreilles
var extleft;;
var extright;;

fun eargetevent=
	let earevent -> ev in
	(
		set earevent=nil;
		ev
	);;

/*
 v16 +fun earLoop;;

 returns more or less (v / EAR_HOLES), > 0 (has to be called with prevLoop == 0)
*/
fun earLoopCount v prevLoop=
	if v<0 then earLoopCount v+EARS_HOLES prevLoop-1
	else if v>=EARS_HOLES then earLoopCount v-EARS_HOLES prevLoop+1
	else prevLoop;;

/*
  returns (v % EAR_HOLES), > 0
*/
fun earCheck v=
	if v<0 then earCheck v+EARS_HOLES
	else if v>=EARS_HOLES then earCheck v-EARS_HOLES
	else v;;


fun earMotorset e val =
	Earsw strcatlist "earMotorset " :: (itoa e.numE) :: " " :: (itoa val) :: nil;
	if (!earsInited) then
	(
		Earsw "ears not inited yet" ;
		earInit
	);
	set e.dirE=val;
	motorset e.numE val
;;

fun earStartReset=
	if earsmode!=EARSMODE_RESET then (
		Earsw "earStartReset";
		set earsmode=EARSMODE_RESET;
		for i=0;i<2 do let ears.i -> e in
		(
			Earsw strcatlist "asking for reset of ear " :: (itoa i) :: nil ;
			earMotorset e 1;
			set e.brokenE=0;
			set e.targetE=nil;
			set e.targetLoopE=nil; // v16
			set e.lvalE=motorget i;
			set e.ldelayE=nil;
			set e.ltimeE=time_ms
		);
		Earsw "earStartReset end"
	);;

/*
  Creates the tab to handle the ears. No action should be made
  concerning the ears before having called this function.
*/
fun earInit =
	set ears=tabnew nil 2;
	for i=0;i<2 do set ears.i=[numE:i];
	earStartReset;
	set earsInited = 1
	;;

fun earStartDetect=
	Earsw "earStartDetect";
	setleds RGB_AMBER;
	set earsmode=EARSMODE_DETECT;
	set earslastmovetime=time_ms;
	set earslastmove=(motorget 0)+(motorget 1);;


fun earDetectRun=
	if earslastmovetime!=nil then
	(
		let (motorget 0)+(motorget 1)->newval in
		if newval!=earslastmove then
		(
			set earslastmove=newval;
			set earslastmovetime=time_ms
		)
		else if time_ms-earslastmovetime>EARS_TIMEOUT then
		(
			set earslastmovetime=nil;
			for i=0;i<2 do let ears.i -> e in
			if e.brokenE!=1 then
			(
				set e.lvalE=motorget i;
				set e.ldelayE=0;
				set e.ltimeE=time_ms;
				earMotorset e 1;
				set e.countE=e.lvalE+EARS_HOLES
			)
		)
	)
	else
	(
		for i=0;i<2 do let ears.i -> e in
			if e.brokenE!=1 then
			if e.dirE then
			let motorget i -> v in
			if v!=e.lvalE then
				let time_ms -> t in
				let t-e.ltimeE -> d in
				(
					if d>e.ldelayE then
					(
						set e.posE=earCheck e.countE-e.lvalE-EARS_OFFZERO-1;
						set e.ldelayE=d
					);
					set e.ltimeE=t;
					set e.lvalE=v;
					if v-e.countE>=0 then earMotorset e 0
				);
		if (ears.(0).dirE)==0 && (ears.(1).dirE)==0 then
		(
			set earevent=0x8000+(ears.(0).posE<<8)+(ears.(1).posE);
			Secho "Acquisition : "; Iecho ears.(0).posE; Secho ", ";Iecholn ears.(1).posE;
			set earsmode=EARSMODE_WAITANDDETECT
		)
	);;
		
fun earResetRun=
	Earsw "earResetRun";
	for i=0;i<2 do let ears.i -> e in
	if e.dirE then
	(
		// still trying to move
		let motorget i -> v in
		if v==e.lvalE then
		(	// still previous position
			let time_ms -> t in
			let t-e.ltimeE -> d in
			if d>5000 then
			(
				Earsw strcatlist "broken :" :: (itoa i) :: nil;
				set e.brokenE=1;
				set e.posE=0;
//				set e.lvalE=v;
				set e.targetE=0;
				set e.targetLoopE=0; // v16
				set e.ldelayE=0;
				earMotorset e 0
			)
		)	
		else
		if e.targetE!=nil then
		(	// moved and have a target : check arrived
			set e.posE=earCheck e.posE+v-e.lvalE;
			set e.lvalE=v;
			if e.posE==e.targetE then
				if e.targetLoopE == 0 then
					earMotorset e 0
				else if e.dirE>0 then
					set e.targetLoopE = e.targetLoopE-1
				else
					set e.targetLoopE = e.targetLoopE+1
		)
		else
		let time_ms -> t in
		let t-e.ltimeE -> d in
		(	// moved and no target
			if (d<10000) && (d>600) && (nil!=e.ldelayE) then
			(
				/* if entering there, we know the ear is at position "zero",
					because of the delay between two holes. */
				//Secho "gowait "; Iecholn d; Iecholn e.ldelayE;
				set e.posE=earCheck -EARS_OFFZERO; // position "zero"
				set e.targetE=0;
				set e.targetLoopE=0 //v16
			)
			else
			(
				//Secho "position "; Iecho e.lvalE; Secho " : "; Iecho v; Secho " during "; Iecholn d;
				set e.ltimeE=t
			);
			set e.lvalE=v;
			set e.ldelayE=d
		)
	);
	if (ears.(0).dirE)==0 && (ears.(1).dirE)==0 then
	(
		// finished reset
		set earsmode=EARSMODE_WAIT
	);;

fun earWaitRun=
	for i=0;i<2 do let ears.i -> e in
	if e.brokenE!=1 then
	(
		// Secho "ear "; Iecho i; Secho "last pos="; Iecho e.lvalE; Secho ",pos=";
		let motorget i -> v in
		if v!=e.lvalE then
		let (/* Secho "dv="; Iecho */ v-e.lvalE) -> dv in
		if e.dirE then (
			// Oreille en train de tourner
			//Earsw ", tourne e.dirE="; Iecho e.dirE;
			set e.lvalE=v;
			set e.posE=earCheck e.posE+ if e.dirE>0 then dv else -dv;
			if e.posE==e.targetE then
			(
//					Secho "stop "; Iecholn e.numE;
				if e.targetLoopE == 0 then //v16
					earMotorset e 0
				else if e.dirE>0 then
					set e.targetLoopE = e.targetLoopE-1 //v16
				else
					set e.targetLoopE = e.targetLoopE+1 // v16
			)
		) else if dv>2 then (
			//Earsw "bouged";
			// Pas de mvt autonome.
			// Veut dire qu'une oreille a √©t√© tourn√©e par l'utilisateur :
			// si interactif : le noter
			// sinon passer en mode detect
			set e.lvalE=v;
			if gItState then
				(itNoteEarTouched i v dv)
			else if earsmode==EARSMODE_WAITANDDETECT then
				earStartDetect
		)
	);;

// boucle pour faire tourner les oreilles vers leur targetobjectif
fun earRun=
	if (earsInited) then (
		Earsw strcatlist ("earRun " :: (itoa earsmode) :: nil);
		if earsmode==EARSMODE_RESET then earResetRun
		else if earsmode==EARSMODE_DETECT then earDetectRun
		else earWaitRun
	);
	0;;

fun earResetting= earsmode==EARSMODE_RESET;;
fun earDetecting= earsmode==EARSMODE_DETECT;;
fun earFinishedMoving = (!earResetting) && (!ears.(0).dirE) && (!ears.(1).dirE);;

fun earSetWaitAndDetectMode=
	if earsmode==EARSMODE_WAIT then set earsmode=EARSMODE_WAITANDDETECT;;

fun earSetWaitOnlyMode=
	if earsmode==EARSMODE_WAITANDDETECT then set earsmode=EARSMODE_WAIT;;

fun earStop force =
	Earsw (strcatlist "earStop " :: (itoa force) :: nil);
	if (earsInited && (earsmode!=EARSMODE_RESET || force)) then (for i=0;i<2 do earMotorset ears.i 0) else ( Earsw "ears not inited yet"; 0 );
	0;;

fun earTarget i= ears.(i).targetE + ears.(i).targetLoopE*EARS_HOLES;; // v16

// oreille i doit aller √† position p dans direction d
// i==0 : droite, i==1 : gauche
// p = int quelconque, m√™me > 17
// d==0 : vers l'avant, d!=0 : vers l'arri√®re
fun earGo i p d=
	if (earsInited) then
	if earsmode==EARSMODE_WAIT ||earsmode==EARSMODE_WAITANDDETECT then
	let ears.i->e in
	let (if d then -1 else 1) -> dir in // v16
	if e.brokenE==1 then
	(
		Earsw strcatlist "earGo " :: (itoa i) :: " broken !" :: nil;
		nil
	)
	else		
	if p!=earTarget i then //v16 add start
	(
		Earsw strcatlist "earGo " :: (itoa i) :: " to " :: (itoa p) :: " dir " :: (itoa d) :: nil;
		set e.targetE=earCheck p; 
		set e.targetLoopE=earLoopCount p 0; 
		Earsw strcatlist "targetE=" :: (itoa e.targetE) :: " targetLoopE=" :: (itoa e.targetLoopE) :: nil;
		if e.posE==e.targetE then
			if e.targetLoopE==0 then
			earMotorset e 0 // on est arriv√©s
			else
			(
				if dir>0 then set e.targetLoopE = e.targetLoopE - 1
				else set e.targetLoopE = e.targetLoopE + 1;
				earMotorset e dir
			)
		else (
		if e.targetLoopE<0 then set e.targetLoopE=e.targetLoopE+1; // sinon fait un tour de trop
		earMotorset e dir //v16 add end
		)
	);
	0;;

fun earsGoToRefPos=
	Earsw "earsGoToRefPos";
	if (extleft != nil || extright != nil) then (
		earGo 0 extleft 0;
		earGo 1 extright 0;
		set extleft = set extright = nil
	) else (
		earGo 0 0 0;
		earGo 1 0 0
	);;
// end of file ears.mtl //
// back to file STDIN, line 2984

// file info.mtl //
// gestion des services

// infodata : les definitions des animations visuelles des services (meteo, traffic, etc..)
// Liste de tuples. Un tuple = [<type de service> <animations>]
// animations = tableau de N animations, une par valeur du service. Animation = tuple = [tempo <couleurs>]
// couleurs = X fois 3 couleurs pour les 3 leds du ventre (led 1, 2, 3)
// couleur = index dans le tableau 'infoPalette'
// tempo = 0.5*log2 du nombre d'it√©rations √† durer sur la couleur courante (ex : tempo = 3, dur√©e = 16 it√©rations)
var infodata;;

// infosrc : les services courants affich√©s par ce lapin (envoy√© par le serveur et mis √† jour par le fonction 'infoUpdate')
// Un tableau de 16 valeurs, pour les services courants. 2 valeurs par service donc 8 services max.
// 2 valeurs par service : la premi√®re valeur vaut 1+infoType (ex : 1 pour meteo), la deuxi√®me vaut infoVal, la valeur du service (ex : 0 pour soleil)
var infosrc;;

// nombre de messages utilisateur en attente (0, 1, 2 et +)
var infomessages=0;;

// valeur de frequence du taichi (40: peu fr√©quent, 80: normal, 255: tr√®s fr√©quent)
var infotaichi=0;;

fun infoInit=
	set infosrc=tabnew 0 16;
	set infomessages=0;
	set infotaichi = 0;
	
	set infodata=
[0 // meteo
{
	[25 {3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0}] // soleil
	[125 {0 3 0 4 0 4}] // nuages
	[25 {4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0}] // brouillard
	[20 {0 0 0 0 4 0 4 0 4 0 0 0 0 0 4 4 0 0 0 0 0 0 4 0 0 0 4}] // pluie
	[40 {4 0 0 0 0 0 0 0 4 0 0 0 0 4 0 0 0 0 0 0 4 0 0 0 0 4 0 0 0 0 4 0 0 0 0 0}] // neige
	[25 {0 4 3 0 0 0 0 0 0 0 0 0 0 0 0 4 3 0 0 4 3 0 0 0 0 0 0 0 3 4 3 4 0}] // orage
}
]::
[1 // bourse
{
	[7 {0 0 11 0 11 0 11 0 0 0 0 0 0 0 0 0 0 0}]
	[14 {0 0 11 0 11 0 11 0 0 0 0 0}]
	[28 {0 0 11 0 11 0 11 0 0 0 0 0}]
	[28 {0 11 0 0 0 0}]
	[28 {11 0 0 0 11 0 0 0 11 0 0 0}]
	[14 {11 0 0 0 11 0 0 0 11 0 0 0}]
	[7 {11 0 0 0 11 0 0 0 11 0 0 0 0 0 0 0 0 0}]
}
]::
[2 // traffic
{
	[100 {1 0 1 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0}]
	[100 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[50 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[25 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[12 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[8 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[4 {0 1 0 1 0 1 0 1 0 1 0 1 0 0 0 0 0 0}]
}
]::
[5 // mails
{
	[70 {5 0 0 0 5 0 0 0 5 0 5 0}]
	[56 {0 5 0 0 0 0}]
	[56 {5 0 5 0 0 0}]
	[56 {5 5 5 0 0 0}]
}
]::
[6 // pollution
{
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
	[14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
	[14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
	[14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
	[14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
	[14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
}
]::
nil;;

// v21 : chang√© couleur jaune clair (11) de 0xffff80 √† 0xffcc00 (bug 197)
const infoPalette={
//  noir     rouge    vert     jaune    bleu     violet   cyan     blanc
	0x000000 0xff0000 0x00ff00 0xffff00 0x0000ff 0xff00ff 0x00ffff 0xffffff
//  gris     rose     G clair  J clair  B clair  V clair  C clair  orange
	0x808080 0xff8080 0x80ff80 0xffcc00 0x8080ff 0xff80ff 0x80ffff 0xff8000
};;


// heure de d√©marrage du service courant
var infoStartTime;;
// index du service courant (dans infosrc)
var infoIndex=0;;
// type du service courant
var infoType;;
// valeur du service courant
var infoVal;;
// index de la couleur dans le tableau des couleurs de l'animation courante
var infoAnimColori;;
// Date de d√©marrage de la couleur..
var infoAnimColorStart;;
// dur√©e de la couleur...
var infoAnimColorDur;;

// dur√©e d'affichage d'un service, en secondes
const INFO_TIMEOUT=15;;

fun infoAnimationsOf typ=listswitch infodata typ;;

// retourne le prochain index utile (infoType non nul)
fun _infoNextIndex i=
	let i+2-> i in
	if i>=16 then 0 else if infosrc.i then i else _infoNextIndex i;;

// le service suivant
fun infoStartOne i=
	set infoIndex= i;
	set infoType=(infosrc.(infoIndex))-1;
	set infoVal=infosrc.(infoIndex+1);
	set infoStartTime=time;
	set infoAnimColori=0;
	set infoAnimColorStart=time_ms;
	let infoAnimationsOf infoType -> anims in
	if anims==nil then set infoStartTime=nil
	else let anims.infoVal ->[dur _] in set infoAnimColorDur= dur*10;
	0;;

fun infoNext=
	infoStartOne (_infoNextIndex infoIndex);
	0;;

fun _dumpinfosrc i=
	if (i < 16) then (
		let infosrc.i -> key in
		let infosrc.(i+1) -> val in
		if key == 1 then ( Secho "Meteo="; Iecho val; Secho ",")
		else if key == 2 then ( Secho "Bourse="; Iecho val; Secho ",")
		else if key == 3 then ( Secho "Traffic="; Iecho val; Secho ",")
		else if key == 6 then ( Secho "Mails="; Iecho val; Secho ",")
		else if key == 7 then ( Secho "Pollution="; Iecho val; Secho ",");
		_dumpinfosrc i+2
	);;
fun dumpinfo=
	Secho "infos=[";
	_dumpinfosrc 0;
	Secho "Messages#="; Iecho infomessages; Secho ",";
	Secho "TaiChi="; Iecho infotaichi; Secho ",";
	Secho "EarL="; Iecho extleft; Secho ",";
	Secho "EarR="; Iecho extright; Secho "]"
	;;

fun infoRun=
	if gSleepState == 0 then // no info while sleeping
	if (!gItState) then // no info while in interactive mode
	if !earDetecting then
	(
		// passage au service suivant ?
		set infoType=(infosrc.(infoIndex))-1;
		if infoStartTime==nil || (time-infoStartTime>INFO_TIMEOUT) || infoType<0 then infoNext;

		// Allumage de la t√™te en violet si message(s) en attente (infomessages)
		let (time_ms>>8)&7 -> t in
			led LED_NOSE if (((infomessages>1) && ((t==1)||(t==3))) || ((infomessages==1) && (t==1))) then RGB_VIOLET else RGB_BLACK;

		// couleurs des 3 leds du ventre (service courant/animation courante/couleur courante)
		set infoType=(infosrc.(infoIndex))-1;
		set infoVal=infosrc.(infoIndex+1);
		let infoAnimationsOf infoType -> anims in
		let anims.infoVal ->[dur anime] in
		if anime!=nil then
		(
			led LED_BODY_LEFT infoPalette.(anime.infoAnimColori);
			led LED_BODY_MIDDLE infoPalette.(anime.(1+infoAnimColori));
			led LED_BODY_RIGHT infoPalette.(anime.(2+infoAnimColori));
			if (time_ms-infoAnimColorStart >= infoAnimColorDur) then
			(
				// next colors
				set infoAnimColori=infoAnimColori+3;
				set infoAnimColorStart=time_ms;
				set infoAnimColorDur= dur*10;
				if infoAnimColori>=tablen anime then set infoAnimColori=0
			)
		)
		else
		(
			led LED_BODY_LEFT RGB_BLACK; led LED_BODY_MIDDLE RGB_BLACK; led LED_BODY_RIGHT RGB_BLACK
		)
	);;
		
// met √† jour ou rajoute cette source
fun __infosrc_update key val i=
	if (i < 16) then
	if (infosrc.i == 0 || infosrc.i == key) then (
		// add or update
		set infosrc.(i+1) = val;
		if (infosrc.i == 0) then (
			// add
			set infosrc.i = key;
			// set lapin to play this new one now
			infoStartOne i
		)
	) else __infosrc_update key val i+2;; // recurse
fun _infosrc_update key val=
	// debug : hack special pour envoyer des commandes cach√©es au lapin... [as]
	if ((key == 1) && (val == 6)) then ( // meteo 6 (n'existe pas)
		// force reconnecte
		Secholn "Forced XmppSessionStart!";
		// XmppSessionStop; DEBUT
		//XmppSessionStart gXmpps_cur.sDomain #Xmpps_statusChangedCb; DEBUG
		0
	);
	__infosrc_update key val 0;;

// util : slide tableau pour effacer case vide
fun __infoslide i=
	if (i == 16-2) then (
		set infosrc.i = 0;
		set infosrc.(i+1) = 0
	) else (
		set infosrc.i = infosrc.(i+2);
		set infosrc.(i+1) = infosrc.(i+3);
		// recurse
		if (infosrc.i > 0) then __infoslide i+2
	);;

// enl√®ve cette source de la liste
fun __infosrc_del key i=
	if (i < 16) then
	if (infosrc.i == key) then (
		// delete
		__infoslide i
	) else __infosrc_del key i+2;;
fun _infosrc_del key=
	__infosrc_del key 0;;

proto controlsound 1;;

const midi_communion=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$9b\$00\$ff\$03\$0b\$63\$6f\$6d\$6d\$75\$6e\
\$69\$6f\$6e\$30\$30\$00\$ff\$51\$03\$10\$59\$43\$00\$ff\$58\$04\
\$04\$02\$18\$08\$00\$c0\$0c\$02\$90\$60\$67\$04\$48\$6a\$7b\$5f\
\$4d\$12\$80\$60\$65\$2a\$90\$5d\$51\$0b\$80\$5f\$76\$18\$48\$2b\
\$10\$5d\$7f\$07\$90\$60\$64\$08\$4f\$5e\$7c\$5f\$52\$15\$80\$60\
\$71\$19\$90\$5d\$56\$1a\$80\$5f\$6c\$15\$5d\$7f\$0e\$90\$58\$56\
\$0c\$80\$4f\$7c\$14\$90\$4d\$5e\$6e\$80\$58\$73\$01\$90\$5d\$62\
\$75\$80\$5d\$7a\$0d\$4d\$67\$05\$90\$5b\$5a\$05\$54\$60\$2a\$80\
\$5b\$65\$81\$1e\$54\$60\$51\$90\$58\$60\$15\$4c\$6a\$81\$1e\$80\
\$58\$63\$0e\$4c\$45\$4d\$90\$24\$01\$72\$80\$24\$40\$00\$ff\$2f\
\$00";;

fun newInfoUpdate data=
	Secho "newInfoUpdate:";
	let 0 -> i in
	let nil -> newleft in
	let nil -> newright in (
		while (i < strlen data) do (
			let strget data i -> key in
			let strget data i+1 -> val in (
				Secho "key:"; Iecho key; Secho "="; Iecho val; Secho ",";
				if key == 8 then set infomessages = val
				else if key == 0 then _infosrc_del val
				else if key == 1 || key == 2 || key == 3 || key == 6 || key == 7 then _infosrc_update key val
				else if key == 4 then set newleft = val
				else if key == 5 then set newright = val
				else if key == 14 then set infotaichi = val
				else (
					Secho "ERROR newInfoUpdate unknown key="; Iecholn key;0
				)
			);
			set i = i + 2
		);
		// process ears
		Secho "newleft="; Iecho newleft; Secho "newright="; Iecho newright; Secho "extleft="; Iecho extleft; Secho "extright="; Iecho extright;
		Secho "gSleepState="; Iecho gSleepState; Secho "earResetting="; Iecho earResetting;  
		if (newleft != nil || newright != nil) && ((newleft!=extleft) || (newright!=extright)) then (
			set extleft=newleft;
			set extright=newright;
			if ((!gSleepState) && (!earResetting)) then (
				controlsound midi_communion;
				earsGoToRefPos
			)
		)
	);
	dumpinfo
	;;
// end of file info.mtl //
// back to file STDIN, line 2988

// ancien format
fun infoUpdate data=
	Secho "infoUpdate OLD FORMAT:";
	let strlen data -> len in (
		// /14/80/0/0/0/0/0/0/0/0/0/0/0/0/0/0/14/13/0/
		Secho "len="; Iecho len; Secho ":";
		for i=0;i<len do (Iecho strget data i; Secho "/");
		
		// sources
		for i=0;i<(min 16 len) do set infosrc.i=strget data i;
		
		// messages
		set infomessages = 0;
		if (len > 16+3) && (strget data (16+3)) then set infomessages = 2
		else if (len > 16+2) && (strget data (16+2)) then set infomessages = 1;
		
		// taichi
		let 0 -> found in
		for i=0;(i<(min 16 len) && !found);i+2 do
		if ((strget data i) == 14) then (
			set infotaichi = strget data i+1;
			set found = 1
		);
		
		// process ears
		if len > 17 then
		let strget data 16 -> newleft in
		let strget data 17 -> newright in
		if (newleft != nil || newright != nil) && ((newleft!=extleft) || (newright!=extright)) then (
			set extleft=newleft;
			set extright=newright;
			if ((!gSleepState) && (!earResetting)) then (
				controlsound midi_communion;
				earsGoToRefPos
			)
		)

	);
	dumpinfo;
	
	0;;


//-------------------



// file wifi.mtl //
var wifi;;
var wifiscans;;

type Wifi=initW | gomasterW | masterW | gostationW _ | dhcpW _| stationW | reconnectW;;


const RT2501_S_BROKEN=0;;
const RT2501_S_IDLE=1;;
const RT2501_S_SCAN=2;;
const RT2501_S_CONNECTING=3;;
const RT2501_S_CONNECTED=4;;
const RT2501_S_MASTER=5;;

const IEEE80211_M_MANAGED=0;;
const IEEE80211_M_MASTER=1;;

var wifitry;;
var master=0;;

// file utils.mtl already included
// file net_vars.mtl already included
// file dhcp_protos.mtl already included
// file udp_protos.mtl already included
// file dns_protos.mtl already included
// file net_protos.mtl already included
// file env_protos.mtl //
// proto envmake 0 ;;
proto envrestore 1 ;;
// end of file env_protos.mtl //
// back to file wifi.mtl, line 26
// file leds_protos.mtl already included
// file config_protos.mtl already included

fun _scanserialize l=
	if l!=nil then
	let hd l->[ssid mac bssid rssi channel rateset encryption] in
	ssid::"\0"::mac::bssid::(itoh4 rssi)::(itoh4 channel)::(itoh4 rateset)::(itoh4 encryption)::
	_scanserialize tl l;;

fun scanserialize l=
	(itoh4 listlen l)::_scanserialize l;;

fun dumpscan l0=
	Secholn "## DUMPSCAN >>>>";
	for l=l0;l!=nil;tl l do
	let hd l->[ssid mac bssid rssi channel rateset encryption] in
	(
		Secho "## SCAN "; Secholn ssid;
		Secho "mac:"; MACecho mac 0 1;
		Secho "bssid:"; MACecho bssid 0 1;
		Secho "rssi:"; Iecholn rssi;
		Secho "channel:"; Iecholn channel;
		Secho "rateset:"; Iecholn rateset;
		Secho "encryption:"; Iecholn encryption
	);
	l0;;

fun ssidlen s i=
	if i>=strlen s then i
	else if !strget s i then i
	else ssidlen s i+1;;

fun scanunserialize s n i0=
	if n>0 then
	let ssidlen s i0 -> j in
	let j+1->i in
	[
		strsub s i0 j-i0
		strsub s i 6
		strsub s i+6 6
		htoi strsub s i+12 8
		htoi strsub s i+20 8
		htoi strsub s i+28 8
		htoi strsub s i+36 8
	]::scanunserialize s n-1 i+44;;


const IEEE80211_CRYPT_NONE=0;;
const IEEE80211_CRYPT_WEP64=1;;
const IEEE80211_CRYPT_WEP128=2;;
const IEEE80211_CRYPT_WPA=3;;
const IEEE80211_CRYPT_WPA_UNSUPPORTED=4;;

const IEEE80211_AUTH_OPEN=0;;
const IEEE80211_AUTH_SHARED=1;;

fun scancmpssid a b=
	let a->[sa _ _ _ _ _ _] in
	let b->[sb _ _ _ _ _ _] in
	strcmp sa sb;;

fun wifiInit rescan=
	set wifitry=nil;
	let envget -> env in
	if env==nil then
	(
		setleds RGB_VIOLET;
		set wifi=initW;
		if rescan then set wifiscans=nil;
		if master then
		(
			set netip=netip_master;
			set netmask=netmask_master;
			set netgateway=netgateway_master;
			0
		)
		else
		(
			if confGetDhcp then	set netip=netip_empty
			else
			(
				set netmask=confGetNetmask;
				set netgateway=confGetNetgateway;
				addnewdns confGetNetdns 1;
				set netip=confGetNetip
			);
			0
		);
		0
	)
	else
	(
		setleds RGB_GREEN;
		set mymac=netMac;
		set wifi=stationW;
		envrestore env;
		envset nil;
		nil
	);
	0;;

var laststate;;

fun wifibyssid x v=let x->[s _ _ _ _ _ _] in (s!=nil)&& !strcmp v s;;


var retrytime;;

fun _wifiwepkey val i len=
	if i<len then
	(htoi strsub val i 2)::_wifiwepkey val i+2 len;;

fun wifiwepkey val=
	let strlen val -> len in
	if len==5 || len==13 then val
	else let strreplace val ":" "" -> val in
	let if len<10 then 0 else if len<26 then 5 else 13 -> len in
	listtostr _wifiwepkey val 0 len<<1;;

fun wificrypttype crypt key=
	if crypt==1 then if 5==strlen key then IEEE80211_CRYPT_WEP64 else IEEE80211_CRYPT_WEP128
	else if crypt==2 then IEEE80211_CRYPT_WPA
	else IEEE80211_CRYPT_NONE;;

fun wifiAuth=
	setleds RGB_AMBER;
	if wifiscans==nil then 0
	else
		let Iecholn confGetWificrypt -> crypt in
		let confGetWifiauth -> auth in
		let if crypt==1 then wifiwepkey confGetWifikey0
			else if crypt==2 then confGetWifipmk -> key in
		(
			dump key;
			set wifitry=time;
			netAuth hd wifiscans Iecholn auth (Iecholn wificrypttype crypt key) key;	//## ajouter les param√®tres de crypto
			1
		);;

fun wifiRun=
	let netState -> state in
	(
		if state!=laststate then (Secho "wifi state=";Iecholn state);
		let match wifi with
		(stationW -> nil)
		|(initW -> if state==RT2501_S_IDLE then
				(
					set mymac=MACecho netMac 0 1;
					setleds RGB_AMBER;
					if master then
					(
						dumpscan set wifiscans=sort netScan nil #scancmpssid;
						netSetmode IEEE80211_M_MASTER (strcat "Nabaztag" ctoh strget mymac 5) 1;
						Secholn "-------------gomaster";
						gomasterW
					)
					else
					(
						if wifiscans==nil then
						(
							let confGetWifissid -> ssid in
							let if strlen ssid then ssid else nil -> ssid in
							let netScan ssid -> lscan in
							let sort lscan #scancmpssid -> l in
							let if ssid==nil then l else select l ssid #wifibyssid-> l in
							dumpscan set wifiscans=l
						);
						if wifiAuth then
						(
							Secho confGetWifissid; Secholn ":-------------gostation";
							gostationW [0 time]
						)
					)
				)
			)
		|(gomasterW -> if state==RT2501_S_MASTER then
				(
					setleds RGB_BLUE;
					Secholn "-------------master";
					startdhcpserver;
//					startconfigserver 80;
					masterW)
			)
		|(masterW -> if !master then
					(
						wifiInit 1;
						resetudp;
						netSetmode IEEE80211_M_MANAGED nil 11;
						nil)
			)
		|(gostationW x-> if state==RT2501_S_CONNECTED then
				(
					Secholn "-------------dhcp";
					if confGetDhcp then startdhcp;
					startdnsclient;
					dhcpW time
				)
			)
		|(dhcpW t-> if netip!=netip_empty then
				(
					Secholn "-------------station";
					stationW
				)
				else if (time-t)>3 then	// retry dhcp client
				(
					startdhcp;
					dhcpW time
				)
			)
		|(reconnectW ->
			netSetmode IEEE80211_M_MANAGED nil 11;
			if wifiAuth then
			(
				Secho confGetWifissid; Secholn ":-------------gostation";
				gostationW [0 time]
			)
		 )
		-> nwifi in
		if nwifi!=nil then set wifi=nwifi;
		set laststate=state
	);
	if retrytime!=time then
	(
		set retrytime=time;
		nettime;
		dnstime;
		0
	)
	;;

fun wifiReady= match wifi with (stationW -> 1)|(_ -> 0);;

fun wifiConnected= match wifi with (stationW -> 1)|(_ -> 0);;

// file dhcp.mtl already included
// file udp.mtl already included
// file dns.mtl already included
// file net.mtl already included
// file env.mtl //

// unused
/*
fun envmake =
	strcatlist netip::netmask::netgateway::netdns::scanserialize wifiscans;;
*/

fun envrestore s =
	if s!=nil then
	(
		set netip=strsub s 0 4;
		set netmask=strsub s 4 4;
		set netgateway=strsub s 8 4;
		set netdnslist=nil; addnewdns (strsub s 12 4) 0;
		let htoi strsub s 16 8 -> nscan in
		set wifiscans=scanunserialize s nscan 24;
		0
	);;
// end of file env.mtl //
// back to file wifi.mtl, line 265
// file leds.mtl already included
// file config.mtl already included
// end of file wifi.mtl //
// back to file STDIN, line 3038
// file env.mtl already included


const tab_osc={
	0 0 0 0 0 0 1 1 2 3 3 4 5 6 7 8 
	9 10 12 13 15 16 18 19 21 23 25 27 29 31 33 35 
	37 39 42 44 46 49 51 54 56 59 62 64 67 70 73 76 
	79 81 84 87 90 93 96 99 103 106 109 112 115 118 121 124
};;


fun osc x=
	let (x>>6)&3 -> q in
	let x&255 -> x in
	if q==0 then tab_osc.x
	else if q==1 then 255-tab_osc.(127-x)
	else if q==2 then 255-tab_osc.(x-128)
	else tab_osc.(255-x);;


var pingsrv;;
var broadcasturl;;
var recorddelay=4;;

var sources;;

var gCurrentProgram;; // the list of commands of the current program
var rsctoget;; // list of remaining resources to get for the execution of the current trame
var rscloaded;; // list of resources loaded from current trame
var rsctmp;;	// buffer de chargement des ressources en petits morceaux

// settings, command="IC", managed in eval_IC_msg
var g_streaming_chor_enabled=1;;
var g_cookie="";;
const MASK_BUTTON = 1;;
const MASK_EAR_LEFT = 2;;
const MASK_EAR_RIGHT = 4;;
const MASK_RFID = 8;;
var g_int_mask=0;;
var g_snd_btn_1 = "clonk";;
var g_snd_btn_2 = "chord";;
var g_record_enabled = 1;;
proto reset_IC 0;;

proto _interactiveReqCBhttp 2;;
proto interactivePrgmDone 0;;
proto interactiveSendUpload 0;;
proto interactiveStop 0;;
proto interactiveError 0;;
proto interactiveResetEarsTouched 0;;

var gCurAudioCmdIndex=-1;;
var gCurStreamName=nil;;

const BROADCAST_KEYWORD="broadcast";;
const SIGNCUTSIZE=40000;; // taille max du fichier audio de signature

const MSG_IDLE=0x7fffffff;;
const MSG_ASLEEP=0x7ffffffe;;

const STREAMING_PING=60;;
const STD_NET_TIMEOUT=10000;;

const LED_TIMEOUT=600;; // 10 minutes
const CH_frame_duration=1;;
//var CH_set_color=6;;
const CH_set_led_color=7;;
const CH_set_motor=8;;
const CH_set_leds_color=9;; // v16
const CH_set_led_off=10;; // v17
const CH_set_led_palette=14;;
//var CH_set_palette=15;;
const CH_randmidi=16;;
const CH_avance=17;;
const CH_ifne=18;;
const CH_attend=19;;
const CH_setmotordir=20;; // v16


// file palette.mtl //
// ************************
// Palettes
// ************************

var current_palette = {0 0 0 0 0 0 0 0};;
var current_palette_is_random = 1;; // random par d√©faut (pour pallier au fait que les podcasts ne pr√©cisent pas de palette)

// 7 palettes
// de 7 couleurs chacune plus une.
// La 8eme couleur est utilisee dans les choregraphies pour eteindre toutes les lumieres.
const all_palettes=
{
	{255 12 0 0 255 31 255 242 0 0 3 255 255 242 0 0 255 31 255 12 0 0 0 0} // acidul√©e
	{95 0 255 127 0 255 146 0 255 191 0 255 223 0 255 255 0 223 255 0 146 0 0 0} // violet
	{255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0} // lumiere
	{254 128 2 243 68 2 216 6 7 200 4 13 170 0 24 218 5 96 207 6 138 0 0 0} // emotion
	{20 155 18 255 0 0 252 243 5 20 155 18 252 243 5 255 0 0 20 155 18 0 0 0} // oriental
	{252 238 71 206 59 69 85 68 212 78 167 82 243 75 153 151 71 196 255 255 255 0 0 0} // pastel
	{204 255 102 204 255 0 153 255 0 51 204 0 0 153 51 0 136 0 0 102 51 0 0 0} // nature
	{0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} //
};;

// change vraiment la palette
fun set_current_palette p=
	Secho "set_current_palette ";Iecholn p&7;
	let all_palettes.(p&7) -> p in
	for i=0;i<8 do let i*3 -> j in set current_palette.i=((p.(j))<<16)+((p.(j+1))<<8)+p.(j+2);;

// is mode >= 8 : palette aleatoire. Sinon fix√©e √† m
fun set_current_palette_mode m=
	if (m >= 8) then
	(
		set current_palette_is_random = 1;
		set_current_palette 0
	)
	else
	(
		set current_palette_is_random = 0;
		set_current_palette m
	);;

fun set_current_palette_color i val=
	Secho "set_current_palette_color ";Iecho i; Secho " = $";Secholn itoh val;
	set current_palette.i=val;;

// end of file palette.mtl //
// back to file STDIN, line 3119
// file const_data.mtl //

const midi_acquired=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$71\$00\$ff\$03\$07\$63\$6f\$6d\$70\$72\$69\
\$73\$00\$ff\$51\$03\$07\$a1\$20\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$c0\$0c\$7a\$90\$34\$50\$6f\$53\$1a\$08\$80\$34\$40\$81\$02\
\$53\$40\$15\$90\$64\$27\$81\$02\$54\$37\$08\$80\$64\$40\$81\$02\
\$54\$40\$15\$90\$34\$50\$81\$02\$53\$2b\$07\$80\$34\$40\$81\$02\
\$53\$40\$16\$90\$43\$3f\$81\$02\$64\$60\$07\$80\$43\$40\$81\$02\
\$64\$40\$15\$90\$54\$5c\$55\$80\$54\$40\$83\$39\$90\$25\$01\$74\
\$80\$25\$40\$00\$ff\$2f\$00";;

const midi_ministop=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$5a\$00\$ff\$03\$05\$73\$74\$6f\$70\$30\$00\
\$ff\$51\$03\$07\$a1\$20\$00\$ff\$58\$04\$04\$02\$18\$08\$00\$c9\
\$00\$00\$c4\$09\$03\$99\$2a\$7f\$00\$2c\$7f\$00\$56\$7f\$00\$94\
\$24\$7f\$00\$28\$64\$00\$2d\$64\$01\$99\$3c\$64\$0a\$84\$24\$40\
\$01\$28\$40\$01\$2d\$40\$0b\$89\$2a\$40\$00\$56\$40\$01\$2c\$40\
\$00\$3c\$40\$81\$52\$99\$2c\$01\$1a\$89\$2c\$40\$00\$ff\$2f\$00";;

const midi_abort=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$5e\$00\$ff\$03\$07\$53\$74\$6f\$70\$4e\$45\
\$57\$00\$ff\$51\$03\$07\$a1\$20\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$c9\$00\$00\$09\$03\$99\$2e\$7f\$00\$23\$7f\$00\$28\$64\$00\
\$2c\$7f\$00\$2d\$64\$00\$3a\$64\$00\$26\$7f\$00\$32\$7f\$07\$89\
\$23\$40\$00\$26\$40\$01\$28\$40\$01\$2d\$40\$0b\$2e\$40\$00\$3a\
\$40\$00\$32\$40\$01\$2c\$40\$83\$2d\$99\$25\$01\$16\$89\$25\$40\
\$00\$ff\$2f\$00";;

var midi_ears=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$9b\$00\$ff\$03\$0b\$63\$6f\$6d\$6d\$75\$6e\
\$69\$6f\$6e\$30\$30\$00\$ff\$51\$03\$10\$59\$43\$00\$ff\$58\$04\
\$04\$02\$18\$08\$00\$c0\$0c\$02\$90\$60\$67\$04\$48\$6a\$7b\$5f\
\$4d\$12\$80\$60\$65\$2a\$90\$5d\$51\$0b\$80\$5f\$76\$18\$48\$2b\
\$10\$5d\$7f\$07\$90\$60\$64\$08\$4f\$5e\$7c\$5f\$52\$15\$80\$60\
\$71\$19\$90\$5d\$56\$1a\$80\$5f\$6c\$15\$5d\$7f\$0e\$90\$58\$56\
\$0c\$80\$4f\$7c\$14\$90\$4d\$5e\$6e\$80\$58\$73\$01\$90\$5d\$62\
\$75\$80\$5d\$7a\$0d\$4d\$67\$05\$90\$5b\$5a\$05\$54\$60\$2a\$80\
\$5b\$65\$81\$1e\$54\$60\$51\$90\$58\$60\$15\$4c\$6a\$81\$1e\$80\
\$58\$63\$0e\$4c\$45\$4d\$90\$24\$01\$72\$80\$24\$40\$00\$ff\$2f\
\$00";;

const midi_ack=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$55\$00\$ff\$03\$07\$65\$66\$66\$61\$63\$65\
\$30\$00\$ff\$51\$03\$10\$59\$43\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$90\$3c\$7f\$00\$41\$7f\$00\$48\$7f\$00\$4f\$7f\$00\$54\$7f\
\$00\$c0\$77\$00\$c1\$74\$84\$54\$80\$4f\$40\$40\$91\$30\$7f\$00\
\$53\$64\$1a\$80\$41\$40\$00\$54\$40\$00\$81\$30\$40\$00\$53\$40\
\$3c\$80\$48\$40\$1e\$3c\$40\$00\$ff\$2f\$00";;

const midi_startInteractive=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$8e\$00\$ff\$03\$0d\$69\$6e\$74\$65\$72\$61\
\$63\$74\$69\$66\$49\$4e\$32\$00\$ff\$51\$03\$07\$a1\$20\$00\$ff\
\$58\$04\$04\$02\$18\$08\$00\$c0\$49\$1e\$90\$54\$7f\$34\$80\$54\
\$40\$08\$90\$56\$7f\$34\$80\$56\$40\$08\$90\$58\$7f\$34\$80\$58\
\$40\$82\$34\$90\$5b\$7f\$16\$80\$5b\$40\$81\$5a\$90\$5d\$7f\$16\
\$80\$5d\$40\$81\$5a\$90\$5f\$7f\$34\$80\$5f\$40\$81\$1e\$90\$59\
\$7f\$16\$80\$59\$40\$81\$78\$90\$60\$7f\$34\$80\$60\$40\$87\$0c\
\$90\$5f\$7f\$52\$80\$5f\$40\$08\$90\$5d\$7f\$34\$80\$5d\$40\$08\
\$90\$64\$7f\$16\$80\$64\$40\$84\$7e\$90\$24\$01\$10\$80\$24\$40\
\$00\$ff\$2f\$00";;

const midi_endInteractive=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$93\$00\$ff\$03\$0e\$69\$6e\$74\$65\$72\$61\
\$63\$74\$69\$66\$4f\$55\$54\$32\$00\$ff\$51\$03\$07\$a1\$20\$00\
\$ff\$58\$04\$04\$02\$18\$08\$00\$c0\$49\$1e\$90\$60\$7f\$14\$80\
\$60\$40\$28\$90\$5d\$7f\$32\$80\$5d\$40\$28\$90\$5f\$7f\$50\$80\
\$5f\$40\$82\$72\$90\$60\$7f\$52\$80\$60\$40\$81\$1e\$90\$59\$7f\
\$34\$80\$59\$40\$81\$3c\$90\$5f\$7f\$32\$80\$5f\$40\$81\$3e\$90\
\$5d\$7f\$1a\$80\$5d\$40\$81\$56\$90\$5b\$7f\$81\$2c\$80\$5b\$40\
\$85\$1c\$90\$58\$7f\$32\$80\$58\$40\$0a\$90\$56\$7f\$32\$80\$56\
\$40\$0a\$90\$54\$7f\$1e\$c0\$49\$52\$80\$54\$40\$84\$42\$90\$24\
\$01\$0e\$80\$24\$40\$00\$ff\$2f\$00";;

const midi_precedent=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$59\$00\$ff\$03\$0a\$70\$72\$65\$63\$65\$64\
\$65\$6e\$74\$31\$00\$ff\$51\$03\$10\$59\$44\$00\$ff\$58\$04\$04\
\$02\$18\$08\$00\$e0\$00\$00\$00\$b0\$00\$51\$00\$90\$1d\$4b\$00\
\$b0\$20\$03\$00\$90\$30\$4b\$00\$c0\$78\$3c\$90\$34\$7f\$00\$e0\
\$4a\$56\$3c\$33\$69\$3c\$7f\$7f\$18\$80\$34\$40\$24\$e0\$7f\$7f\
\$36\$80\$1d\$40\$00\$30\$40\$06\$e0\$1d\$7c\$00\$ff\$2f\$00";;

const midi_suivant=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$45\$00\$ff\$03\$09\$73\$75\$69\$76\$61\$6e\
\$74\$35\$36\$00\$ff\$51\$03\$10\$59\$44\$00\$ff\$58\$04\$04\$02\
\$18\$08\$00\$c0\$78\$01\$90\$3c\$64\$1d\$41\$64\$1e\$47\$64\$1e\
\$4a\$64\$18\$80\$41\$40\$00\$47\$40\$00\$4a\$40\$01\$3c\$40\$05\
\$90\$54\$64\$18\$80\$54\$40\$00\$ff\$2f\$00";;


// Choregraphies definitions

const chordef_interactiveerror=
"\$01\$01\$01\$01\$00\$01\$0e\$00\$09\$ff\$00\$00\$02\$09\$00\$00\
\$00\$02\$09\$ff\$00\$00\$02\$09\$00\$00\$00\$02\$09\$ff\$00\$00\
\$02\$09\$00\$00\$00";;

const chordef_startInteractive=
"\$01\$01\$01\$01\$00\$01\$0e\$00\$07\$04\$ff\$00\$00\$00\$00\$00\
\$07\$01\$00\$ee\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$ff\$00\$00\$00\
\$07\$03\$ff\$00\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$00\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$01\$00\$ee\$00\$00\$00\$00\
\$07\$00\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$ff\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$ff\$ff\$00\$00\$00\$00\
\$07\$01\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$ff\$00\$00\$00\
\$07\$03\$00\$33\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$00\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\$ff\$00\$00\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$ff\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$00\$ee\$00\$00\$00\$00\
\$07\$01\$ff\$00\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$ff\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\$ee\$00\$00\$00\$00\
\$07\$00\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$ff\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$ff\$ff\$00\$00\$00\$00\
\$07\$03\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$ff\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$ff\$ff\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$ff\$ff\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$04\$ff\$ff\$ff\$00\$00\$00\
\$07\$00\$ff\$ff\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\$ff\$ff\$ff\$00\$00\$00\
\$07\$03\$ff\$ff\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$ff\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00";;

const chordef_taichi=
"\$01\$01\$01\$01\$00\$01\$0a\$00\$07\$00\$00\$00\$00\$00\$00\$00\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$00\$00\$00\$00\$01\
\$10\$00\$01\$04\$01\$07\$04\$00\$33\$ff\$00\$00\$00\$07\$02\$ff\
\$00\$00\$00\$00\$00\$07\$00\$ff\$ff\$00\$00\$00\$01\$07\$04\$00\
\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$00\$07\$01\$ff\$ff\$00\$00\$00\$01\$07\$01\$00\
\$00\$00\$00\$00\$00\$07\$04\$ff\$ff\$00\$00\$00\$00\$07\$02\$00\
\$ee\$00\$00\$00\$00\$07\$00\$ff\$00\$00\$00\$00\$01\$07\$04\$00\
\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$00\$07\$03\$00\$ee\$00\$00\$00\$01\$07\$03\$00\
\$00\$00\$00\$00\$00\$07\$04\$ee\$00\$00\$00\$00\$00\$07\$01\$00\
\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\
\$00\$00\$00\$00\$00\$07\$04\$ff\$00\$00\$00\$00\$00\$07\$00\$ff\
\$ff\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\$07\$03\$00\
\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$00\$00\$00\$00\$07\$00\$ff\
\$00\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$01\$07\$03\$ee\$00\$00\$00\$00\$00\$07\$00\$00\
\$ee\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$00\$07\$03\$ff\$00\$00\$00\$00\$00\$07\$02\$00\
\$ee\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$00\
\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\$07\$01\$00\
\$00\$00\$00\$00\$01\$07\$04\$00\$33\$ff\$00\$00\$00\$07\$02\$ff\
\$00\$00\$00\$00\$00\$07\$00\$ff\$ff\$00\$00\$00\$01\$07\$04\$00\
\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$00\$07\$01\$ff\$ff\$00\$00\$00\$01\$07\$01\$00\
\$00\$00\$00\$00\$00\$07\$04\$ff\$ff\$00\$00\$00\$00\$07\$02\$00\
\$ee\$00\$00\$00\$00\$07\$00\$ff\$00\$00\$00\$00\$01\$07\$04\$00\
\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$00\$07\$03\$00\$ee\$00\$00\$00\$01\$07\$03\$00\
\$00\$00\$00\$00\$00\$07\$04\$ee\$00\$00\$00\$00\$00\$07\$01\$00\
\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\
\$00\$00\$00\$00\$00\$07\$04\$ff\$00\$00\$00\$00\$00\$07\$00\$ff\
\$ff\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\$07\$03\$00\
\$00\$00\$00\$00\$00\$07\$02\$ff\$ff\$00\$00\$00\$00\$07\$00\$ff\
\$00\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$01\$07\$03\$ee\$00\$00\$00\$00\$00\$07\$00\$00\
\$ee\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\$00\
\$00\$00\$00\$00\$00\$07\$03\$ff\$00\$00\$00\$00\$00\$07\$02\$00\
\$ee\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$00\
\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\$07\$01\$00\
\$00\$00\$00\$00\$01\$12\$00\$00\$f3\$00\$01\$10\$00\$14\$01\$00\
\$00\$11\$01\$02\$01\$13\$01\$09\$ff\$ff\$00\$00\$14\$00\$00\$00\
\$11\$00\$02\$01\$13\$01\$14\$01\$00\$00\$11\$01\$02\$01\$09\$00\
\$00\$00\$01\$13\$01\$09\$ff\$ff\$00\$00\$14\$00\$00\$00\$11\$00\
\$02\$01\$13\$01\$14\$01\$00\$00\$11\$01\$02\$01\$09\$00\$00\$00\
\$01\$13\$01\$09\$ff\$ff\$00\$00\$14\$00\$00\$00\$11\$00\$02\$01\
\$13\$01\$14\$01\$00\$00\$11\$01\$02\$01\$09\$00\$00\$00\$01\$13\
\$01\$09\$ff\$ff\$00\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\
\$14\$01\$00\$00\$11\$01\$02\$01\$09\$00\$00\$00\$01\$13\$01\$09\
\$ff\$ff\$00\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$14\$01\
\$00\$00\$11\$01\$02\$01\$09\$00\$00\$00\$01\$13\$01\$09\$ff\$ff\
\$00\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$14\$01\$00\$00\
\$11\$01\$02\$01\$09\$00\$00\$00\$01\$13\$01\$09\$ff\$ff\$00\$00\
\$14\$00\$00\$00\$11\$00\$02\$01\$13\$02\$14\$01\$00\$00\$11\$01\
\$03\$01\$09\$00\$00\$00\$01\$13\$01\$09\$ff\$ff\$00\$00\$14\$00\
\$00\$00\$11\$00\$03\$01\$13\$01\$09\$00\$00\$00\$01\$12\$01\$00\
\$f3\$00\$01\$10\$00\$09\$ff\$00\$00\$00\$14\$01\$00\$00\$11\$01\
\$02\$01\$13\$01\$14\$00\$00\$00\$11\$00\$02\$01\$09\$00\$00\$00\
\$01\$13\$01\$09\$ff\$00\$00\$00\$14\$01\$00\$00\$11\$01\$02\$01\
\$13\$01\$14\$00\$00\$00\$11\$00\$02\$01\$09\$00\$00\$00\$01\$13\
\$01\$09\$ff\$00\$00\$00\$14\$01\$00\$00\$11\$01\$02\$01\$13\$01\
\$14\$00\$00\$00\$11\$00\$02\$01\$09\$00\$00\$00\$01\$13\$01\$09\
\$ff\$00\$00\$00\$14\$01\$00\$00\$11\$01\$02\$01\$13\$01\$14\$00\
\$00\$00\$11\$00\$02\$01\$09\$00\$00\$00\$01\$13\$01\$09\$ff\$00\
\$00\$00\$14\$01\$00\$00\$11\$01\$02\$01\$13\$01\$14\$00\$00\$00\
\$11\$00\$02\$01\$09\$00\$00\$00\$01\$13\$01\$09\$ff\$00\$00\$00\
\$14\$01\$00\$00\$11\$01\$02\$01\$13\$01\$14\$00\$00\$00\$11\$00\
\$02\$01\$09\$00\$00\$00\$01\$13\$01\$09\$ff\$00\$00\$00\$14\$01\
\$00\$00\$11\$01\$02\$01\$13\$01\$14\$00\$00\$00\$11\$00\$02\$01\
\$09\$00\$00\$00\$01\$13\$01\$09\$ff\$00\$00\$00\$14\$01\$00\$00\
\$11\$01\$03\$01\$13\$01\$14\$00\$00\$00\$11\$00\$03\$01\$09\$00\
\$00\$00\$01\$13\$01\$12\$02\$00\$da\$00\$01\$08\$00\$09\$ee\$00\
\$00\$00\$14\$01\$01\$00\$11\$01\$04\$00\$14\$00\$01\$00\$11\$00\
\$04\$01\$09\$00\$00\$00\$01\$09\$ee\$00\$00\$01\$09\$00\$00\$00\
\$01\$13\$01\$13\$0a\$09\$ee\$00\$00\$00\$14\$01\$01\$00\$11\$01\
\$04\$00\$14\$00\$01\$00\$11\$00\$04\$01\$09\$00\$00\$00\$01\$09\
\$ee\$00\$00\$01\$09\$00\$00\$00\$01\$13\$01\$13\$0a\$09\$ee\$00\
\$00\$00\$14\$01\$01\$00\$11\$01\$04\$00\$14\$00\$01\$00\$11\$00\
\$04\$01\$09\$00\$00\$00\$01\$09\$ee\$00\$00\$01\$09\$00\$00\$00\
\$01\$13\$01\$13\$0a\$09\$ee\$00\$00\$00\$14\$01\$01\$00\$11\$01\
\$05\$00\$14\$00\$01\$00\$11\$00\$05\$01\$09\$00\$00\$00\$01\$09\
\$ee\$00\$00\$01\$09\$00\$00\$00\$01\$13\$01\$13\$01\$09\$ee\$00\
\$00\$01\$09\$00\$00\$00\$01\$09\$ee\$00\$00\$01\$07\$00\$00\$00\
\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\
\$00\$00\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$00\
\$00\$00\$00\$01\$12\$03\$00\$cb\$00\$01\$08\$00\$14\$01\$00\$00\
\$11\$01\$04\$00\$14\$00\$00\$00\$11\$00\$04\$01\$13\$01\$13\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$00\
\$14\$01\$01\$00\$11\$01\$04\$00\$14\$00\$01\$00\$11\$00\$04\$01\
\$13\$01\$13\$01\$12\$04\$01\$8f\$00\$01\$14\$00\$07\$02\$00\$ee\
\$00\$00\$00\$00\$14\$01\$01\$00\$11\$01\$06\$00\$14\$00\$00\$00\
\$11\$00\$06\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$00\
\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$99\$ff\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$00\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$cc\$00\
\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$13\$01\$13\$01\
\$07\$02\$00\$ff\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$00\
\$14\$01\$01\$00\$11\$01\$06\$00\$14\$00\$00\$00\$11\$00\$06\$01\
\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\
\$07\$02\$00\$99\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\
\$07\$02\$ee\$00\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\
\$07\$02\$ff\$00\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\
\$07\$02\$cc\$00\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\
\$07\$02\$00\$ff\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\
\$13\$01\$13\$01\$07\$02\$ff\$cc\$00\$00\$00\$00\$14\$01\$01\$00\
\$11\$01\$05\$00\$14\$00\$00\$00\$11\$00\$05\$01\$07\$02\$00\$00\
\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$02\$00\$00\
\$00\$00\$00\$01\$07\$02\$00\$00\$ff\$00\$00\$01\$07\$02\$00\$00\
\$00\$00\$00\$01\$07\$02\$cc\$00\$ff\$00\$00\$01\$07\$02\$00\$00\
\$00\$00\$00\$01\$07\$02\$00\$ff\$ff\$00\$00\$01\$07\$02\$00\$00\
\$00\$00\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\
\$00\$00\$00\$01\$07\$02\$cc\$00\$ff\$00\$00\$01\$07\$02\$00\$00\
\$00\$00\$00\$01\$13\$01\$13\$01\$07\$02\$00\$ff\$ff\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$12\$05\$00\$cd\$00\$01\$14\$00\
\$07\$02\$ff\$cc\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\$11\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$06\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$06\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$07\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$13\$01\$12\$06\$01\$67\$00\$01\
\$14\$00\$07\$03\$ff\$cc\$00\$00\$00\$00\$14\$01\$01\$00\$11\$01\
\$11\$00\$14\$00\$00\$00\$11\$00\$11\$01\$07\$03\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$01\$ff\$cc\$00\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$03\$ff\$cc\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$01\$ff\$cc\$00\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$03\$ff\$cc\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$01\$ff\$cc\$00\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$03\$ff\$cc\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$01\$ff\$cc\$00\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$03\$ff\$cc\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$01\$ff\$cc\$00\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$01\$07\$02\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$01\$07\$03\$ff\$cc\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$01\$13\$01\$13\$01\$12\$07\$00\$fd\$00\$01\$10\$00\$09\$ff\
\$00\$00\$00\$14\$01\$00\$00\$11\$01\$02\$00\$14\$00\$00\$00\$11\
\$00\$02\$01\$13\$01\$13\$01\$09\$00\$00\$00\$02\$14\$01\$01\$00\
\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\$02\$01\$13\$01\$13\$01\
\$09\$ff\$00\$00\$00\$14\$01\$00\$00\$11\$01\$02\$00\$14\$00\$00\
\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\$00\$00\$00\$02\$14\$01\
\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\$02\$01\$13\$01\
\$13\$01\$09\$ff\$00\$00\$00\$14\$01\$00\$00\$11\$01\$02\$00\$14\
\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\$00\$00\$00\$02\
\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\$02\$01\
\$13\$01\$13\$01\$09\$ff\$00\$00\$00\$14\$01\$00\$00\$11\$01\$02\
\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\$00\$00\
\$00\$02\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\
\$02\$01\$13\$01\$13\$01\$09\$ff\$00\$00\$00\$14\$01\$00\$00\$11\
\$01\$02\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\
\$00\$00\$00\$02\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\
\$11\$00\$02\$01\$13\$01\$13\$01\$12\$08\$00\$fd\$00\$01\$10\$00\
\$09\$ff\$ff\$00\$00\$14\$01\$00\$00\$11\$01\$02\$00\$14\$00\$00\
\$00\$11\$00\$02\$06\$09\$00\$00\$00\$01\$13\$01\$13\$01\$14\$01\
\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\$02\$01\$13\$01\
\$13\$01\$09\$ff\$ff\$00\$00\$14\$01\$00\$00\$11\$01\$02\$00\$14\
\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\$00\$00\$00\$02\
\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\$02\$01\
\$13\$01\$13\$01\$09\$ff\$ff\$00\$00\$14\$01\$00\$00\$11\$01\$02\
\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\$00\$00\
\$00\$02\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\
\$02\$01\$13\$01\$13\$01\$09\$ff\$ff\$00\$00\$14\$01\$00\$00\$11\
\$01\$02\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\
\$00\$00\$00\$02\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\
\$11\$00\$02\$01\$13\$01\$13\$01\$09\$ff\$ff\$00\$00\$14\$01\$00\
\$00\$11\$01\$02\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\
\$01\$09\$00\$00\$00\$02\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\
\$01\$00\$11\$00\$02\$01\$13\$01\$13\$01\$12\$09\$01\$1b\$00\$01\
\$08\$00\$14\$01\$00\$00\$11\$01\$04\$00\$14\$00\$00\$00\$11\$00\
\$04\$01\$13\$01\$13\$02\$07\$03\$00\$ee\$00\$00\$00\$01\$07\$03\
\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$01\$00\$ee\$00\$00\$00\$01\$07\$01\
\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$03\$00\$ee\$00\$00\$00\$01\$07\$03\
\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$01\$00\$ee\$00\$00\$00\$01\$07\$01\
\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$03\$00\$ee\$00\$00\$00\$01\$07\$03\
\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$01\$00\$ee\$00\$00\$00\$01\$07\$01\
\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$03\$00\$ee\$00\$00\$00\$01\$07\$03\
\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$01\$00\$ee\$00\$00\$00\$01\$07\$01\
\$00\$00\$00\$00\$00\$00\$14\$01\$01\$00\$11\$01\$04\$00\$14\$00\
\$01\$00\$11\$00\$04\$01\$13\$01\$13\$01\$12\$0a\$02\$9f\$00\$01\
\$08\$00\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\
\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\$00\$01\$07\$04\
\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\
\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\
\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$07\$04\
\$00\$ee\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$01\$14\$01\
\$00\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\
\$13\$01\$07\$04\$00\$ee\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\
\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\$00\$01\$07\$04\
\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\
\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\
\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$07\$04\
\$00\$ee\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$01\$14\$01\
\$00\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\
\$13\$01\$07\$04\$00\$ee\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\
\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\$00\$01\$07\$04\
\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\
\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\
\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$07\$04\
\$00\$ee\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$01\$14\$01\
\$00\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\
\$13\$01\$07\$04\$00\$ee\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$01\$14\$01\$01\$00\$11\$01\$01\$00\$14\$00\$01\$00\$11\$00\
\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\$00\$01\$07\$04\
\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\
\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\
\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$07\$04\
\$00\$ee\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$01\$14\$01\
\$00\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\
\$13\$01\$07\$04\$00\$ee\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\
\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\$00\$01\$07\$04\
\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\
\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$07\$04\$00\$ee\$00\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$01\$14\$01\$00\$00\$11\$01\
\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\$01\$12\$0b\
\$04\$f5\$00\$01\$14\$00\$07\$04\$00\$33\$ff\$00\$00\$00\$14\$01\
\$01\$00\$11\$01\$11\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\
\$00\$33\$ff\$00\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\
\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\
\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\
\$00\$33\$ff\$00\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\
\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\
\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\
\$00\$33\$ff\$00\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\
\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\
\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\
\$00\$33\$ff\$00\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\
\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\
\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\
\$00\$33\$ff\$00\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\
\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\
\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\
\$00\$33\$ff\$00\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\
\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\
\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\
\$00\$33\$ff\$00\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\
\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\
\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\
\$00\$33\$ff\$00\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\
\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\
\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$00\
\$00\$33\$ff\$00\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\
\$00\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\
\$00\$33\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\
\$00\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$01\$13\$01\
\$14\$00\$00\$00\$11\$00\$11\$01\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\
\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$33\$ff\$00\$00\$01\
\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$33\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$00\$33\$ff\$00\$00\$01\
\$07\$04\$00\$00\$00\$00\$00\$01\$12\$0c\$00\$fd\$00\$01\$10\$00\
\$09\$00\$ee\$00\$00\$14\$01\$00\$00\$11\$01\$02\$00\$14\$00\$00\
\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\$00\$00\$00\$02\$14\$01\
\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\$02\$01\$13\$01\
\$13\$01\$09\$00\$ee\$00\$00\$14\$01\$00\$00\$11\$01\$02\$00\$14\
\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\$00\$00\$00\$02\
\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\$02\$01\
\$13\$01\$13\$01\$09\$00\$ee\$00\$00\$14\$01\$00\$00\$11\$01\$02\
\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\$01\$09\$00\$00\
\$00\$02\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\
\$02\$01\$13\$01\$13\$01\$09\$00\$ee\$00\$00\$14\$01\$00\$00\$11\
\$01\$02\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\$02\$09\
\$00\$00\$00\$02\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$01\$00\
\$11\$00\$02\$01\$13\$01\$13\$01\$09\$00\$ee\$00\$00\$14\$01\$00\
\$00\$11\$01\$02\$00\$14\$00\$00\$00\$11\$00\$02\$01\$13\$01\$13\
\$01\$09\$00\$00\$00\$02\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\
\$01\$00\$11\$00\$02\$01\$13\$01\$13\$01\$12\$0d\$00\$cb\$00\$01\
\$08\$00\$14\$01\$00\$00\$11\$01\$04\$00\$14\$00\$00\$00\$11\$00\
\$04\$01\$13\$01\$13\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\
\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\
\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\
\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\
\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\
\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\
\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\
\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\
\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\
\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\
\$01\$09\$00\$00\$00\$00\$14\$01\$01\$00\$11\$01\$04\$00\$14\$00\
\$01\$00\$11\$00\$04\$01\$13\$01\$13\$01\$12\$0e\$01\$1b\$00\$01\
\$08\$00\$14\$01\$00\$00\$11\$01\$04\$00\$14\$00\$00\$00\$11\$00\
\$04\$01\$13\$01\$13\$01\$07\$04\$ff\$00\$00\$00\$00\$01\$07\$04\
\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$00\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$00\$ff\$00\$00\$00\$00\$01\$07\$00\
\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$00\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$04\$ff\$00\$00\$00\$00\$01\$07\$04\
\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$00\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$00\$ff\$00\$00\$00\$00\$01\$07\$00\
\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$00\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$04\$ff\$00\$00\$00\$00\$01\$07\$04\
\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$00\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$00\$ff\$00\$00\$00\$00\$01\$07\$00\
\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$00\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$04\$ff\$00\$00\$00\$00\$01\$07\$04\
\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$00\$00\$00\$00\$01\$07\$02\
\$00\$00\$00\$00\$00\$01\$07\$00\$ff\$00\$00\$00\$00\$01\$07\$00\
\$00\$00\$00\$00\$00\$00\$14\$01\$01\$00\$11\$01\$04\$00\$14\$00\
\$01\$00\$11\$00\$04\$01\$13\$01\$13\$01\$12\$0f\$00\$49\$00\$01\
\$14\$00\$14\$00\$00\$00\$11\$00\$11\$0d\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$04\$09\$ff\$00\$00\$01\$09\$00\$00\
\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\
\$01\$09\$00\$00\$00\$01\$13\$01\$12\$10\$00\$85\$00\$01\$14\$00\
\$09\$ff\$ff\$00\$00\$14\$00\$00\$00\$11\$00\$11\$01\$09\$00\$00\
\$00\$03\$09\$ff\$ff\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$ff\$00\
\$01\$09\$00\$00\$00\$03\$09\$ff\$ff\$00\$01\$09\$00\$00\$00\$03\
\$09\$ff\$ff\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$ff\$00\$01\$09\
\$00\$00\$00\$03\$09\$ff\$ff\$00\$01\$09\$00\$00\$00\$03\$09\$ff\
\$ff\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$ff\$00\$01\$09\$00\$00\
\$00\$03\$09\$ff\$ff\$00\$01\$09\$00\$00\$00\$03\$09\$ff\$ff\$00\
\$01\$09\$00\$00\$00\$01\$09\$ff\$ff\$00\$01\$09\$00\$00\$00\$01\
\$13\$01\$12\$11\$00\$85\$00\$01\$14\$00\$09\$00\$00\$ee\$00\$14\
\$01\$01\$00\$11\$01\$11\$01\$09\$00\$00\$00\$03\$09\$00\$00\$ee\
\$01\$09\$00\$00\$00\$01\$09\$00\$00\$ee\$01\$09\$00\$00\$00\$03\
\$09\$00\$00\$ee\$01\$09\$00\$00\$00\$03\$09\$00\$00\$ee\$01\$09\
\$00\$00\$00\$01\$09\$00\$00\$ee\$01\$09\$00\$00\$00\$03\$09\$00\
\$00\$ee\$01\$09\$00\$00\$00\$03\$09\$00\$00\$ee\$01\$09\$00\$00\
\$00\$01\$09\$00\$00\$ee\$01\$09\$00\$00\$00\$03\$09\$00\$00\$ee\
\$01\$09\$00\$00\$00\$03\$09\$00\$00\$ee\$01\$09\$00\$00\$00\$01\
\$09\$00\$00\$ee\$01\$09\$00\$00\$00\$01\$13\$01\$12\$12\$00\$f3\
\$00\$01\$14\$00\$14\$01\$01\$00\$11\$01\$11\$00\$14\$00\$00\$00\
\$11\$00\$11\$01\$13\$01\$13\$01\$09\$00\$ee\$00\$00\$14\$01\$00\
\$00\$11\$01\$22\$00\$14\$00\$01\$00\$11\$00\$22\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$13\$01\$13\$01\$12\$13\$01\$25\$00\$01\$08\$00\$14\$01\$00\$00\
\$11\$01\$04\$00\$14\$00\$00\$00\$11\$00\$04\$01\$13\$01\$13\$01\
\$09\$ff\$00\$cc\$00\$14\$01\$01\$00\$11\$01\$00\$00\$14\$00\$00\
\$00\$11\$00\$00\$01\$13\$01\$13\$01\$14\$01\$00\$00\$11\$01\$01\
\$00\$14\$00\$01\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$01\
\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\
\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$01\$00\$11\$00\$01\
\$01\$13\$01\$13\$01\$14\$01\$01\$00\$11\$01\$01\$00\$14\$00\$00\
\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$00\$00\$11\$01\$01\
\$00\$14\$00\$01\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$01\
\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\
\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$01\$00\$11\$00\$01\
\$01\$13\$01\$13\$01\$14\$01\$01\$00\$11\$01\$01\$00\$14\$00\$00\
\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$00\$00\$11\$01\$01\
\$00\$14\$00\$01\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$01\
\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\
\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$01\$00\$11\$00\$01\
\$01\$13\$01\$13\$01\$14\$01\$01\$00\$11\$01\$05\$00\$14\$00\$01\
\$00\$11\$00\$04\$03\$09\$00\$00\$00\$01\$13\$01\$13\$01\$12\$14\
\$0a\$4b\$00\$01\$08\$00\$14\$01\$00\$00\$11\$01\$04\$00\$14\$00\
\$00\$00\$11\$00\$04\$01\$13\$01\$13\$01\$07\$04\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$01\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$03\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$01\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$01\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$66\$ff\$00\
\$00\$00\$07\$01\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$01\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$03\$00\$66\$ff\$00\$00\$00\$07\$01\$00\$66\$ff\$00\
\$00\$00\$07\$00\$00\$66\$ff\$00\$00\$01\$07\$04\$00\$00\$00\$00\
\$00\$00\$07\$03\$00\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$03\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\
\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$04\$00\$66\$ff\$00\
\$00\$00\$07\$02\$00\$66\$ff\$00\$00\$00\$07\$00\$00\$66\$ff\$00\
\$00\$00\$14\$01\$01\$00\$11\$01\$04\$00\$14\$00\$01\$00\$11\$00\
\$04\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\
\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$13\$01\$13\$01\$12\$15\
\$01\$e1\$00\$01\$08\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\
\$07\$02\$99\$00\$ff\$00\$00\$02\$07\$02\$00\$00\$00\$00\$00\$00\
\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$07\$04\$99\$00\$ff\$00\
\$00\$02\$07\$04\$00\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\
\$01\$01\$13\$01\$07\$02\$99\$00\$ff\$00\$00\$02\$07\$02\$00\$00\
\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$07\$04\
\$99\$00\$ff\$00\$00\$02\$07\$04\$00\$00\$00\$00\$00\$00\$14\$00\
\$00\$00\$11\$00\$01\$01\$13\$01\$07\$02\$99\$00\$ff\$00\$00\$02\
\$07\$02\$00\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\$01\$01\
\$13\$01\$07\$04\$99\$00\$ff\$00\$00\$02\$07\$04\$00\$00\$00\$00\
\$00\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$07\$02\$99\$00\
\$ff\$00\$00\$02\$07\$02\$00\$00\$00\$00\$00\$00\$14\$00\$00\$00\
\$11\$00\$01\$01\$13\$01\$07\$04\$99\$00\$ff\$00\$00\$02\$07\$04\
\$00\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\
\$07\$02\$99\$00\$ff\$00\$00\$02\$07\$02\$00\$00\$00\$00\$00\$00\
\$14\$00\$01\$00\$11\$00\$01\$01\$13\$01\$07\$04\$99\$00\$ff\$00\
\$00\$02\$07\$04\$00\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\
\$01\$01\$13\$01\$07\$02\$99\$00\$ff\$00\$00\$02\$07\$02\$00\$00\
\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$07\$04\
\$99\$00\$ff\$00\$00\$02\$07\$04\$00\$00\$00\$00\$00\$00\$14\$00\
\$00\$00\$11\$00\$01\$01\$13\$01\$07\$02\$99\$00\$ff\$00\$00\$02\
\$07\$02\$00\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\$01\$01\
\$13\$01\$07\$04\$99\$00\$ff\$00\$00\$02\$07\$04\$00\$00\$00\$00\
\$00\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$07\$02\$99\$00\
\$ff\$00\$00\$02\$07\$02\$00\$00\$00\$00\$00\$00\$14\$00\$00\$00\
\$11\$00\$01\$01\$13\$01\$07\$04\$99\$00\$ff\$00\$00\$02\$07\$04\
\$00\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\
\$07\$02\$99\$00\$ff\$00\$00\$02\$07\$02\$00\$00\$00\$00\$00\$00\
\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$07\$04\$99\$00\$ff\$00\
\$00\$02\$07\$04\$00\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\
\$01\$01\$13\$01\$12\$16\$00\$f3\$00\$01\$14\$00\$14\$01\$01\$00\
\$11\$01\$11\$00\$14\$00\$00\$00\$11\$00\$11\$01\$13\$01\$13\$01\
\$09\$ff\$00\$00\$00\$14\$01\$00\$00\$11\$01\$22\$00\$14\$00\$01\
\$00\$11\$00\$22\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\
\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\
\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\
\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\
\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\
\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\
\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\
\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\
\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\
\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\
\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\
\$00\$00\$00\$01\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$09\$ff\
\$00\$00\$01\$09\$00\$00\$00\$01\$13\$01\$13\$01\$12\$17\$00\$cd\
\$00\$01\$14\$00\$07\$02\$ff\$cc\$00\$00\$00\$00\$14\$01\$01\$00\
\$11\$01\$11\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$04\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$05\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$04\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$05\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$04\$07\$02\$ff\$cc\
\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$13\$00\$07\$02\
\$ff\$cc\$00\$00\$00\$01\$07\$02\$00\$00\$00\$00\$00\$01\$12\$18\
\$00\$49\$00\$01\$14\$00\$14\$01\$01\$00\$11\$01\$11\$0d\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\
\$00\$03\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$03\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\
\$09\$ff\$00\$00\$01\$09\$00\$00\$00\$01\$13\$01\$12\$19\$01\$25\
\$00\$01\$08\$00\$14\$01\$00\$00\$11\$01\$04\$00\$14\$00\$00\$00\
\$11\$00\$04\$01\$13\$01\$13\$01\$09\$ff\$ff\$00\$00\$14\$01\$01\
\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\
\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$01\$00\$11\$00\$01\
\$01\$13\$01\$13\$01\$14\$01\$01\$00\$11\$01\$01\$00\$14\$00\$00\
\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$00\$00\$11\$01\$01\
\$00\$14\$00\$01\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$01\
\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\
\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$01\$00\$11\$00\$01\
\$01\$13\$01\$13\$01\$14\$01\$01\$00\$11\$01\$01\$00\$14\$00\$00\
\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$00\$00\$11\$01\$01\
\$00\$14\$00\$01\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$01\
\$00\$11\$01\$01\$00\$14\$00\$00\$00\$11\$00\$01\$01\$13\$01\$13\
\$01\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$01\$00\$11\$00\$01\
\$01\$13\$01\$13\$01\$14\$01\$01\$00\$11\$01\$01\$00\$14\$00\$00\
\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$00\$00\$11\$01\$01\
\$00\$14\$00\$01\$00\$11\$00\$01\$01\$13\$01\$13\$01\$14\$01\$01\
\$00\$11\$01\$04\$00\$14\$00\$01\$00\$11\$00\$04\$03\$09\$00\$00\
\$00\$01\$13\$01\$13\$01\$12\$1a\$01\$e1\$00\$01\$08\$00\$14\$01\
\$00\$00\$11\$01\$01\$01\$13\$01\$07\$02\$ff\$ff\$00\$00\$00\$02\
\$07\$02\$00\$00\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\
\$13\$01\$07\$04\$ff\$ff\$00\$00\$00\$02\$07\$04\$00\$00\$00\$00\
\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\$13\$01\$07\$02\$ff\$ff\
\$00\$00\$00\$02\$07\$02\$00\$00\$00\$00\$00\$00\$14\$01\$00\$00\
\$11\$01\$01\$01\$13\$01\$07\$04\$ff\$ff\$00\$00\$00\$02\$07\$04\
\$00\$00\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\$13\$01\
\$07\$02\$ff\$ff\$00\$00\$00\$02\$07\$02\$00\$00\$00\$00\$00\$00\
\$14\$01\$00\$00\$11\$01\$01\$01\$13\$01\$07\$04\$ff\$ff\$00\$00\
\$00\$02\$07\$04\$00\$00\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\
\$01\$01\$13\$01\$07\$02\$ff\$ff\$00\$00\$00\$02\$07\$02\$00\$00\
\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\$13\$01\$07\$04\
\$ff\$ff\$00\$00\$00\$02\$07\$04\$00\$00\$00\$00\$00\$00\$14\$01\
\$01\$00\$11\$01\$01\$01\$13\$01\$07\$02\$ff\$ff\$00\$00\$00\$02\
\$07\$02\$00\$00\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\
\$13\$01\$07\$04\$ff\$ff\$00\$00\$00\$02\$07\$04\$00\$00\$00\$00\
\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\$13\$01\$07\$02\$ff\$ff\
\$00\$00\$00\$02\$07\$02\$00\$00\$00\$00\$00\$00\$14\$01\$00\$00\
\$11\$01\$01\$01\$13\$01\$07\$04\$ff\$ff\$00\$00\$00\$02\$07\$04\
\$00\$00\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\$13\$01\
\$07\$02\$ff\$ff\$00\$00\$00\$02\$07\$02\$00\$00\$00\$00\$00\$00\
\$14\$01\$00\$00\$11\$01\$01\$01\$13\$01\$07\$04\$ff\$ff\$00\$00\
\$00\$02\$07\$04\$00\$00\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\
\$01\$01\$13\$01\$07\$02\$ff\$ff\$00\$00\$00\$02\$07\$02\$00\$00\
\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\$13\$01\$07\$04\
\$ff\$ff\$00\$00\$00\$02\$07\$04\$00\$00\$00\$00\$00\$00\$14\$01\
\$00\$00\$11\$01\$01\$01\$13\$01\$07\$02\$ff\$ff\$00\$00\$00\$02\
\$07\$02\$00\$00\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\
\$13\$01\$07\$04\$ff\$ff\$00\$00\$00\$02\$07\$04\$00\$00\$00\$00\
\$00\$00\$14\$01\$00\$00\$11\$01\$01\$01\$13\$01\$12\$1b\$00\$cb\
\$00\$01\$14\$00\$14\$01\$01\$00\$11\$01\$11\$00\$14\$00\$00\$00\
\$11\$00\$11\$01\$13\$01\$13\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$01\$07\$02\$00\$ee\$00\$00\$00\$01\
\$07\$02\$00\$00\$00\$00\$00\$00\$14\$01\$01\$00\$11\$01\$11\$00\
\$14\$00\$00\$00\$11\$00\$11\$01\$13\$01\$13\$01\$12\$1c\$01\$6f\
\$00\$01\$10\$00\$07\$03\$ff\$00\$00\$00\$00\$00\$14\$01\$00\$00\
\$11\$01\$02\$01\$13\$01\$07\$01\$ff\$00\$00\$00\$00\$00\$14\$00\
\$00\$00\$11\$00\$02\$01\$07\$03\$00\$00\$00\$00\$00\$01\$13\$01\
\$07\$03\$ff\$00\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$02\$01\
\$07\$01\$00\$00\$00\$00\$00\$01\$13\$01\$07\$01\$ff\$00\$00\$00\
\$00\$00\$14\$00\$00\$00\$11\$00\$02\$01\$07\$03\$00\$00\$00\$00\
\$00\$01\$13\$01\$07\$03\$ff\$00\$00\$00\$00\$00\$14\$01\$00\$00\
\$11\$01\$02\$01\$07\$01\$00\$00\$00\$00\$00\$01\$13\$01\$07\$01\
\$ff\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\$02\$01\$07\$03\
\$00\$00\$00\$00\$00\$01\$13\$01\$07\$03\$ff\$00\$00\$00\$00\$00\
\$14\$01\$00\$00\$11\$01\$02\$01\$07\$01\$00\$00\$00\$00\$00\$01\
\$13\$01\$07\$01\$ff\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\
\$02\$01\$07\$03\$00\$00\$00\$00\$00\$01\$13\$01\$07\$03\$ff\$00\
\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$02\$01\$07\$01\$00\$00\
\$00\$00\$00\$01\$13\$01\$07\$01\$ff\$00\$00\$00\$00\$00\$14\$00\
\$00\$00\$11\$00\$02\$01\$07\$03\$00\$00\$00\$00\$00\$01\$13\$01\
\$07\$03\$ff\$00\$00\$00\$00\$00\$14\$01\$00\$00\$11\$01\$04\$01\
\$07\$01\$00\$00\$00\$00\$00\$01\$13\$01\$07\$01\$ff\$00\$00\$00\
\$00\$00\$14\$00\$00\$00\$11\$00\$04\$01\$07\$03\$00\$00\$00\$00\
\$00\$01\$13\$01\$07\$03\$ff\$00\$00\$00\$00\$00\$14\$01\$00\$00\
\$11\$01\$03\$01\$07\$01\$00\$00\$00\$00\$00\$01\$13\$01\$07\$01\
\$ff\$00\$00\$00\$00\$00\$14\$00\$00\$00\$11\$00\$03\$01\$07\$03\
\$00\$00\$00\$00\$00\$01\$13\$02\$07\$01\$00\$00\$00\$00\$00\$01\
\$12\$1d\$02\$bf\$00\$01\$07\$00\$14\$01\$01\$00\$11\$01\$04\$00\
\$14\$00\$01\$00\$11\$00\$04\$01\$13\$01\$13\$02\$09\$00\$ee\$00\
\$00\$14\$01\$00\$00\$11\$01\$01\$00\$14\$00\$01\$00\$11\$00\$01\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$13\$01\$13\$01\$09\$00\$ee\$00\$00\$14\$01\$01\
\$00\$11\$01\$02\$00\$14\$00\$00\$00\$11\$00\$02\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$13\$01\$13\$01\$09\$00\$ee\$00\
\$00\$14\$01\$00\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\$02\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$13\$01\$13\$01\
\$09\$00\$ee\$00\$00\$14\$01\$01\$00\$11\$01\$02\$00\$14\$00\$00\
\$00\$11\$00\$02\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$13\$01\$13\$01\$09\$00\$ee\$00\$00\$14\$01\$00\$00\$11\$01\$02\
\$00\$14\$00\$01\$00\$11\$00\$02\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$13\$01\$13\$01\$09\$00\$ee\$00\$00\$14\$01\$01\
\$00\$11\$01\$02\$00\$14\$00\$00\$00\$11\$00\$02\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$13\$01\$13\$01\$09\$00\$ee\$00\
\$00\$14\$01\$00\$00\$11\$01\$02\$00\$14\$00\$01\$00\$11\$00\$02\
\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\
\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\
\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\
\$ee\$00\$01\$09\$00\$00\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\
\$00\$01\$09\$00\$ee\$00\$01\$09\$00\$00\$00\$01\$13\$01\$13\$01\
\$14\$01\$00\$00\$11\$01\$03\$00\$14\$00\$00\$00\$11\$00\$05\$01\
\$13\$01\$13\$01\$13\$01\$13\$01\$10\$00\$01\$04\$01\$07\$04\$00\
\$33\$ff\$00\$00\$00\$07\$02\$ff\$00\$00\$00\$00\$00\$07\$00\$ff\
\$ff\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\$ff\
\$ff\$00\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$ff\
\$ff\$00\$00\$00\$00\$07\$02\$00\$ee\$00\$00\$00\$00\$07\$00\$ff\
\$00\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\
\$ee\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$ee\
\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\$07\$04\$00\
\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$ff\
\$00\$00\$00\$00\$00\$07\$00\$ff\$ff\$00\$00\$00\$01\$07\$04\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\
\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$ff\
\$ff\$00\$00\$00\$00\$07\$00\$ff\$00\$00\$00\$00\$01\$07\$02\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$03\$ee\
\$00\$00\$00\$00\$00\$07\$00\$00\$ee\$00\$00\$00\$01\$07\$03\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$ff\
\$00\$00\$00\$00\$00\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$03\$00\
\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\
\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$01\$07\$04\$00\
\$33\$ff\$00\$00\$00\$07\$02\$ff\$00\$00\$00\$00\$00\$07\$00\$ff\
\$ff\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$01\$ff\
\$ff\$00\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$ff\
\$ff\$00\$00\$00\$00\$07\$02\$00\$ee\$00\$00\$00\$00\$07\$00\$ff\
\$00\$00\$00\$00\$01\$07\$04\$00\$00\$00\$00\$00\$00\$07\$02\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\
\$ee\$00\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$04\$ee\
\$00\$00\$00\$00\$00\$07\$01\$00\$33\$ff\$00\$00\$01\$07\$04\$00\
\$00\$00\$00\$00\$00\$07\$01\$00\$00\$00\$00\$00\$00\$07\$04\$ff\
\$00\$00\$00\$00\$00\$07\$00\$ff\$ff\$00\$00\$00\$01\$07\$04\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$00\
\$33\$ff\$00\$00\$01\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$ff\
\$ff\$00\$00\$00\$00\$07\$00\$ff\$00\$00\$00\$00\$01\$07\$02\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$01\$07\$03\$ee\
\$00\$00\$00\$00\$00\$07\$00\$00\$ee\$00\$00\$00\$01\$07\$03\$00\
\$00\$00\$00\$00\$00\$07\$00\$00\$00\$00\$00\$00\$00\$07\$03\$ff\
\$00\$00\$00\$00\$00\$07\$02\$00\$ee\$00\$00\$00\$01\$07\$03\$00\
\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\$07\$01\$00\
\$33\$ff\$00\$00\$01\$07\$01\$00\$00\$00\$00\$00\$01";;

// la liste des pas de danse pour la chor√©graphie de streaming (messages audio, podcasts, radios...)
const chorstream_chorslist=
"\$01\$01\$01\$01\$00\$01\$10\$00\$0e\$04\$00\$00\$0e\$03\$01\$00\
\$0e\$01\$01\$00\$0e\$00\$02\$01\$0a\$03\$00\$0a\$01\$00\$0e\$02\
\$01\$01\$0a\$02\$01\$0a\$00\$01\$0e\$03\$01\$01\$0a\$04\$00\$0a\
\$03\$00\$0e\$02\$01\$00\$0e\$00\$02\$01\$0a\$02\$00\$0e\$01\$01\
\$01\$0a\$01\$00\$0e\$04\$00\$01\$0a\$00\$01\$0e\$03\$01\$01\$0a\
\$03\$00\$0e\$02\$01\$00\$0e\$00\$02\$01\$0a\$02\$00\$0e\$01\$01\
\$01\$0a\$04\$00\$0a\$01\$01\$0a\$00\$01\$0e\$04\$00\$00\$0e\$01\
\$01\$01\$0a\$01\$00\$0e\$02\$01\$00\$0e\$00\$02\$01\$0a\$02\$00\
\$0e\$03\$01\$01\$0a\$03\$01\$0a\$00\$01\$0a\$04\$00\$0e\$02\$01\
\$01\$0a\$02\$00\$0e\$03\$01\$00\$0e\$01\$01\$00\$0e\$00\$02\$01\
\$0a\$03\$00\$0a\$01\$00\$0e\$04\$00\$00\$0e\$02\$01\$01\$0a\$02\
\$01\$0a\$00\$01\$0e\$03\$01\$00\$0e\$02\$01\$00\$0e\$01\$01\$01\
\$0a\$03\$00\$0a\$02\$00\$0a\$01\$00\$0e\$00\$02\$01\$0a\$04\$02\
\$0a\$00\$00\$0e\$04\$00\$02\$0e\$00\$02\$01\$0e\$03\$01\$00\$0e\
\$01\$01\$01\$0a\$03\$00\$0a\$01\$00\$0e\$02\$01\$01\$0a\$04\$00\
\$0a\$02\$00\$0a\$00\$02\$0e\$04\$00\$00\$0e\$03\$01\$00\$0e\$00\
\$02\$01\$0a\$03\$00\$0e\$02\$01\$01\$0a\$02\$00\$0e\$01\$01\$01\
\$0a\$01\$00\$0a\$00\$02\$0a\$04\$00\$0e\$01\$01\$00\$0e\$00\$02\
\$01\$0a\$01\$00\$0e\$02\$01\$01\$0a\$02\$00\$0e\$04\$00\$00\$0e\
\$03\$01\$01\$0a\$03\$00\$0a\$00\$02\$0e\$02\$01\$00\$0e\$00\$02\
\$01\$0a\$02\$00\$0e\$03\$01\$00\$0e\$01\$01\$01\$0a\$04\$00\$0a\
\$03\$00\$0a\$01\$00\$0e\$02\$01\$01\$0a\$02\$00\$0a\$00\$01\$0e\
\$04\$00\$01\$0e\$03\$01\$00\$0e\$00\$02\$01\$0a\$03\$00\$0e\$02\
\$01\$01\$0a\$02\$00\$0e\$01\$01\$01\$0a\$01\$00\$0a\$00\$01\$0a\
\$04\$01\$0e\$03\$01\$00\$0e\$00\$02\$01\$0a\$03\$00\$0e\$04\$00\
\$00\$0e\$02\$01\$01\$0a\$02\$00\$0e\$01\$01\$01\$0a\$01\$00\$0a\
\$00\$02\$0e\$00\$02\$01\$0a\$04\$02\$0a\$00\$00\$0e\$04\$00\$02\
\$0e\$03\$01\$00\$0e\$01\$01\$00\$0e\$00\$02\$01\$0a\$03\$00\$0a\
\$01\$00\$0e\$02\$01\$01\$0a\$02\$01\$0a\$04\$00\$0a\$00\$02\$0a\
\$00\$00\$0a\$01\$00\$0a\$02\$00\$0a\$03\$00\$0a\$04"::
"\$01\$01\$01\$01\$00\$01\$10\$00\$0e\$04\$00\$00\$0e\$03\$01\$00\
\$0e\$01\$01\$00\$0e\$00\$02\$01\$0a\$03\$00\$0a\$01\$00\$0e\$02\
\$01\$01\$0a\$02\$01\$0a\$00\$01\$0e\$03\$01\$01\$0a\$03\$00\$0e\
\$02\$01\$00\$0e\$00\$02\$01\$0a\$02\$00\$0e\$01\$01\$01\$0a\$04\
\$00\$0a\$01\$01\$0a\$00\$01\$0e\$04\$00\$01\$0e\$00\$02\$03\$0a\
\$00\$01\$0e\$01\$01\$01\$0a\$01\$00\$0e\$02\$01\$00\$0e\$00\$02\
\$01\$0a\$04\$00\$0a\$02\$00\$0e\$03\$01\$01\$0a\$03\$01\$0a\$00\
\$01\$0e\$02\$01\$01\$0a\$02\$00\$0e\$03\$01\$00\$0e\$01\$01\$00\
\$0e\$00\$02\$01\$0a\$03\$00\$0a\$01\$00\$0e\$02\$01\$01\$0a\$02\
\$01\$0a\$00\$01\$0e\$03\$01\$00\$0e\$02\$01\$00\$0e\$01\$01\$01\
\$0a\$03\$00\$0a\$02\$00\$0a\$01\$00\$0e\$00\$02\$02\$0e\$04\$00\
\$00\$0e\$03\$01\$00\$0e\$01\$01\$01\$0a\$03\$00\$0a\$01\$00\$0a\
\$00\$00\$0e\$02\$01\$01\$0a\$02\$01\$0e\$00\$02\$03\$0a\$00\$01\
\$0a\$04\$01\$0e\$03\$01\$00\$0e\$00\$02\$01\$0a\$03\$00\$0e\$04\
\$00\$00\$0e\$02\$01\$01\$0a\$02\$00\$0e\$01\$01\$01\$0a\$01\$00\
\$0a\$00\$02\$0e\$01\$01\$00\$0e\$00\$02\$01\$0a\$01\$00\$0e\$02\
\$01\$01\$0a\$02\$00\$0e\$03\$01\$01\$0a\$04\$00\$0a\$03\$00\$0a\
\$00\$02\$0a\$00\$00\$0a\$01\$00\$0a\$02\$00\$0a\$03\$00\$0a\$04\
"::
"\$01\$01\$01\$01\$00\$01\$10\$00\$0e\$04\$00\$00\$0e\$03\$01\$00\
\$0e\$01\$01\$00\$0e\$00\$02\$01\$0e\$02\$01\$01\$0a\$00\$01\$0a\
\$03\$00\$0a\$01\$01\$0a\$02\$01\$0e\$03\$01\$01\$0a\$04\$00\$0e\
\$02\$01\$00\$0e\$00\$02\$01\$0e\$01\$01\$01\$0a\$03\$00\$0a\$00\
\$01\$0a\$02\$01\$0a\$01\$00\$0e\$04\$00\$02\$0e\$00\$02\$01\$0e\
\$01\$01\$01\$0a\$00\$00\$0e\$02\$01\$01\$0e\$03\$01\$01\$0a\$01\
\$01\$0a\$04\$00\$0a\$02\$01\$0a\$03\$00\$0e\$00\$02\$01\$0e\$02\
\$01\$01\$0a\$00\$00\$0e\$03\$01\$00\$0e\$01\$01\$01\$0e\$04\$00\
\$01\$0a\$02\$01\$0e\$02\$01\$01\$0e\$00\$02\$01\$0a\$03\$00\$0a\
\$01\$01\$0a\$02\$00\$0a\$00\$02\$0a\$04\$02\$0e\$03\$01\$00\$0e\
\$02\$01\$00\$0e\$01\$01\$00\$0e\$00\$02\$01\$0e\$04\$00\$01\$0a\
\$00\$01\$0a\$03\$00\$0a\$02\$00\$0a\$01\$03\$0e\$00\$02\$02\$0a\
\$04\$00\$0a\$00\$00\$0e\$01\$01\$01\$0e\$02\$01\$01\$0e\$03\$01\
\$01\$0a\$01\$01\$0a\$02\$00\$0e\$00\$02\$01\$0a\$03\$01\$0a\$00\
\$01\$0e\$03\$01\$01\$0e\$02\$01\$01\$0e\$01\$01\$01\$0a\$03\$00\
\$0e\$00\$02\$01\$0a\$02\$01\$0a\$01\$00\$0a\$00\$00\$0e\$04\$00\
\$03\$0e\$03\$01\$00\$0e\$01\$01\$01\$0e\$02\$01\$00\$0e\$00\$02\
\$02\$0a\$03\$00\$0a\$01\$00\$0a\$00\$01\$0a\$04\$00\$0a\$02\$03\
\$0e\$00\$02\$01\$0e\$04\$00\$00\$0e\$03\$01\$00\$0e\$01\$01\$01\
\$0a\$00\$00\$0e\$02\$01\$02\$0a\$03\$00\$0a\$01\$01\$0a\$02\$01\
\$0e\$00\$02\$02\$0a\$04\$00\$0a\$00\$04\$0a\$00\$00\$0a\$01\$00\
\$0a\$02\$00\$0a\$03\$00\$0a\$04"::
"\$01\$01\$01\$01\$00\$01\$19\$00\$0e\$04\$00\$00\$0e\$01\$01\$00\
\$0e\$00\$02\$01\$0e\$02\$01\$01\$0a\$04\$00\$0e\$03\$01\$02\$0a\
\$01\$00\$0e\$04\$00\$01\$0a\$02\$00\$0a\$00\$01\$0a\$04\$00\$0a\
\$03\$01\$0e\$00\$02\$01\$0e\$04\$00\$00\$0e\$03\$01\$01\$0e\$02\
\$01\$01\$0a\$04\$00\$0e\$01\$01\$01\$0a\$03\$01\$0a\$02\$00\$0a\
\$00\$01\$0a\$01\$01\$0e\$00\$02\$01\$0e\$01\$01\$01\$0e\$04\$00\
\$00\$0e\$02\$01\$01\$0e\$03\$01\$01\$0a\$04\$01\$0a\$01\$00\$0a\
\$00\$01\$0a\$02\$00\$0e\$04\$00\$01\$0a\$03\$00\$0e\$00\$02\$01\
\$0a\$04\$01\$0e\$03\$01\$01\$0e\$04\$00\$00\$0e\$02\$01\$01\$0e\
\$01\$01\$01\$0a\$04\$00\$0a\$03\$00\$0a\$00\$01\$0a\$02\$01\$0a\
\$01\$00\$0e\$00\$02\$04\$0e\$04\$00\$00\$0e\$03\$01\$00\$0e\$01\
\$01\$01\$0a\$00\$00\$0e\$02\$01\$01\$0a\$04\$01\$0a\$03\$00\$0a\
\$01\$00\$0e\$00\$02\$01\$0a\$02\$00\$0e\$04\$00\$01\$0e\$03\$01\
\$00\$0e\$01\$01\$01\$0a\$04\$00\$0e\$02\$01\$02\$0a\$03\$00\$0a\
\$01\$00\$0a\$00\$00\$0e\$04\$00\$01\$0a\$02\$01\$0a\$04\$00\$0e\
\$03\$01\$00\$0e\$01\$01\$00\$0e\$00\$02\$01\$0e\$02\$01\$02\$0a\
\$03\$00\$0a\$01\$01\$0a\$02\$01\$0a\$00\$00\$0e\$03\$01\$00\$0e\
\$01\$01\$01\$0e\$04\$00\$00\$0e\$02\$01\$01\$0e\$00\$02\$01\$0a\
\$04\$00\$0a\$03\$00\$0a\$01\$01\$0a\$02\$01\$0e\$04\$00\$00\$0e\
\$03\$01\$00\$0e\$01\$01\$01\$0e\$02\$01\$01\$0a\$04\$00\$0a\$00\
\$01\$0a\$03\$00\$0a\$01\$01\$0a\$02\$00\$0e\$04\$00\$00\$0e\$00\
\$02\$01\$0e\$03\$01\$00\$0e\$01\$01\$01\$0a\$04\$00\$0e\$02\$01\
\$02\$0a\$03\$00\$0a\$01\$01\$0a\$02\$00\$0a\$00\$02\$0a\$00\$00\
\$0a\$01\$00\$0a\$02\$00\$0a\$03\$00\$0a\$04"::
nil;;
const midi_1noteA4=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$2a\$00\$ff\$03\$07\$31\$6e\$6f\$74\$65\$41\
\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$c0\$09\$14\$90\$51\$78\$82\$4a\$80\$51\$49\$00\$ff\$2f\$00";;
const midi_1noteB5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$2a\$00\$ff\$03\$07\$31\$6e\$6f\$74\$65\$42\
\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$c0\$09\$0a\$90\$5f\$76\$82\$5d\$80\$5f\$4d\$00\$ff\$2f\$00";;
const midi_1noteBb4=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$2b\$00\$ff\$03\$08\$31\$6e\$6f\$74\$65\$42\
\$62\$34\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\$02\$18\
\$08\$00\$c0\$09\$14\$90\$52\$64\$82\$7a\$80\$52\$49\$00\$ff\$2f\
\$00";;
const midi_1noteC5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$2a\$00\$ff\$03\$07\$31\$6e\$6f\$74\$65\$43\
\$36\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$c0\$09\$0d\$90\$54\$7a\$83\$39\$80\$54\$76\$00\$ff\$2f\$00";;
const midi_1noteE4=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$29\$00\$ff\$03\$06\$4e\$6f\$74\$65\$31\$41\
\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\$02\$18\$08\$00\
\$c0\$09\$11\$90\$4c\$7f\$82\$56\$80\$4c\$76\$00\$ff\$2f\$00";;
const midi_1noteF4=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$2b\$00\$ff\$03\$08\$31\$6e\$6f\$74\$65\$46\
\$23\$34\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\$02\$18\
\$08\$00\$c0\$09\$12\$90\$4e\$6e\$82\$46\$80\$4e\$49\$00\$ff\$2f\
\$00";;
const midi_1noteF5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$2a\$00\$ff\$03\$07\$31\$6e\$6f\$74\$65\$46\
\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$c0\$09\$12\$90\$59\$70\$81\$7f\$80\$59\$49\$00\$ff\$2f\$00";;
const midi_1noteG5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$2a\$00\$ff\$03\$07\$31\$6e\$6f\$74\$65\$47\
\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$c0\$09\$0f\$90\$5b\$7b\$82\$20\$80\$5b\$4d\$00\$ff\$2f\$00";;
const midi_2notesC6C4=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$34\$00\$ff\$03\$0a\$32\$6e\$6f\$74\$65\$73\
\$43\$36\$43\$34\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\
\$02\$18\$08\$00\$c0\$09\$11\$90\$60\$63\$81\$06\$48\$53\$82\$0a\
\$80\$60\$4d\$5e\$48\$76\$00\$ff\$2f\$00";;
const midi_2notesC6F5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$34\$00\$ff\$03\$0b\$32\$6e\$6f\$74\$65\$73\
\$43\$36\$46\$23\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\
\$04\$02\$18\$08\$00\$c0\$09\$14\$90\$60\$5d\$38\$5a\$67\$02\$80\
\$60\$6a\$81\$23\$5a\$6f\$00\$ff\$2f\$00";;
const midi_2notesD4A5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$33\$00\$ff\$03\$0a\$32\$6e\$6f\$74\$65\$73\
\$44\$34\$41\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\
\$02\$18\$08\$00\$c0\$09\$45\$90\$4a\$5b\$81\$70\$5d\$69\$06\$80\
\$4a\$49\$78\$5d\$52\$00\$ff\$2f\$00";;
const midi_2notesD4G4=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$36\$00\$ff\$03\$0a\$32\$6e\$6f\$74\$65\$73\
\$44\$34\$47\$34\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\
\$02\$18\$08\$00\$c0\$09\$15\$90\$4a\$62\$84\$15\$80\$4a\$49\$10\
\$90\$4f\$71\$84\$33\$80\$4f\$76\$00\$ff\$2f\$00";;
const midi_2notesD5G4=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$32\$00\$ff\$03\$0a\$32\$6e\$6f\$74\$65\$73\
\$44\$35\$47\$34\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\
\$02\$18\$08\$00\$c0\$09\$08\$90\$56\$5f\$3d\$4f\$5a\$0e\$80\$56\
\$78\$49\$4f\$6c\$00\$ff\$2f\$00";;
const midi_2notesE5A5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$33\$00\$ff\$03\$0a\$32\$6e\$6f\$74\$65\$73\
\$41\$35\$45\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\
\$02\$18\$08\$00\$c0\$09\$14\$90\$58\$59\$81\$03\$5d\$58\$22\$80\
\$58\$6f\$7f\$5d\$52\$00\$ff\$2f\$00";;
const midi_2notesE5C6=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$32\$00\$ff\$03\$0a\$32\$6e\$6f\$74\$65\$73\
\$45\$35\$43\$36\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\
\$02\$18\$08\$00\$c0\$09\$02\$90\$58\$5a\$43\$60\$62\$08\$80\$58\
\$78\$61\$60\$54\$00\$ff\$2f\$00";;
const midi_2notesE5E4=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$33\$00\$ff\$03\$0a\$32\$6e\$6f\$74\$65\$73\
\$45\$35\$45\$34\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\
\$02\$18\$08\$00\$c0\$09\$02\$90\$58\$5a\$2c\$4c\$62\$1f\$80\$58\
\$78\$83\$76\$4c\$49\$00\$ff\$2f\$00";;
const midi_3notesA4G5G5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$3c\$00\$ff\$03\$0c\$33\$6e\$6f\$74\$65\$73\
\$41\$34\$47\$35\$47\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\
\$04\$04\$02\$18\$08\$00\$c0\$09\$11\$90\$51\$62\$6c\$5b\$52\$57\
\$80\$5b\$6c\$54\$90\$5b\$62\$46\$80\$5b\$54\$56\$51\$49\$00\$ff\
\$2f\$00";;
const midi_3notesB5A5F5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$3c\$00\$ff\$03\$0c\$33\$6e\$6f\$74\$65\$73\
\$42\$35\$41\$35\$46\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\
\$04\$04\$02\$18\$08\$00\$c0\$09\$10\$90\$5f\$49\$27\$5d\$62\$13\
\$80\$5f\$6a\$2b\$90\$59\$5a\$08\$80\$5d\$54\$44\$59\$78\$00\$ff\
\$2f\$00";;
const midi_3notesB5D5C6=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$3c\$00\$ff\$03\$0c\$33\$6e\$6f\$74\$65\$73\
\$42\$35\$44\$35\$43\$36\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\
\$04\$04\$02\$18\$08\$00\$c0\$09\$14\$90\$5f\$62\$28\$56\$52\$10\
\$80\$5f\$54\$32\$90\$60\$5a\$15\$80\$56\$6c\$46\$60\$6a\$00\$ff\
\$2f\$00";;
const midi_3notesD4E4G4=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$3c\$00\$ff\$03\$0c\$33\$6e\$6f\$74\$65\$73\
\$44\$34\$45\$34\$47\$34\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\
\$04\$04\$02\$18\$08\$00\$c0\$09\$03\$90\$4a\$5a\$28\$4c\$52\$23\
\$80\$4a\$78\$01\$90\$4f\$62\$33\$80\$4c\$6c\$13\$4f\$54\$00\$ff\
\$2f\$00";;
const midi_3notesE5A5C6=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$41\$00\$ff\$03\$0c\$33\$6e\$6f\$74\$65\$73\
\$45\$35\$41\$35\$43\$36\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\
\$04\$04\$02\$18\$08\$00\$c0\$09\$02\$90\$58\$5a\$4b\$80\$58\$78\
\$81\$01\$90\$5d\$49\$3a\$80\$5d\$6a\$82\$22\$90\$60\$58\$81\$77\
\$80\$60\$4d\$00\$ff\$2f\$00";;
const midi_3notesE5C6D5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$3d\$00\$ff\$03\$0c\$33\$6e\$6f\$74\$65\$73\
\$45\$35\$43\$36\$44\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\
\$04\$04\$02\$18\$08\$00\$c0\$09\$02\$90\$58\$5a\$43\$60\$62\$08\
\$80\$58\$78\$26\$90\$56\$48\$18\$80\$60\$54\$82\$3b\$56\$76\$00\
\$ff\$2f\$00";;
const midi_3notesE5D5A5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$3e\$00\$ff\$03\$0c\$33\$6e\$6f\$74\$65\$73\
\$45\$35\$44\$35\$41\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\
\$04\$04\$02\$18\$08\$00\$c0\$09\$0b\$90\$58\$40\$36\$56\$58\$6b\
\$80\$58\$52\$54\$90\$5d\$48\$81\$72\$80\$56\$4d\$81\$5c\$5d\$76\
\$00\$ff\$2f\$00";;
const midi_3notesF5C6G5=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$3c\$00\$ff\$03\$0c\$33\$6e\$6f\$74\$65\$73\
\$46\$35\$43\$36\$47\$35\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\
\$04\$04\$02\$18\$08\$00\$c0\$09\$04\$90\$59\$5a\$41\$60\$62\$0a\
\$80\$59\$78\$2f\$90\$5b\$52\$0d\$80\$60\$54\$4a\$5b\$6c\$00\$ff\
\$2f\$00";;

var midi_startrecord=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$03\$c0\$4d\$54\
\$72\$6b\$00\$00\$00\$9f\$00\$c0\$11\$00\$b0\$0a\$40\$00\$b0\$65\
\$00\$00\$b0\$64\$02\$00\$b0\$06\$40\$00\$b0\$65\$00\$00\$b0\$64\
\$01\$00\$b0\$06\$40\$00\$b0\$26\$00\$00\$b0\$65\$00\$00\$b0\$64\
\$00\$00\$b0\$06\$02\$00\$b0\$26\$00\$00\$ff\$51\$03\$09\$27\$c0\
\$1e\$90\$4f\$7f\$00\$b0\$0b\$7f\$00\$e0\$00\$3f\$1e\$b0\$0b\$7a\
\$00\$e0\$00\$40\$1e\$b0\$0b\$52\$1e\$b0\$0b\$69\$3c\$80\$4f\$7b\
\$00\$90\$51\$7b\$00\$b0\$0b\$7f\$00\$e0\$00\$3b\$1e\$b0\$0b\$65\
\$00\$e0\$00\$3c\$1e\$b0\$0b\$5d\$00\$e0\$00\$40\$1e\$e0\$00\$3d\
\$3c\$80\$51\$5b\$1e\$b0\$0b\$7f\$00\$e0\$00\$3e\$1e\$b0\$0b\$5e\
\$00\$e0\$00\$40\$1e\$b0\$0b\$34\$00\$90\$54\$7f\$83\$60\$80\$54\
\$00\$00\$ff\$2f\$00";;
const midi_endrecord=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$61\$00\$ff\$03\$07\$52\$65\$63\$46\$69\$6e\
\$31\$00\$ff\$51\$03\$10\$59\$42\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$c0\$71\$00\$90\$48\$7f\$1a\$80\$48\$40\$04\$90\$4a\$72\$1a\
\$80\$4a\$40\$04\$90\$4d\$7b\$1a\$80\$4d\$40\$04\$90\$4f\$7f\$1a\
\$80\$4f\$40\$04\$90\$51\$76\$1a\$80\$51\$40\$04\$90\$53\$7b\$1a\
\$80\$53\$40\$04\$90\$54\$7f\$1a\$80\$54\$40\$22\$91\$24\$01\$54\
\$81\$24\$40\$00\$ff\$2f\$00";;


const mp3_startrecord=
"\$49\$44\$33\$03\$00\$00\$00\$00\$00\$00\$ff\$f3\$66\$c0\$00\$00\
\$00\$02\$58\$01\$40\$00\$00\$16\$83\$41\$61\$80\$07\$fe\$b1\$30\
\$32\$63\$6c\$84\$ff\$fe\$9b\$81\$51\$83\$99\$ff\$ff\$0c\$b4\$cc\
\$c9\$41\$7b\$2d\$c0\$28\$60\$19\$06\$80\$70\$8d\$7d\$48\$20\$07\
\$81\$10\$18\$d5\$20\$04\$ec\$00\$8c\$fd\$66\$e9\$98\$1a\$01\$9f\
\$26\$25\$c0\$14\$9c\$2f\$98\$03\$0f\$fc\$d0\$cc\$dc\$dd\$08\$2c\
\$90\$21\$18\$06\$b0\$a0\$1e\$79\$60\$6d\$d6\$81\$9d\$03\$fd\$9e\
\$d6\$82\$88\$01\$b6\$62\$de\$07\$fb\$00\$1c\$47\$00\$6b\$03\$01\
\$91\$4b\$ff\$5a\$6e\$ab\$3b\$20\$06\$bd\$08\$2c\$2c\$01\$94\$00\
\$28\$b0\$1a\$0e\$06\$b0\$20\$06\$87\$02\$40\$ff\$f3\$66\$c0\$84\
\$3e\$64\$2a\$7a\$21\$9b\$a0\$00\$c0\$cb\$10\$ff\$f5\$a6\$9a\$ad\
\$be\$c0\$63\$08\$00\$12\$40\$35\$af\$c0\$e8\$c9\$03\$56\$0c\$0d\
\$31\$c0\$32\$c4\$80\$38\$c0\$19\$11\$60\$61\$c1\$85\$8f\$80\$30\
\$8f\$ff\$f5\$bb\$aa\$df\$6f\$17\$08\$f6\$06\$94\$88\$36\$3e\$1b\
\$78\$05\$0c\$14\$a1\$04\$0b\$2b\$25\$ce\$81\$ae\$28\$24\$a5\$70\
\$b9\$c0\$c0\$1f\$ff\$ff\$ff\$7f\$ff\$c3\$a4\$03\$0e\$0c\$0c\$08\
\$30\$1a\$06\$06\$80\$90\$0a\$00\$10\$00\$0c\$c9\$b0\$33\$a4\$c0\
\$b0\$30\$6d\$40\$6c\$80\$c1\$00\$34\$0d\$02\$2e\$5f\$70\$00\$6a\
\$01\$6a\$23\$6f\$fe\$ac\$8f\$f9\$98\$4f\$ff\$81\$ff\$f3\$66\$c0\
\$0e\$1d\$4a\$9b\$06\$7f\$c1\$a0\$00\$18\$7e\$c0\$61\$c1\$81\$be\
\$30\$28\$12\$aa\$53\$15\$bb\$cd\$52\$06\$dc\$13\$24\$ab\$35\$28\
\$97\$4d\$56\$62\$89\$aa\$57\$30\$1c\$e3\$64\$92\$49\$96\$8a\$28\
\$b2\$4a\$33\$3e\$74\$d5\$03\$22\$f4\$88\$93\$a4\$44\$8a\$97\$59\
\$12\$88\$b9\$cc\$4d\$4c\$8d\$9d\$03\$62\$91\$06\$36\$75\$22\$2b\
\$53\$1d\$66\$a3\$a4\$70\$9a\$ae\$a7\$55\$bf\$f4\$46\$74\$bc\$92\
\$49\$25\$d1\$fa\$df\$ff\$eb\$41\$27\$5a\$06\$ff\$ff\$2b\$ff\$f5\
\$80\$b8\$83\$56\$e0\$00\$44\$60\$c6\$3b\$45\$c6\$ab\$cc\$96\$7a\
\$c3\$58\$de\$26\$fe\$2d\$b8\$52\$63\$ef\$63\$a1\$24\$ff\$f3\$66\
\$c0\$1c\$18\$4b\$7a\$ce\$ec\$7c\$d4\$d8\$80\$ac\$43\$94\$5f\$e8\
\$a2\$80\$5f\$e2\$b5\$9b\$fd\$4d\$29\$08\$54\$d9\$05\$37\$f3\$23\
\$f5\$b2\$92\$73\$86\$a6\$44\$55\$47\$19\$82\$81\$4a\$7d\$fd\$85\
\$a1\$f7\$88\$e2\$d9\$df\$4f\$fe\$75\$d7\$e4\$63\$8f\$ff\$ff\$fe\
\$84\$d6\$ff\$ff\$fe\$83\$e7\$ff\$ff\$ff\$c4\$91\$37\$ff\$c8\$80\
\$a5\$54\$67\$80\$00\$00\$cc\$26\$49\$01\$81\$40\$83\$3b\$db\$5d\
\$34\$4e\$3d\$ee\$b3\$13\$57\$55\$66\$c6\$28\$1d\$14\$08\$0b\$dc\
\$04\$53\$42\$d8\$17\$52\$f6\$94\$48\$80\$a9\$3f\$fe\$a2\$f2\$44\
\$90\$29\$c2\$f8\$58\$39\$a2\$1f\$a9\$26\$ea\$52\$6a\$48\$ff\$f3\
\$66\$c0\$3e\$18\$9a\$2a\$b7\$04\$5d\$1a\$b4\$9a\$a7\$ac\$ba\$81\
\$2c\$75\$77\$e8\$f8\$fa\$4a\$f5\$92\$21\$c2\$53\$fd\$2f\$ff\$ea\
\$e3\$b4\$71\$3f\$ff\$d8\$a2\$bf\$f9\$52\$3f\$fe\$b3\$bf\$fd\$40\
\$73\$44\$78\$80\$00\$01\$93\$98\$42\$0e\$6e\$bf\$b7\$3c\$e3\$5d\
\$4d\$38\$60\$89\$c9\$48\$83\$13\$29\$11\$60\$f8\$40\$34\$2c\$06\
\$4f\$74\$01\$a6\$02\$c0\$61\$80\$00\$c7\$99\$2e\$ce\$a5\$13\$41\
\$8c\$8b\$5d\$1f\$d7\$93\$22\$95\$22\$a4\$44\$5b\$c0\$6c\$1d\$ea\
\$43\$ea\$5a\$15\$2c\$b6\$69\$62\$8b\$2f\$ac\$ba\$6a\$64\$6e\$64\
\$9e\$82\$1a\$8a\$c4\$db\$e8\$92\$a2\$3b\$10\$e6\$57\$ff\$ff\$ff\
\$f3\$66\$c0\$5f\$19\$f2\$2e\$9f\$00\$5d\$60\$b4\$a6\$d9\$88\$62\
\$93\$e7\$ff\$f8\$90\$96\$98\$8a\$90\$00\$04\$13\$78\$e2\$2d\$c6\
\$94\$d1\$62\$e1\$82\$36\$b3\$ac\$6e\$4b\$5d\$df\$7f\$fb\$bf\$c7\
\$19\$53\$58\$30\$32\$a3\$4f\$2e\$18\$83\$36\$b4\$53\$25\$01\$70\
\$38\$ce\$eb\$63\$94\$dc\$38\$e6\$53\$f3\$0e\$ff\$ff\$ff\$ff\$7d\
\$92\$49\$33\$51\$25\$24\$84\$98\$5e\$18\$73\$e5\$c6\$7f\$74\$d6\
\$cc\$c7\$51\$ab\$ea\$7a\$92\$9f\$a6\$82\$06\$2b\$43\$5a\$24\$80\
\$48\$c9\$77\$ff\$ff\$ff\$50\$54\$87\$21\$df\$fe\$54\$b9\$bb\$9c\
\$c0\$00\$04\$11\$66\$be\$9c\$56\$3c\$66\$f1\$5f\$ea\$d7\$f6\$89\
\$ff\$f3\$66\$c0\$7b\$19\$f2\$2e\$a7\$00\$7e\$da\$b4\$1a\$f5\$b2\
\$cf\$9f\$ff\$ff\$fa\$7f\$9d\$b6\$04\$2a\$14\$d0\$17\$35\$b4\$8c\
\$20\$b0\$c2\$8d\$a3\$b3\$7e\$c6\$9e\$25\$c6\$1c\$70\$cd\$06\$31\
\$2a\$cd\$8a\$90\$e4\$e5\$fc\$79\$6d\$5e\$ee\$ff\$f6\$cd\$38\$d0\
\$5c\$00\$c0\$04\$0e\$c3\$02\$5c\$c3\$19\$68\$ba\$2b\$73\$ee\$e6\
\$29\$e7\$9e\$7a\$22\$38\$e9\$73\$75\$53\$98\$03\$8c\$cf\$14\$10\
\$4f\$ff\$fe\$a0\$36\$82\$b1\$b8\$97\$48\$8b\$b0\$00\$06\$91\$4f\
\$30\$8d\$e6\$5f\$fe\$64\$5d\$38\$44\$d7\$9e\$94\$c6\$e7\$37\$ff\
\$ff\$ff\$f5\$72\$8c\$dc\$7e\$d9\$a1\$83\$8a\$15\$80\$3a\$ea\$6a\
\$ed\$ff\$f3\$66\$c0\$97\$1b\$6a\$3e\$ab\$00\$7e\$8e\$b4\$2d\$76\
\$94\$a1\$e8\$aa\$82\$c9\$38\$62\$63\$46\$12\$28\$6a\$70\$46\$8e\
\$da\$64\$0c\$c6\$bc\$8c\$02\$50\$62\$76\$d8\$64\$ea\$2f\$a2\$9a\
\$d3\$8e\$72\$15\$25\$15\$4a\$11\$b9\$9f\$ea\$61\$3b\$51\$48\$47\
\$a5\$05\$a1\$e9\$09\$31\$84\$af\$d1\$d4\$84\$dd\$47\$a1\$24\$45\
\$a2\$ff\$ff\$e7\$51\$c2\$72\$40\$75\$76\$69\$90\$00\$04\$60\$a9\
\$14\$11\$ad\$c8\$ea\$22\$61\$6d\$3a\$68\$ed\$a7\$73\$f8\$63\$ff\
\$ff\$ff\$72\$ac\$a6\$55\$02\$3e\$ab\$04\$e4\$af\$66\$c5\$49\$4d\
\$01\$bb\$31\$56\$94\$ed\$30\$b6\$40\$8c\$4f\$c0\$c0\$59\$96\$13\
\$98\$41\$ff\$f3\$66\$c0\$ad\$1c\$92\$3e\$9f\$00\$7e\$d4\$b4\$79\
\$b5\$4e\$98\$d3\$b1\$b0\$8b\$87\$07\$a8\$30\$a6\$81\$be\$04\$99\
\$41\$1c\$fb\$24\$b4\$14\$8d\$34\$92\$44\$87\$09\$b8\$82\$95\$d9\
\$ff\$69\$1a\$93\$7f\$5a\$27\$4c\$9d\$6a\$a0\$df\$a2\$b1\$d2\$33\
\$1a\$6f\$ff\$ff\$5a\$46\$c3\$4d\$40\$f6\$db\$e1\$40\$01\$f1\$0e\
\$8a\$89\$b1\$26\$0c\$88\$98\$bc\$8f\$7c\$2e\$70\$94\$bf\$85\$65\
\$4e\$74\$81\$9a\$1c\$27\$8d\$8b\$a3\$9a\$66\$70\$77\$13\$23\$a4\
\$d4\$4a\$22\$95\$24\$88\$30\$84\$63\$32\$2e\$21\$08\$40\$58\$68\
\$1a\$02\$20\$60\$12\$80\$11\$c0\$24\$58\$04\$39\$04\$88\$81\$85\
\$88\$06\$90\$ff\$f3\$66\$c0\$be\$1c\$da\$4a\$93\$00\$66\$e2\$b4\
\$20\$72\$85\$a2\$60\$8a\$1a\$37\$f4\$52\$91\$c2\$e6\$1c\$4c\$99\
\$06\$1a\$0b\$f6\$59\$75\$16\$4f\$fa\$27\$ba\$5a\$2f\$e9\$51\$38\
\$6c\$99\$44\$ac\$87\$ff\$fd\$68\$98\$a0\$3a\$4a\$e9\$80\$56\$08\
\$70\$88\$08\$80\$00\$00\$00\$00\$04\$46\$2c\$26\$18\$12\$07\$a7\
\$b2\$58\$62\$a5\$4e\$2b\$65\$5c\$aa\$6c\$89\$5a\$a6\$6a\$56\$20\
\$63\$2e\$32\$7c\$b2\$a2\$54\$d1\$12\$a9\$4c\$bd\$4a\$b2\$70\$4f\
\$84\$b8\$74\$45\$13\$eb\$28\$9b\$90\$64\$4c\$52\$78\$0b\$05\$03\
\$58\$d0\$0e\$31\$70\$b9\$92\$4a\$20\$80\$00\$9c\$03\$66\$4c\$36\
\$21\$a6\$6e\$3e\$ff\$f3\$66\$c0\$ce\$1d\$ca\$56\$8a\$61\$49\$a0\
\$00\$84\$a4\$23\$14\$51\$45\$69\$13\$44\$d1\$bd\$65\$c5\$32\$8a\
\$c6\$86\$6a\$49\$2a\$28\$cc\$9e\$9e\$7f\$28\$bd\$6e\$83\$6b\$45\
\$49\$25\$52\$52\$c9\$08\$8f\$d4\$34\$b4\$0b\$ac\$ee\$d9\$80\$f4\
\$c9\$d5\$fa\$96\$8f\$ff\$fd\$34\$d9\$6b\$41\$06\$7d\$34\$dd\$0d\
\$15\$24\$97\$a2\$8f\$ff\$ff\$ff\$98\$17\$0d\$09\$f3\$74\$d6\$5f\
\$37\$22\$85\$c6\$02\$19\$cb\$65\$40\$0c\$04\$04\$2a\$aa\$c6\$5f\
\$db\$aa\$a7\$55\$57\$8c\$db\$35\$ff\$0c\$b5\$0c\$2c\$74\$87\$20\
\$d4\$e2\$45\$69\$9a\$43\$90\$6a\$74\$c0\$2a\$00\$60\$16\$1e\$0e\
\$80\$04\$17\$07\$c7\$ff\$f3\$66\$c0\$da\$2b\$53\$be\$83\$07\$8f\
\$a0\$00\$35\$f0\$51\$d0\$1d\$07\$c7\$5a\$d3\$0b\$2e\$cc\$d7\$22\
\$a2\$b6\$48\$aa\$c3\$5a\$8a\$b6\$aa\$bc\$33\$53\$33\$6b\$50\$d5\
\$b7\$ff\$ff\$ff\$ff\$ff\$ff\$f0\$cd\$2a\$2a\$05\$05\$4b\$3c\$37\
\$c1\$a2\$c1\$df\$c1\$55\$86\$bf\$06\$94\$1d\$e4\$b1\$2f\$2c\$78\
\$44\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$ff\$f3\$66\$c0\$b0\$1a\$ba\$65\$e4\$01\
\$c3\$40\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$ff\$f3\$66\$c0\$c9\$00\$00\$02\$58\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$ff\$f3\$66\$c0\$ff\$00\$00\$02\
\$58\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$ff\$f3\$66\$c0\$ff\$00\$00\
\$02\$58\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$ff\$f3\$66\$c0\$ff\$00\
\$00\$02\$58\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$ff\$f3\$66\$c0\$ff\
\$00\$00\$02\$58\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$ff\$f3\$66\$c0\
\$ff\$00\$00\$02\$58\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$ff\$f3\$66\
\$c0\$ff\$00\$00\$02\$58\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$ff\$f3\
\$66\$c0\$ff\$00\$00\$02\$58\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$00\$ff\
\$f3\$66\$c0\$ff\$00\$00\$02\$58\$00\$00\$00\$00\$00\$00\$00\$00\
\$00\$00\$00\$00\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\
\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\
\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\
\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\
\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\
\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\
\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\
\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\
\$ff\$f3\$66\$c0\$ff\$00\$00\$02\$58\$00\$00\$00\$00\$00\$20\$00\
\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\
\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\
\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\
\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\
\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\
\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\
\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\
\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\$20\$00\
\$00";;

const midi_RFIDok=
"\$4d\$54\$68\$64\$00\$00\$00\$06\$00\$00\$00\$01\$01\$e0\$4d\$54\
\$72\$6b\$00\$00\$00\$42\$00\$ff\$03\$07\$52\$46\$49\$44\$6f\$6b\
\$31\$00\$ff\$51\$03\$07\$a1\$20\$00\$ff\$58\$04\$04\$02\$18\$08\
\$00\$c9\$00\$0b\$99\$43\$7f\$6b\$89\$43\$00\$03\$99\$4a\$79\$6a\
\$89\$4a\$00\$0d\$99\$51\$79\$6a\$89\$51\$00\$88\$49\$99\$18\$01\
\$45\$89\$18\$00\$00\$ff\$2f\$00";;

const chor_RFIDok=
"\$01\$01\$01\$01\$00\$01\$0e\$00\$07\$03\$00\$00\$ff\$00\$00\$00\
\$07\$02\$00\$00\$ff\$00\$00\$00\$07\$01\$00\$00\$ff\$00\$00\$01\
\$07\$03\$00\$00\$00\$00\$00\$00\$07\$02\$00\$00\$00\$00\$00\$00\
\$07\$01\$00\$00\$00\$00\$00\$01\$07\$04\$00\$00\$ff\$00\$00\$02\
\$07\$04\$00\$00\$00\$00\$00\$01\$07\$04\$00\$00\$ff\$00\$00\$02\
\$0a\$04";;
// end of file const_data.mtl //
// back to file STDIN, line 3120

var midilist;;

fun getmidilist=
	if midilist==nil then set midilist=
	{midi_1noteA4 midi_1noteB5 midi_1noteBb4 midi_1noteC5 midi_1noteE4 midi_1noteF4
	 midi_1noteF5 midi_1noteG5 midi_2notesC6C4 midi_2notesC6F5 midi_2notesD4A5
	 midi_2notesD4G4 midi_2notesD5G4 midi_2notesE5A5 midi_2notesE5C6 midi_2notesE5E4
	 midi_3notesA4G5G5 midi_3notesB5A5F5 midi_3notesB5D5C6 midi_3notesD4E4G4 midi_3notesE5A5C6
	 midi_3notesE5C6D5 midi_3notesE5D5A5 midi_3notesF5C6G5};
	midilist;;

fun controlsound s=
	wavstartlocal s::nil;
	0;;

// file button.mtl //
var buttonlast;;
var buttontime;;
var buttonevent;;
var buttonclicn;;

const BUTTON_CLIC=1;;
const BUTTON_DCLIC=2;;
const BUTTON_LCLIC=3;;
const BUTTON_DLCLIC=4;;
const T_DCLIC=500;;
const T_LCLIC=1500;;


fun buttonloop=
	let button2 -> b in
	if b!=buttonlast then
	(
		set buttonlast=b;
		if b then
		(
			if buttontime==nil then
			(
				set buttonclicn=1;
				set buttontime=time_ms
			)
			else
			(
				set buttonclicn=buttonclicn+1;
				set buttontime=time_ms
			)
		)
		else if buttontime!=nil then set buttontime=time_ms
	)
	else if (buttontime!=nil) then
	(
		if ((time_ms-buttontime)>=T_LCLIC) then
		(
			if buttonlast then set buttonevent=if buttonclicn==1 then BUTTON_LCLIC else BUTTON_DLCLIC;
			set buttontime=nil
		)
		else if ((time_ms-buttontime)>=T_DCLIC)&&!buttonlast then
		(
			set buttonevent=if buttonclicn==1 then BUTTON_CLIC else BUTTON_DCLIC;
			set buttontime=nil
		)
	);;

fun buttongetevent=
	let buttonevent -> ev in
	(
		set buttonevent=nil;
		ev
	);;

proto loop 0;;
fun buttoncheckevent=
	buttonloop;
	if buttonevent!=nil then loop;
	0;;
// end of file button.mtl //
// back to file STDIN, line 3137

// Pour le d√©veloppement, d√©commenter une des lignes ci-dessous.
// fun confGetServerUrl = "r.nabaztag.com/vl";;
// fun confGetServerUrl = "nabdev.violet.net/vl";; // debug
// fun confGetServerUrl = "192.168.1.11/vl";;

// fun confGetServerUrl = "objects-pp.nabaztag.com/vl";;

// URLs normales
fun configurl=strcatlist confGetServerUrl::"/locate.jsp?sn="::(webmac netMac)::"&h="::(itoa HARDWARE)::"&v="::(getBytecodeRevision)::nil;;
fun recordurl mode=strcatlist pingsrv::"/vl/record.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&h="::(itoa HARDWARE)::"&m="::(itoa mode)::nil;;
fun rfidurl tag=strcatlist pingsrv::"/vl/rfid.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&h="::(itoa HARDWARE)::"&t="::(webmac tag)::nil;;
fun interactifurl application = strcatlist pingsrv::"/vl/itmode.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&h="::(itoa HARDWARE)::"&a="::application::nil;;
fun sendmailxmppurl xmppdomain data = strcatlist pingsrv::"/vl/sendMailXMPP.jsp?m="::(webmac netMac)::"&d="::xmppdomain::"&r="::data::"&v="::(getBytecodeRevision)::nil;;
fun boshurl ip = strcatlist ip::"/http-bind"::nil;; 
//fun boshurl ip = strcatlist ip::":5281/http-bind"::nil;;  // DEBUG

// Construction des urls d'interactivitÈ
fun interactifurl_start application= strcatlist (interactifurl application)::"&st=start"::g_cookie::nil;;
fun interactifurl_btn application position cmdindex btn= strcatlist (interactifurl application)::"&st=btn&pos="::(itoa position)::"&idx="::(itoa cmdindex)::"&btn="::(itoa btn)::g_cookie::nil;;
fun interactifurl_done application = strcatlist (interactifurl application)::"&st=done"::g_cookie::nil;;
fun interactifurl_ear application position cmdindex earg eard = strcatlist (interactifurl application)::"&st=ear&pos="::(itoa position)::"&idx="::(itoa cmdindex)::"&el="::(itoa earg)::"&er="::(itoa eard)::g_cookie::nil;;
fun interactifurl_reco application position cmdindex = strcatlist (interactifurl application)::"&st=reco&pos="::(itoa position)::"&idx="::(itoa cmdindex)::g_cookie::nil;;
fun interactifurl_rfid application tag = strcatlist (interactifurl application)::"&st=rfid&t="::(webmac tag)::g_cookie::nil;;

fun runinit=
	set run=configstartRun;;


fun filterconfig_word s=
	let strstr s " " 0 -> i in
	if i!=nil then [strsub s 0 i strsub s i+1 nil]
	else [s nil];;

fun filterconfig_line s i=
	let strstr s "\10" i-> j in
	if j!=nil then (filterconfig_word strsub s i j-i)::filterconfig_line s j+1
	else if i<strlen s then (filterconfig_word strsub s i nil)::nil;;

fun filterconfig s i0=
	let strreplace s "\13" "" -> s in
	filterconfig_line s i0
;;

fun dump_prgm l=
	Progw "Program:";
	for l=l;l!=nil;tl l do let hd l->[key val] in (
		Progw strcatlist ( key :: " " :: (if (val != nil) then val else "") :: nil)
	);
	Secholn "---";
	l;;

		
fun _configcbhttp http res=
	if (nil != res) then
	(
		Secholn "config=";
		let filterconfig Secholn httpgetcontent res 0-> conf in
		(
			// http urls
			set pingsrv=listswitchstr conf "ping";
			set broadcasturl=listswitchstr conf "broad";

			/****** XMPP ****/
			let listswitchstr conf "xmpp_domain" -> xmpp_domain in
				if xmpp_domain != nil then
					XmppSessionStart xmpp_domain 1; // START 1 XMPP SESSION HERE (1 == Display Leds for connexion Details)

			set run = xmppLoginRun;
		
			0
		)
	)
	else
	(
		// l'appel ‡ locate.jsp a ÈchouÈ -> ... rebooter tout ?
		Secholn "call to locate.jsp failed, rebooting";
		reboot 0x0407FE58 0x13fb6754;
		0
	)
;;

var gConfigStart = 0;;
fun runconfigstart=
	if netState==RT2501_S_CONNECTED && wavrunning==0 then (
		set gConfigStart = time_ms;
		leds_set_state LEDS_STATE_CONFIG_WAIT ;
		set run=configwaitRun httprequest "GET" Secholn configurl nil #_configcbhttp HTTP_NORMAL
	);
	0;;

fun runconfigwait http=
	// check timeout and retry : cligne + ou - la led middle body toutes les secondes en bleu
	if ((httpinactive http) > STD_NET_TIMEOUT) then
	(
		Secholn "##timeout on configwait";
		httpabort http;
		set run=configstartRun
	);

	0;;

// Cryptage des trames
fun bintoi3 s x=((strget s x)<<16)+((strget s x+1)<<8)+(strget s x+2);;


/** aide pour la fonction pingextract juste en dessous */
fun pingextract_ s i res=
	if i<strlen s then
	let (strget s i)-> code in
	if code==255 then res
	else if code>=0 && code<=11 then
		let bintoi3 s i+1 -> len in
		if len>=0 then pingextract_ s i+4+len [code strsub s i+4 len]::res;;

/** parse la chaine s et renvoie une liste des commandes contenues dedans */
fun pingextract s=
	if (strget s 0)==0x7f then pingextract_ s 1 nil;;

// replace the prefix string "broadcast" (if present) by broadcasturl
fun rscfilterurl url=
	if 0==strstr url BROADCAST_KEYWORD 0 then strcat broadcasturl strsub url strlen BROADCAST_KEYWORD nil
	else url;;

fun rscFromProgram l=
	if l!=nil then let hd l->[key val] in
	if (!strcmp key "MU") || (!strcmp key "CH") then [val /*nil*/300000]::rscFromProgram tl l
	else if (!strcmp key "MC") then [val SIGNCUTSIZE]::rscFromProgram tl l
	else rscFromProgram tl l;;
	


var paletteselected = 0;;
// v17 (add romain)
// Fonction permettant d'activer la palette pour le programme en cours
// au jour du 31 mai 2007, on recoit le PL apres le son a jouer, la palette associee au son est donc affichee juste apres la fin du programme
// Cette fonction passe prealablement sur le programme reÁu pour mettre la bonne palette
// A noter, si il y a plusieurs palettes dans la trame de retour, seule la premiere est prise en compte
fun CheckForPaletteBefore l=
	for l=l;l!=nil;tl l do let hd l->[key val] in
	(
		if (!strcmp key "PL") && (paletteselected==0) then
		(
			set_current_palette_mode atoi val;
			set paletteselected = 1
		)
	);;

fun prgmStart=
	// Starts playing the program
	// setleds RGB_RED;
	
	// Si la palette est definie pour ce programme, alors on ne met pas l'aleatoire
	if(paletteselected==0) then (
		set current_palette=tabnew 0 8; // v17 : c'Ètait inversÈ
		set_current_palette_mode 8 // random palette par dÈfaut
	);
	// start evaluating first command
	set gCurAudioCmdIndex = -1;
	set run=cmdEvalOne 0;
	0;;


// ********** loading resources

// callback from rscLoadWaitRun : a resource has been loaded
fun _rscLoadCBhttp http res maxsize=
	if recording then
	(
		httpabort http;
		nil
	)
	else if res!=nil then
	(
		// received a result, store it in rsctmp
		// Je ne comprends pas la logique ici (AS sept07) : a quoi sert rsctmp et maxsize, et comment passe-t-il ‡ la suite ?
//		Secholn res;
		set rsctmp=res::rsctmp;
		if maxsize!=nil && (slistlen rsctmp)>maxsize then
		(
			// too big ? (?)
			httpabort http;
			_rscLoadCBhttp http nil nil
		);
		0
	)
	else
	(
		let hd rsctoget ->[url _] in
		// remember rsc loaded
		set rscloaded=[url tl rev rsctmp nil]::rscloaded;
		
		// load next rsc
		set rsctoget=tl rsctoget;
		set run=rscLoadNextRun;
		0
	);;

// Recursive : loads all needed resources of the list 'rsctoget' and then starts current program
fun runRscLoadNext=
	let hd rsctoget -> [url maxsize] in
	if url==nil then
	(
		// nothing (else) to load : start execute msgs now
		Secholn "rsrcs loaded, starting prgm";
		prgmStart;
		0
	)
	else if nil!=listswitchstr rscloaded url then
	(
		// already loaded : load next
		set rsctoget=tl rsctoget;
		runRscLoadNext
	)
	else
	(
		// load resource
		set rsctmp=nil;
		Secho "loading ";
		set run=rscLoadWaitRun httprequest "GET" Secholn (rscfilterurl url) nil (fixarg3 #_rscLoadCBhttp maxsize) HTTP_STREAM;
		0
	);;

fun runRscLoadWait http=
	// wait for loading resource
	if (httpinactive http)>STD_NET_TIMEOUT then
	(
		Secholn "##timeout in runRscLoadWait";
		httpabort http;
		// skip, load next
		set rsctoget=tl rsctoget;
		set run=rscLoadNextRun
	);
	0;;


/**
	Called when a program has to end.
	If doNotNotify is set (!=0) then the server is not notified of the end of the program
*/
fun endOfProgram doNotNotify =
	Secholn "endOfProgram";
	set gProcessingState = 0;
	set gProcessingWaitState = 0; // just in case
	set gCurrentProgram = nil;
	if (gItState && !doNotNotify) then (
		// notifier fini
		interactivePrgmDone
	) else (
		// retour normal
		set run = idleRun;
		0
	);
	0;;

var recordtimestart;;
var recordmode;;
var recorddata;;
var recordreq;;
var recordretry;;
var recordplayend;;

fun uploading = recordreq!=nil;;

fun runrecordstart=
	// wait for the end of the starting sound
	if !wavrunning then
	(
	led LED_NOSE RGB_RED;//if time_ms&64 then RGB_RED else 0;
//		setleds RGB_BLACK;
		unforcevol;
		recstart;
		set recordtimestart=time_ms;
		set run=recordRun
	);;

fun _controlrecord mode=
	setleds RGB_BLACK;
	wavstop;
	motorset 0 0;
	motorset 1 0;
	forcevol 64;
	wavstartlocalEx mp3_startrecord::nil 100;
	set recordmode=mode;
	set run=recordStartRun;
	0;;

fun _cbrecordhttp http res=
	// record upload done
	set recorddata=nil;
	set recordreq=nil;
	Secholn res;
	setleds RGB_BLACK;
	if recordplayend!=nil then
	(
		set recordplayend=nil;
		wavstartlocal midi_endrecord::nil
	);
	set run=idleRun;
	0;;

fun uploadtimeout=
	if uploading then
	(
		if recordplayend!=nil && ((recordplayend-time_ms)<0) then
		(
			set recordplayend=nil;
			wavstartlocal midi_endrecord::nil
		);
		if (httpinactive recordreq)>STD_NET_TIMEOUT then
		(
			Secholn "##timeout on upload";
			httpabort recordreq;
			set recordreq=nil;
			if recordretry>0 then
			(
				// retry
				set recordretry=recordretry-1;
				if (!gItState) then (
					set recordreq=httprequest "POST" Secholn recordurl recordmode recorddata #_cbrecordhttp HTTP_NORMAL;0
				) else (
					interactiveSendUpload
				);
				nil
			)
			else
			(
				// abort
				set recorddata=nil;
				if (!gItState) then (
					set run=idleRun;0
				) else (
					interactiveError
				)
			)
		)
	);;

const AskR = 0;; // v18
const RecordingTime = 8000;; // v18

fun runrecord=
//	led LED_NOSE if time_ms&1024 then RGB_RED else RGB_BLACK;
	if !button2 || ((time_ms-recordtimestart)>8000)then
	(
		recstop;
		setleds RGB_BLACK;
		let recriff -> wavfile in
		(
			set recorddata=strcatlist wavfile;
			set recordretry=3;
			set recordplayend=time_ms+400;
			if (!gItState) then (
				set recordreq=httprequest "POST" Secholn recordurl recordmode recorddata #_cbrecordhttp HTTP_NORMAL;
				set run=idleRun;0
			) else (
				interactiveSendUpload
			)
		)
	);;

// ************************* Choregraphies (TaiChi, .chor) ************
var chordata;;
var chorindex;;
var chortimescale;;
var chornexttime;;
var chorrandom;;
var chortaichimotordir;; // le moteur // v16
var chorendcb=nil;; // the callback to call in the end of the chor
var chor_paused_dur;; // can be paused during buffering
var chor_paused;;
var chor_paused_since;;

fun msgchorstart chor cb i0=
	set chorendcb = cb;
	set chordata=strcatlist chor;
	set chorindex=4+1;	// on saute le header et la premiËre attente
	set chortimescale=0;
	set chornexttime=time_ms;
	set chor_paused_dur = 0;
	set chor_paused_since = nil;
	set chor_paused= 0;
	setleds RGB_BLACK; // shut off all leds at start (or should it be in the chor ?)
	set run=chorCmdRun i0;
	0;;

fun msgendchor i0=
	set chornexttime=nil;
	// call the callback
	if (chorendcb != nil) then call chorendcb [i0];
	0;;

fun runChorCmd i0=
	//	Secho "runChorCmd i:";Iecho chorindex; Secho " t:";Iecholn chornexttime;
	// Manage buffering and pauses
	
	if (!chor_paused && wav_buffering) then (
		// start pause
		set chor_paused_since = time_ms;
		set chor_paused = 1
	) else if (chor_paused && !wav_buffering) then (
		// end pause
		set chor_paused = 0;
		// increment paused_dur
		set chor_paused_dur = chor_paused_dur + (time_ms - chor_paused_since)
	);
	
	if (!chor_paused) then
	if time_ms-chor_paused_dur >= chornexttime then
	(
		if chorindex>=strlen chordata then msgendchor i0
		else let strget chordata chorindex -> code in
		set chorindex=chorindex+2+
		if code==CH_frame_duration then
		(
			set chortimescale=10*strget chordata chorindex+1;
			1	//nb de paramËtres
		)
		else if code==CH_set_motor then
		(
			earGo (strget chordata chorindex+1) (strget chordata chorindex+2) (strget chordata chorindex+3);
			3
		)
		else if code==CH_set_led_color then
		(
//			Secho "set_led_color ";
			//led 4-strget chordata chorindex+1 ((strget chordata chorindex+2)<<16)+((strget chordata chorindex+3)<<8)+(strget chordata chorindex+4); // v16 start
			let 4-strget chordata chorindex+1 -> iled in
			let strget chordata chorindex+2 -> ired in
			let strget chordata chorindex+3 -> igreen in
			let strget chordata chorindex+4 -> iblue in
			(
				//Iecho iled; Secho ",r=";Iecho ired; Secho ",g=";Iecho igreen; Secho ",b=";Iecho iblue; Secholn ".";
				led iled (ired<<16)+(igreen<<8)+iblue
			); // v16 end
			6
		)
		else if code==CH_set_leds_color then // v16 start
		(
			//Secho "set_leds_color ";
			let strget chordata chorindex+1 -> ired in
			let strget chordata chorindex+2 -> igreen in
			let strget chordata chorindex+3 -> iblue in
			let (ired<<16)+(igreen<<8)+iblue -> col in
			(
				//Secho "leds "; Secho ",r=";Iecho ired; Secho ",g=";Iecho igreen; Secho ",b=";Iecho iblue; Secholn ".";
				setleds col
			);
			3
		) // v16 end
		else if code==CH_set_led_palette then
		(
//			Secholn "set_led_palette ";
			led 4-strget chordata chorindex+1 current_palette.(7&strget chordata chorindex+2);
			2
		)
		// v17
		else if code== CH_set_led_off then 
		(
			//Secholn "CH_set_led_off ";
			led 4-strget chordata chorindex+1 0;
			1
		)
		else if code==CH_randmidi then
		(
			//Secholn "randmidi";
			let getmidilist -> t in
			let tablen t -> n in
			if n>0 then
			let ((rand&255)*n)>>8 -> imusic in // v16 start
			let t.(imusic) -> music in
			(
				Secho "randmidi="; Iecholn imusic;
				wavstartlocal music::nil
			); // v16 end
			0
		)
		else if code==CH_avance then
		(
			//Secholn "avance";
			let (strget chordata chorindex+1) -> motor in // v16 start
			let (strget chordata chorindex+2) -> delta in
			let chortaichimotordir.motor -> dir in
			earGo motor (earTarget motor)+if dir then -delta else delta dir;
			2
		)
		else if code==CH_setmotordir then
		(
			//Secholn "setmotordir";
			let (strget chordata chorindex+1) -> motor in
			let (strget chordata chorindex+2) -> dir in
			set chortaichimotordir=
			if  motor == 0 then {dir chortaichimotordir.1} else {chortaichimotordir.0 dir}; // v16 end
			2
		)
		else if code==CH_ifne then
		(
			//Secho "ifne ";Iecholn chorrandom;
			if chorrandom==(Iecholn strget chordata chorindex+1) then 3
			else 3+((strget chordata chorindex+2)<<8)+(strget chordata chorindex+3)
		)
		else if code==CH_attend then
		(
			//Secholn "attend";
			if earFinishedMoving && wavrunning==0 then 0
			else -2
		)
		else
		(
			msgendchor i0;
			0
		);
		if chornexttime!=nil then
		(
			set chornexttime=chornexttime+(strget chordata chorindex-1)*chortimescale;
			runChorCmd i0
		)
	);;

fun _cbtaichiend unused=
	set gProcessingState = 0;
	earSetWaitAndDetectMode;
	set run=idleRun;
	0
	;;
	
fun taichistart=
	Secho "taichistart ";
	
	set chorrandom=((Iecholn rand&255)*30)>>8;
	Secho "chorrandom="; Iecholn chorrandom;
	set chortaichimotordir={0 0};

	earSetWaitOnlyMode;
	set gProcessingState = 1; // block all trames during taichi
	msgchorstart chordef_taichi::nil #_cbtaichiend nil;
	0;;


// **********************
// Interactivity
// **********************

var gInteractiveLastWavBytes = 0;;
type gInteractiveSoundsType = intDefaultStart | intDefaultStop | intNone;;
type gInteractiveChorType = intchorDefaultStart | intchorDefaultStop | intchorStartNone | intchorStopNone;;
var gInteractiveSounds;;
var gInteractiveChors;;

// quand on a reÁu une commande "WT", on stocke ici la date jusqu'‡ laquelle on doit attendre
var interactiveWaitEndTime_ms = 0;;

proto _cbContinueStartInteractive 1;;
proto _cbContinueStopInteractive 1;;
proto _cbContinueErrorInteractive 1;;

proto evalTrame 1;;

// Play a start or stop sound
fun gIntControlSound Type =
	match Type with
	(intDefaultStart ->		controlsound midi_startInteractive )	// On joue le son par defaut
	| (intDefaultStop ->	controlsound midi_endInteractive )		// On joue le son par defaut
	| (intNone -> 			nil)									// On ne joue pas de son
	| (_ -> Secholn "No Sound to Play!!"; nil );					// Si on a indique un mauvais son, on ne joue rien
	0
;;

// Play a start or stop chor
fun gIntControlChor Type =
	match Type with
	(intchorDefaultStart ->		msgchorstart chordef_startInteractive::nil #_cbContinueStartInteractive nil )		// On joue le chor par defaut
	| (intchorDefaultStop ->	msgchorstart chordef_startInteractive::nil #_cbContinueStopInteractive nil )		// On joue le chor par defaut
	| (intchorStartNone -> 		_cbContinueStartInteractive nil )													// On ne joue pas de chor
	| (intchorStopNone ->		_cbContinueStopInteractive nil )													// On ne joue pas de chor
	| (_ -> Secholn "No Chor to Play!!"; nil );					// Si on a indique un mauvais chor, on ne joue rien
	0
;;

// Starts interactivity : sets run mode, remember application and request commands
fun interactiveStart application=

	set gItState = 1;
	set gItApp = application;
	if !gBusyState then XmppSessionRequestResource "itmode";

	reset_IC;
		
	// oreilles vers l'avant
	(earGo 0 3 0; earGo 1 3 0);
	
	// jingle
	let gInteractiveSounds -> [gSoundStart gSoundStop] in
		gIntControlSound gSoundStart;
	
	// chor de debut
	let gInteractiveChors -> [gChorStart gChorStop] in
		gIntControlChor gChorStart;

	0;;

fun _cbContinueStartInteractive unused=
	
	// ask for instructions
	set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_start gItApp) nil #_interactiveReqCBhttp HTTP_NORMAL);
		
	0;;

fun interactiveError=
	// jingle error
	Secho "interactiveError";
	msgchorstart chordef_interactiveerror::nil #_cbContinueErrorInteractive nil;
	0;;

fun _cbContinueErrorInteractive unused=
	interactiveStop;
	0;;
	
fun interactiveStop=
	Secholn "interactiveStop";
	
	// jingle de fin
	let gInteractiveSounds -> [gSoundStart gSoundStop] in
		gIntControlSound gSoundStop;
	set gInteractiveSounds = [intDefaultStart intDefaultStop]; // on remet le son par default a la fin
	
	// chor de fin
	let gInteractiveChors -> [gChorStart gChorStop] in
		gIntControlChor gChorStop;
	set gInteractiveChors = [intchorDefaultStart intchorDefaultStop]; // on remet le chor par default a la fin
	
	// oreilles
	earsGoToRefPos;

	// clean
	set g_cookie="";
	0;;

fun _cbContinueStopInteractive unused=
	// finalise stopping itMode
	set gItApp = nil;
	set gItState = 0;
	set gProcessingState = 0; // skips all remaining commands anyway, so : not processing
	//if !gBusyState then XmppSessionRequestResource "idle"; // can only be idle now 
	// DEBUG
	XmppSessionRequestResource "idle"; // Obligation de revenir en IDLE
	set gStreamingState = 0; // On ne stream plus rien!
	set run = idleRun;
	0;;

fun interactiveSendBtn btn=
	Xw "Inside interactiveSendBtn";
	wavstop;
	earStop 0;
	let wav_curplayedbytes -> readBytes in ( // controlsound resets wav_curplayedbytes so we cache it
		// sound
		if (btn == BUTTON_CLIC) then (
			if (!strcmp g_snd_btn_1 "clonk") then controlsound midi_abort
			else if (!strcmp g_snd_btn_1"chord") then controlsound midi_ack
			else if (!strcmp g_snd_btn_1 "neutral") then controlsound midi_ministop;
			0
		) else if (btn == BUTTON_DCLIC) then (
			if (!strcmp g_snd_btn_2 "clonk") then controlsound midi_abort
			else if (!strcmp g_snd_btn_2 "chord") then controlsound midi_ack
			else if (!strcmp g_snd_btn_2 "neutral") then controlsound midi_ministop;
			0
		);
		// request instructions
		set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_btn gItApp readBytes gCurAudioCmdIndex btn) nil #_interactiveReqCBhttp HTTP_NORMAL)
	);
	0;;

fun interactivePrgmDone=
	set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_done gItApp) nil #_interactiveReqCBhttp HTTP_NORMAL);
	0;;

/**
	Calls the server to tell a rfid tag has been seen
*/
fun interactiveSendRfid tag =
	wavstop;
	earStop 0;
	set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_rfid gItApp tag) nil #_interactiveReqCBhttp HTTP_NORMAL);
	0;;

//*******************
// Ears turned
//*******************
type EarTouch=[num_ET refPos_ET moveDir_ET lastDV_ET lastMoveTime_ET turned_ET];;
var earsTouch;;
const EAR_TOUCH_TIMEOUT=1000;;

fun interactiveResetEarsTouched=
	set earsTouch=tabnew nil 2;
	for i=0;i<2 do set earsTouch.i=[num_ET:i];
	for i=0;i<2 do let earsTouch.i -> et in
	(
		set et.refPos_ET = -1;
		set et.moveDir_ET = -1;
		set et.lastDV_ET = -1;
		set et.lastMoveTime_ET = -1;
		set et.turned_ET = 0
	);
	0;;

fun earDeltaPosNormalized deltaPos=
	// between -EARS_HOLES>>1 and EARS_HOLES>>1
	if (deltaPos > EARS_HOLES>>1) then deltaPos - EARS_HOLES
	else if (deltaPos < -EARS_HOLES>>1) then deltaPos + EARS_HOLES
	else deltaPos;;
	
fun itNoteEarTouched eari curPos deltaPos=
	// right = 0, left = 1
	if (eari == 0 && (g_int_mask & MASK_EAR_RIGHT == 0)) || (eari == 1 && (g_int_mask & MASK_EAR_LEFT == 0)) then // active
	let earsTouch.eari -> et in
	(
		set et.lastMoveTime_ET = time_ms;
		if (et.refPos_ET == -1) then (
			// first move : remember position and direction of movement
			set et.refPos_ET = curPos;
			if ((earDeltaPosNormalized deltaPos) > 0) then set et.moveDir_ET = 0 else set et.moveDir_ET = 1;
			set et.lastDV_ET = 0
			
		) else if !et.turned_ET then
		// was already moving and not turned yet : test turned
		let (earDeltaPosNormalized (curPos - et.refPos_ET)) -> normalizedDV in (
			Secho "NDV="; Iecho normalizedDV; Secho ",";
			
			// Test 1 tour or stopped
			if (et.moveDir_ET == 0 && normalizedDV >= 0 && et.lastDV_ET < 0) then
				// if more than one tour forward : ok
				set et.turned_ET = 1
			else if (et.moveDir_ET == 1 && normalizedDV <= 0 && et.lastDV_ET > 0) then
				// if more than one tour backward : ok
				set et.turned_ET = 1;
	
			Secho "TOUCH="; Iecho et.turned_ET; Secho ",";
				
			set et.lastDV_ET = normalizedDV
		)
	);;

fun touchedP i=
	let earsTouch.i -> et in (et.turned_ET || ((et.lastMoveTime_ET != -1) && ((/*Secho "DLAST="; Iecho */(time_ms - et.lastMoveTime_ET))> EAR_TOUCH_TIMEOUT)))
;;

fun interactiveSendEarTouched lefttouch righttouch=
	// right = 0, left = 1
	wavstop;
	earStop 0;
	let wav_curplayedbytes -> readBytes in  // controlsound resets wav_curplayedbytes so we cache it
	(
		if (lefttouch) then controlsound midi_precedent;
		if (righttouch) then controlsound midi_suivant;		
		set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_ear gItApp readBytes gCurAudioCmdIndex righttouch lefttouch) nil #_interactiveReqCBhttp HTTP_NORMAL)
	);
	0;;

fun interactiveEarProcessTouched=
	if (gItState) then
	let touchedP 0 -> lefttouch in
	let touchedP 1 -> righttouch in
	if (lefttouch || righttouch) then (
		interactiveSendEarTouched lefttouch righttouch;
		interactiveResetEarsTouched
	);;

fun interactiveSendUpload=
	set recordreq = httprequest "POST" (interactifurl_reco gItApp gInteractiveLastWavBytes gCurAudioCmdIndex) recorddata #_interactiveReqCBhttp HTTP_NORMAL;
	set run=interactiveReqWaitRun recordreq;
	0;;


proto zeroRFIDchek 0;;

// Interactive request answer
fun _interactiveReqCBhttp http res=
	Secholn "_interactiveReqCBhttp=";

	if (uploading) then (
		// mode upload / record
		set recorddata=nil;
		set recordreq=nil;
		Secholn res;
		setleds RGB_BLACK
	);

	// if the request was a rfid one...
	zeroRFIDchek;

	if !recording then
	let httpgetcontent res -> ping_trame in
		evalTrame ping_trame;

	0;;

// Interactive request wait : timeout
fun runInteractiveReqWait http=
	// Waiting for interactive request
	// check timeout
	if (!uploading) then // upload record mode : timeout managed by uploadtimeout
	if (httpinactive http)>STD_NET_TIMEOUT then
	(
		Secholn "##timeout on runInteractiveReqWait";
		httpabort http;
		
		// error
		interactiveError
	);

	0;;

// ********************************
// interactive settings
// ********************************

/**
	Called when entering interactive state (command "IC" in a program)
*/
fun reset_IC=
	set g_streaming_chor_enabled=1;
	set g_int_mask=0;
	set g_snd_btn_1 = "clonk";
	set g_snd_btn_2 = "chord";
	set g_record_enabled = 1;
	0;;

fun eval_IC_msg val=
	// parse val : ickey=icval
	let strstr val "=" 0 -> icpos in
	if icpos != nil && icpos > 0 && icpos < (strlen val) - 1 then
	 // present, not first, not last
		let strsub val 0 icpos -> ickey in
		let strsub val icpos+1 ((strlen val) -1-icpos) -> icval in
		(
			if !strcmp ickey "snd.btn.1" then (
				// snd.btn.1                -> son du bouton en cas de pression courte.
				set g_snd_btn_1 = icval;
				0
			) else if !strcmp ickey "snd.btn.2" then (
				// snd.btn.2                -> son du bouton en cas de double click.
				set g_snd_btn_2 = icval;
				0
			) else if !strcmp ickey "snd.itmode" then (
				// snd.itmode                -> son debut et fin du mode interactif.
				if		!strcmp icval "default"		then set gInteractiveSounds = [intDefaultStart intDefaultStop]
				else if !strcmp icval "none"		then set gInteractiveSounds = [intNone intNone];
				0
			) else if !strcmp ickey "chor.itmode" then (
				// chor.itmode                -> chor debut et fin du mode interactif.
				if		!strcmp icval "default"		then set gInteractiveChors = [intchorDefaultStart intchorDefaultStop]
				else if !strcmp icval "none"		then set gInteractiveChors = [intchorStartNone intchorStopNone];
				0
			) else if !strcmp ickey "record.enabled" then (
				// record.enabled   -> activation de l'enregistrement
				if (!strcmp icval "true") then set g_record_enabled = 1
				else set g_record_enabled = 0;
				0
			) else if !strcmp ickey "streaming.chor.enabled" then (
				// streaming.chor.enabled   -> chorÈgraphie de streaming (oreilles)
				if (!strcmp icval "true") then set g_streaming_chor_enabled = 1
				else set g_streaming_chor_enabled = 0;
				0
			
			) else if !strcmp ickey "int.mask" then (
				// int.mask -> masque d'interruption pour le mode interactif
				set g_int_mask = (atoi icval);
				0
			
			) else if !strcmp ickey "cookie" then (
				// cookie -> cookie envoyÈ au serveur
				set g_cookie = strcatlist "&c="::icval::nil;
				0
			) else (
				0
			)
		);;


// ****************************************
// ExÈcution des chorÈgraphies de streaming
// v17 - AS 25may07

// - 4 pas de danse fournis (dans chorstream_chorslist)
// - une sÈquence :
// 	- une fois sur chorst_oreille_chance, bouger les oreilles :
// 		- pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 4, 8, 12 dents) et, si elle est diffÈrente de la position courante, y aller, dans le sens 'vers l'avant'.
// 	- tirer un pas de danse au hasard (parmi les 4 fournis)
// 	- tirer un nombre de boucles N au hasard entre 3 et 20 (inclus)
// 	- tirer un frame_duration au hasard entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
// or les pas durent de 44 ‡ 71 frames, donc le pas dure de 7 ‡ 17 secs,
// donc la sÈquence dure de 21s ‡ 5m40s
// 	-> jouer le pas de danse N fois ‡ ce tempo, puis nouvelle sÈquence
// A chaque pas de danse : tirer 3 couleurs au hazard dans la palette courante : tete, ventre, pied
// Si palette alÈatoire : la changer ‡ toutes les sÈquences
// sinon, fixÈe par le serveur.
// 
var chorst_pasdedanse;;
var chorst_index;;
var chorst_tempo;;
var chorst_loops;;
var chorst_nexttime;;
var chorst_palettecolors = {0 0 0};;

// v17 AS 25may07 : ratio entre changt de sÈquence et mvt d'oreille. Plus c'est grand moins souvent les moteurs joueront.
// = 0 : ‡ chaque chgt de seq (en myenne toutes les 2,5 minutes)
// = 1 : une fois sur 2 (soit en moyenne ttes les 5 minutes)
// = 2 : une fois sur 3 (soit en moyenne ttes les 7,5 minutes), etc...
var chorst_oreille_chance;; 

// mouvement des leds et oreilles
fun dochorstream=
	if chorst_pasdedanse==nil || ((chorst_index>=strlen chorst_pasdedanse)&&(chorst_loops<1)) then
	(
		// nouvelle sÈquence
		// Secho "Sequence suivante ";

		// ears enabled ?
		if (g_streaming_chor_enabled) then 
		(
		// movements moteur
		// toutes les chorst_oreille_chance fois en moyenne
		// et aussi la premiËre fois forcÈment histoire de montrer qu'on commence
		if (chorst_pasdedanse == nil) then
		(
			// une des oreilles en haut, une autre en bas : radio...
			if ((random 2) == 1) then (earGo 0 0 0; earGo 1 10 0) else (earGo 0 10 0; earGo 1 0 0);
			
			// initialisation chorst_oreille_chance
			set chorst_oreille_chance = 0

		) else if ((random chorst_oreille_chance) == 0) then
		(
			// pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 5, 10, 14 dents) et, si elle est diffÈrente de la position courante, y aller, dans le sens 'vers l'avant'.
			let 0::5::10::14::nil -> ear4Positions in
			(
				let listnth ear4Positions rand&3 -> p in earGo 0 p 0;
				let listnth ear4Positions rand&3 -> p in earGo 1 p 0
			);
			
			// de moins en moins souvent, puis de nouveau souvent, etc..
			if ((set chorst_oreille_chance = chorst_oreille_chance + 1) > 4) then set chorst_oreille_chance = 0
		)
		);
		
		// choix d'une sÈquence = pas de danse (chorst_pasdedanse), tempo et nb de boucles
		set chorst_pasdedanse = listnth chorstream_chorslist Iecholn rand&3;

		set chorst_index=4+1; // on saute le header (4 bytes)
		set chorst_tempo=160+random 90; // entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
		//Secho "tempo "; Iecholn chorst_tempo;
		set chorst_loops=3+random 18; // entre 3 et 20 (inclus)
		//Secho "loops "; Iecholn chorst_loops;
		
		if (current_palette_is_random) then
			// changer palette courante
			set_current_palette random 7;
		
		// choisir 3 couleurs au hasard dans la palette
		set chorst_palettecolors={(random 7) (random 7) (random 7)};
		
		set chorst_nexttime=time_ms
		
	);
	
	// continuer ‡ jouer
	while (chorst_index < strlen chorst_pasdedanse) && time_ms >= chorst_nexttime do
	(
		// interprËte la choragraphie. Uniquement des set_led_palette et des set_led_off et des set_led_color
		
		let strget chorst_pasdedanse chorst_index -> cmd in		
			// avance l'index de...
			set chorst_index=chorst_index+2+
				if (cmd == CH_set_led_palette) then
				(
					// palette index
					let strget chorst_pasdedanse chorst_index+1 -> iled in
					let strget chorst_pasdedanse chorst_index+2 -> icol in
					let chorst_palettecolors.(3&icol) -> palcol in
						// jouer la LED						
						led iled current_palette.palcol;

					// 2 bytes : led, color
					2
				)
				else if (cmd == CH_set_led_off) then
				(
					// off
					let strget chorst_pasdedanse chorst_index+1 -> iled in
						led iled 0;
						
					// 1 byte : led
					1
				)
				else if (cmd == CH_set_led_color) then
				(
					led strget chorst_pasdedanse chorst_index+1
						((strget chorst_pasdedanse chorst_index+2)<<16) + 
						((strget chorst_pasdedanse chorst_index+3)<<8) + 
						((strget chorst_pasdedanse chorst_index+4));
						
						// 6 bytes : 2 qui ne servent ‡ rien
						6
				)
				else if (cmd==CH_frame_duration) then
				(
					// on ne le prend pas en compte : c'est chorst_tempo qui gËre le tempo
					// 1 byte : duree
					1
				)

				else (
					// problËme : commande inconnue : forcer ‡ recommencer au dÈbut en incrÈmentant beaucoup trop
					Streamw strcatlist "dochorstream : unknown command, restarting dance" :: (itoa cmd) :: nil;
					strlen chorst_pasdedanse
				);			
		
		// pas de danse fini ?
		if (chorst_index>=strlen chorst_pasdedanse) then
		(
			// on est arrivÈs au bout du pas de danse
			// next repeat
			set chorst_loops=chorst_loops-1;
			//Secho "loops "; Iecholn chorst_loops;
			if (chorst_loops > 0) then
			(
				// recommencer pas de danse
				set chorst_index=4+1;  // on saute le header (4 bytes)
				// tout de suite
				set chorst_nexttime=time_ms;				
				
				0 // pour avoir le mÍme type de return value que les autres branches du if...

			) // sinon on laisse chorst_loops = 0 et chorst_index trop loin, ce qui force un passage ‡ la sÈq suivante
			
		) else 
			// date de la prochaine commande
			// note : on repart de time_ms, histoire de se caler sur le temps prÈsent et non pas sur le temps de
			// la chorÈgraphie, sinon, on a des coups de speed car cette fonction n'est pas toujours appelÈe de maniËre rÈguliËre.
			let strget chorst_pasdedanse chorst_index-1 -> delay in
				set chorst_nexttime = time_ms+delay*chorst_tempo
		
	);
	
	0;;

// boucle principale de la chorÈgraphie de streaming
fun stopStream=
  Streamw "stopStream";
	// oreilles
	earsGoToRefPos;

	set gStreamingState = 0;
	// which resource now ? Can only be interactive or idle
	if (!gBusyState) then ( // don't get a resource if we're busy
    Streamw strcatlist "not busy. gItState : " :: (if (gItState) then "true" else "false") :: nil ;
		if (gItState) then XmppSessionRequestResource "itmode"
		else XmppSessionRequestResource "idle"
	)
	
	;;

fun runStreamingCmd i0=
	if wavrunning==0 then (
		// Fin du stream
		stopStream;
		// next command
		set run=cmdEvalOne i0+1;
			
		nil
	) else (
		// execute streaming choreography
		if !wav_buffering then dochorstream;

		0
	);;


fun _cbGotoNextCmd i0=
	set run=cmdEvalOne i0+1;
	0;;

fun _cbWavError=
	Streamw "_cbWavError";
	if (gItState) then interactiveError;
	0;;


/**
	quand on a rencontre une instruction "WT" dans un programme, qui demandait
  d'attendre <n> millisecondes avant de continuer le programme
*/
fun runWaitCmd i0 =
	if (time_ms > interactiveWaitEndTime_ms) then
	(
		Xw "runWaitCmd";
		set gProcessingWaitState = 1;
		set run=cmdEvalOne i0+1
	)
;;

//********************************************************
// Executes the i0'th command in the 'gCurrentProgram' program
// a command is a list [key val]
fun runEvalOneCommand i0=
//	Secho "runEvalOneCommand ";Iecholn i0;
	interactiveResetEarsTouched;
		
	let listnth gCurrentProgram i0 -> [key val] in
	if (/* Secho "eval cmd:";Secholn */ key)==nil then
	(
		// toutes commandes jouÈes : demander la suite
		endOfProgram 0;
		0
	)
	else if (!strcmp key "MU") || (!strcmp key "MC") then
	(
		Secho "exec "; Secho key; Secholn " : start music";
		set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
		let listswitchstr rscloaded Secholn val -> music in
			if music==nil then Secholn "###nilmusic";
		wavstartlocal listswitchstr rscloaded val;
		set run=cmdEvalOne i0+1;
		0
	)
	else if !strcmp key "ST" then
	(
		Secholn "exec ST : Start streaming";
		//IPecho netdns 0 1;
		//startdnsclient;
		set gStreamingState = 1;
		setleds 0;
		if !gBusyState then XmppSessionRequestResource "streaming";
		set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
		set gCurStreamName= nil;
		set chorst_pasdedanse=nil;
		let rscfilterurl val -> music in wavstarthttp music #_cbWavError;
		set run=streamCmdRun i0;
		0
	)
	else if !strcmp key "SP" then
	(
		Secholn "exec SP : Start streaming (protected)";
		//IPecho netdns 0 1;
		//startdnsclient;
		set gStreamingState = 1;
		setleds 0;
		if !gBusyState then XmppSessionRequestResource "streaming";
		set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
		set gCurStreamName= nil;
		set chorst_pasdedanse=nil;
		// Romain
		let rscfilterurl val -> music in (
			set music = strcatlist music::"&sn="::(webmac netMac)::nil;
			let music -> tmpval in (
				set tmpval = md5(strcatlist music::"teloiv"::nil);
				set music = strcatlist music::"&cs="::tmpval::nil
			);
			wavstarthttp music #_cbWavError
		);
		set run=streamCmdRun i0;
		0
	)
	else if !strcmp key "SI" then
	(
		Secho "exec SI : "; Secholn val;
		// nomme le stream courant
		if gStreamingState then set gCurStreamName = val;
		// play next
		set run=cmdEvalOne i0+1;
		0
	)
	else if !strcmp key "SE" then
	(
		Secho "exec SE : "; Secholn val;
		// stoppe le stream courant s'il est nommÈ comme ca
		if gStreamingState && (!strcmp gCurStreamName val) then (
			wavstop;
			earStop 0;		
			stopStream
		);
		// play next
		set run=cmdEvalOne i0+1;
		0
	)
	else if !strcmp key "MS" then
	(
		Secholn "exec MS : "; Secho val;
		// Music Stream : streams the music (like ST), no choregraphy (assumed to be done by CH), not blocking (like MU)
		set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
		// starts the streamed music
		let rscfilterurl val -> music in wavstarthttp music #_cbWavError;
		// play next
		set run=cmdEvalOne i0+1;

		0
	)
	else if !strcmp key "MW" then
	(
		// wait for the end of music
		if wavrunning==0 then set run=cmdEvalOne i0+1;
		0
	)
	else if !strcmp key "CH" then
	(
		Secholn "exec CH : "; Secho val;
		msgchorstart (listswitchstr rscloaded val) #_cbGotoNextCmd i0;
		0
	)
	else if !strcmp key "IS" then
	(
		Secho "exec IS : "; Secholn val;
		// Start Interactive mode
		interactiveStart val;
		0
	)
	else if !strcmp key "IE" then
	(
		Secholn "exec IE : ";
		// Ends Interactive mode
		interactiveStop;
		0
	)
	else if !strcmp key "WT" then
	(
		Xw strcatlist "exec WT : " :: val :: nil ;
	// need to wait for val miliseconds, staying in interactive mode. at the end, program continues.
	// if button pressed, program stops.
	// if rfid detected, send info.
		set gProcessingWaitState = 1;
	  set interactiveWaitEndTime_ms = time_ms + (atoi val);
		set run =	waitCmdRun i0+1;
	  0
	)
	else
	(
		Secho key ; Secholn " : "; Secholn val;
		if !strcmp key "PL" then (set_current_palette_mode atoi val;0)
		else if !strcmp key "CL" then (
				let atoi val -> x in set_current_palette_color (x>>24) x&0xffffff;
				0)
		else if !strcmp key "IC" then (eval_IC_msg val;0)
		else (Secholn "unknown, dropping";0);
		
		// and skip command
		set run=cmdEvalOne i0+1;
		runEvalOneCommand i0+1
	);;

// R=60*((rand&127)+64)) => 64 ‡ 196 mn
// donc si x=30, (x*R)>>7 => 15 ‡ 45 mn
// donc si x=40, (x*R)>>7 => 20 ‡ 61 mn
// donc si x=80, (x*R)>>7 => 40 ‡ 122 mn
// donc si x=216, (x*R)>>7 => 108 ‡ 330 mn
// donc si x=255, (x*R)>>7 => 127 ‡ 390 mn, soit 2 ‡ 6,5h
var nexttaichi;;
fun dotaichinow=
	//Secho "checktaichi ";
	if infotaichi && (infotaichi != nil) && (!gSleepState) then let (if nexttaichi!=nil then (time>nexttaichi) else 0) -> now in (
		if now || nexttaichi==nil then // compute nexttaichi
		let if (infotaichi == 40) then 255 else if (infotaichi == 255) then 40 else 80 -> correctedTaichi in // etait inversÈ
		let ((correctedTaichi*60*((rand&127)+64))>>7) -> delaye in (
			Secho "taichi in "; Iecho delaye; Secholn "s";
			set nexttaichi=time+delaye
		);
		now
	) else (
		set nexttaichi=nil;
		0
	);;

fun runEarReset cb=
	if (!earResetting) then
		call cb []
	;;

fun _goSleepNow=
	// oreilles arrivÈes en haut : eteindre tout + oreille basses
	setleds RGB_BLACK;
	earGo 0 10 0; // sur le v2 c'est la position 10 qui est en bas
	earGo 1 10 0;
	set run=sleepRun
	;;
	
fun _wakeupNow=
	//Secholn "_wakeupNow";
	earsGoToRefPos;
	earSetWaitAndDetectMode;
	set run=idleRun
	;;
	
fun startSleep=
	Secholn "startSleep";
	let gSleepState -> sleeping in (
		set gSleepState = 1;
		set gStreamingState = 0; // just to be sure
		set gProcessingState = 0; // just to be sure
		// server resource
		let XmppSessionRequestResource "asleep" -> result in (
			// Starts to sleep
			Secholn "going asleep";
			if sleeping == 0 then (
				setleds RGB_VIOLET;
				earStartReset // oreilles en haut
			);
			set run = earResetWaitRun #_goSleepNow; // attente de fin oreille
			result
		)
	)
	;;

fun endSleep=
	Secholn "endSleep";
	if (gSleepState) then (
		// was asleep or initial booting (gSleepState = 1 at start)
		set gSleepState = 0;
		set gStreamingState = 0; // just to be sure
		set gProcessingState = 0; // just to be sure
		let XmppSessionRequestResource "idle" -> result in (
			setleds RGB_VIOLET; // violet
			earStartReset; // reset oreilles
			set run = earResetWaitRun #_wakeupNow; // attente de fin oreille
			result
		)
	) else (
		// was not asleep (after a reconnect for example)
		let (
			if (gStreamingState) then XmppSessionRequestResource "streaming"
			else if (gItState) then XmppSessionRequestResource "itmode"
			else XmppSessionRequestResource "idle") -> result in (
			set run=idleRun;
			result
		)
	)
	;;

// ******************************************
// Main function : evaluate trame
// trames are sent back from ping and itmode
// a trame contains frames
// a frame can:
// - change the ping delay (type 3)
// - order 'reboot' (type 9)
// - contain new service values and ear positions (type 4)
// - contain a program (type 10)
// In program frames, programs can contain url resources: resources are loaded and stored and then program is executed
// Return the XMPP packet(s) to send or nil.

fun evalTrame ping_trame=
	Secholn "evalTrame >>";
	Secholn ping_trame;
	Secholn "<<";
	let pingextract dump ping_trame -> frame_list in
	if frame_list==nil then (
		// error, bad trame
		Secholn "bad trame";
		dump ping_trame;
		Secholn "dropping";
		if (gItState) then (
			// display error
			interactiveError;
			nil
		) else (
			// drop, and ping again later
			set run=idleRun;
			nil
		)
	) else (
		// frame_list ok
		let nil->xmpp_packets in
		let nil->program in
		(
			for l=frame_list;l!=nil;tl l do let hd l-> [code val] in
			(
				let (if code == 3 then (
					// ping delay
					Secholn "dropping ping delay";
					nil
				) else if code == 4 then (
					// update sources, messages number and ears
					let ((strget val 3) == 0xFF) -> fromHttp in
					if fromHttp then (
						// old format
						infoUpdate strsub val 4 nil;
						dumpStatus;
						nil
					) else (
						// new format
						newInfoUpdate strsub val 4 nil;
						dumpStatus;
						nil
					)
				) else if code == 9 then (
					// reboot
					reboot 0x0407FE58 0x13fb6754;
					nil
				) else if code == 10 then (
					// programs (or IDLE or SLEEP)
					uncrypt val 1 nil 0x47 47;
					set program=dump_prgm filterconfig val 1;
					nil
				) else if code == 11 then (
					// change mode
					let strget val 0 -> mode in (
						Secho "changemode = "; Iecholn mode;
						if (mode == 0) then endSleep
						else if (mode == 1) then startSleep
						else nil
					)
				) else (Secho "Unknown code "; Iecho code; Secholn ""; nil)) -> xmpp_packet_list in
				if (xmpp_packet_list != nil) then
					set xmpp_packets = xmpp_packet_list::xmpp_packets
				else
					xmpp_packets
			); // for l=frame_list

			// post process : a program ?
			if program!=nil then (
				// Initialize Program
				set paletteselected = 0;
				set gCurrentProgram = program;
				set gProcessingState = 1;
				set gProcessingWaitState = 0;
				CheckForPaletteBefore program; // Permet de mettre la palette correspondante au programme, v17 (add romain)
				// resources
				set rsctoget=rscFromProgram program;
				// empties the rsc cache
				set rscloaded=nil;
				let hd rsctoget -> [url _] in
				if url==nil then (
					// no resources to load : start the program now
					prgmStart;
					0
				) else (
					// will load rsctoget and then start the program 'gCurrentProgram'
					Secho "loading rsrcs...";
					set run = rscLoadNextRun;
					0
				)
			);
			xmpp_packets
		) // nil->program
	) // frame_list != nil
	;;


//*******************
// Trames queue
var gTramesQueue = nil;;
const TRAME_QUEUE_MAXLEN = 10;;

fun _isResourceValid rsrcName=
	// les rËgles d'adÈquation entre resource et etats
	if (!strcmp rsrcName "urgent") then 1 // tjrs
	else if (!strcmp rsrcName "sources") then 1 // tjrs
	else if (!strcmp rsrcName "boot") then 1 // tjrs
	else if (gStreamingState) then (if (!strcmp rsrcName "streaming") then 1 else 0)
	else if (gItState) then (if (!strcmp rsrcName "itmode") then 1 else 0)
	else if (gSleepState) then (if (!strcmp rsrcName "asleep") then 1 else 0)
	else if (gProcessingState) then 0
	else 1;;

fun _queueTrameRemoveEntry binome=
	// dÈpile
	set gTramesQueue = remfromlist gTramesQueue binome;
	
	// was full ?
	let listlen gTramesQueue -> queueLen in
	if queueLen == TRAME_QUEUE_MAXLEN-1 then (
		Secholn "trame queue not full anymore, warning server";
		set gBusyState = 0;
		// which resource now ? Can be in this order asleep, streaming, itmode or idle
		if (gSleepState) then XmppSessionRequestResource "asleep"
		else if (gStreamingState) then XmppSessionRequestResource "streaming"
		else if (gItState) then XmppSessionRequestResource "itmode"
		else XmppSessionRequestResource "idle"
	);
	0;;

fun getNextValidPendingTrame=
	let gTramesQueue -> ptr in
	let nil -> theTrame in (
		while ((theTrame == nil) && ((hd ptr) != nil)) do (
			let hd ptr -> binome in
			let binome -> [rsrc expiration_time ping_trame] in
			if ((expiration_time != nil) && (time >= expiration_time)) then (
				Secholn "trame expired, removing";
				_queueTrameRemoveEntry binome
				
			) else if (_isResourceValid rsrc) then (
				// ok
				set theTrame = ping_trame;
			
				_queueTrameRemoveEntry binome
			);
			
			// next
			set ptr = tl ptr
		);
		theTrame
	)
	;;



fun processIncomingTrame ping_trame rsrc ttl=
	Secho "processIncomingTrame for "; Secholn rsrc;
	if (_isResourceValid rsrc) then (
		evalTrame ping_trame
	) else (
		Secholn "enqueueing trame";
		let if (ttl == nil) then nil else (time + (atoi ttl)) -> expiration_time in
			set gTramesQueue = conc gTramesQueue [rsrc expiration_time ping_trame]::nil;
		
		// full ?
		let listlen gTramesQueue -> queueLen in
		if queueLen >= TRAME_QUEUE_MAXLEN then (
			Secholn "trame queue full, warning server";
			set gBusyState = 1;
			(XmppSessionRequestResource "busy")::nil
		) else (
			nil
		)
	)
	;;


fun runLogin=
	// if trame waiting, execute it
	let getNextValidPendingTrame -> trame in 
	if trame != nil then
		evalTrame trame;;

fun runIdle=
	// if trame waiting, execute it
	let getNextValidPendingTrame -> trame in 
	if trame != nil then (
		evalTrame trame;
		0
	) else (
		set gProcessingState = 0;
		if dotaichinow then (
			taichistart;
			0
		)
	);
	0
;;


var gWasNetActivity = 0;;
fun noseled=
	if !earDetecting then
	// led tete clignote if netactivity or wav_buffering // 
	let uploading || (match run with (rscLoadWaitRun _-> 1)|(interactiveReqWaitRun _->1)|(_->0)) -> netactivity in
	if (netactivity || wav_buffering) then (
		let if netactivity then 256 else if wav_buffering then 128 else 0 -> speed in
		if speed > 0 then led LED_NOSE (if time_ms&speed then RGB_RED else 0);
		set gWasNetActivity = 1
	) else if (gWasNetActivity) then (
		// show off the light
		led LED_NOSE RGB_BLACK;
		set gWasNetActivity = 0
	);
	0;;

fun bottomled=
	if gSleepState == 0 then 
	if !earDetecting then
		(let osc time_ms>>4 -> v in led LED_BASE v*0x10001); // pulse violet
	0;;
	

// ********** RFID **********************
// v19 AmÈlioration de la lecteure RFID
// v19 Les fonction ParseRfid servent ‡ tester les caractËres de l'identifiant RFID
var lastrfid;;
var RFIDchar = 2;; // v19
var RFIDint = 6;; // v19
var RFIDchek = 0;; // v19
var RFIDlast = 0;; // v19

var tmptps = 0;;
	
fun _cbrfidhttp http res=
	Secholn "Recv rfid:"; Secho res;
	set gProcessingState = 0;
	set RFIDchek = 0;
	let httpgetcontent res -> ping_trame in
		evalTrame ping_trame;
	0;;

fun dumprfid l0=
	for l=l0;l!=nil;tl l do let hd l->x in Secholn webmac x;
	l0;;

fun ParseRfidChar id index= // v19
	set RFIDchar = strget id index;
	RFIDchar;;

fun ParseRfid id = // v19
	set RFIDint = 6;
	for i=0;i<6 do ( if(ParseRfidChar id i) == 0 then set RFIDint = RFIDint - 1);
	RFIDint;;

/**
	Sets RFIDchek = 0
*/
fun zeroRFIDchek =
	set RFIDchek = 0;;


// *************** CONTROLS *************

fun _cbrfidendchor unused=
	// continue idle
	set run=idleRun;
	0
	;;


/**
	Controls if a stamp is shown to the rabbit.
	Does not control wether we _should_ control or not (according to the interactive state, ...)

	Returns the rfid or nil.
*/
fun checkRfidPresence=
	let rfidGet -> rfid in
	if (strcmp rfid lastrfid) && (RFIDchek == 0) && (time_ms - RFIDlast > 750) then
		rfid
	else
		nil	
;;

fun controlrfid=
//	let hd dumprfid rfidGetList -> rfid in
	if ((!gItState) // disabled when interactive except ...
      || (gItState && ((g_int_mask & MASK_RFID == 0) || (gProcessingState && gProcessingWaitState)))) then // enabled when mask set or executing a waiting command
(
	if ((time_ms - RFIDlast) > 1000) then
	(
		set lastrfid = "0000000"
	);
	let checkRfidPresence -> rfid in
	if rfid!=nil then
	(
		if (ParseRfid rfid) !=0 then
		(
			set lastrfid=rfid;
			set RFIDchek = 1;
			set RFIDlast = time_ms;
			controlsound midi_RFIDok;

			// lancer l'animation (v19)
			msgchorstart chor_RFIDok::nil #_cbrfidendchor nil;
			set chortimescale=10; // recopiÈ d'avant, mas pourquoi ? NÈcessaire ? [AS 24oct07]				

			set gProcessingState = 1;
			if (gItState) then
				interactiveSendRfid rfid
			else
				(httprequest "GET" rfidurl rfid nil #_cbrfidhttp HTTP_NORMAL ; 0)
		)
	)
	)
;
	0;;

fun controlplay=
	let buttongetevent -> ev in
	if ev!=nil then (
		Secholn "controlplay";
		wavstop;
		earStop 0;
		let atoi listswitchstr gCurrentProgram "ID" -> id in
			if ev==BUTTON_CLIC then	(controlsound midi_abort; if (gStreamingState) then stopStream; endOfProgram 0; XmppSessionSendButtonMsg ev 1 id) //pause  
			else if ev==BUTTON_DCLIC then (controlsound midi_ack;if (gStreamingState) then stopStream; endOfProgram 0; XmppSessionSendButtonMsg ev 1 id) //ackall
			else if ev==BUTTON_LCLIC then nil //pause ou record ? callPingRequest 5
	)
	;;

fun controlwait=
	let buttongetevent -> ev in
	let if ev==nil then eargetevent else ev -> ev in
	if ev!=nil then
	(
		Secho "controlwait ev="; Iecholn ev; 
		wavstop;
		earStop 0;
		if ev==BUTTON_CLIC then ( XmppSessionSendButtonMsg ev 0 nil) // debug
		else if ev==BUTTON_DCLIC then (controlsound midi_ack;XmppSessionSendButtonMsg ev 0 nil) //ackall
		else if ev==BUTTON_LCLIC then _controlrecord 0	//  //back ou record
		else if ev==BUTTON_DLCLIC then _controlrecord 1	// //back ou record
		else if ev&0x8000 then (
			// oreilles
			controlsound midi_acquired;
			let (ev-0x8000)&0xFF00>>8 -> leftpos in
			let (ev-0x8000)&0xFF -> rightPos in (
				// remember for after sleep, etc...
				set extleft=leftpos;
				set extright=rightPos;
				XmppSessionSendEarMsg leftpos rightPos
			);
			0
		) 
	);
	controlrfid
	;;

fun controlinteractif=
	let buttongetevent -> ev in
	if ev!=nil then
	(
		Secholn "controlinteractif";
		if ev==BUTTON_CLIC || ev==BUTTON_DCLIC then	(
			if (g_int_mask&MASK_BUTTON == 0) then interactiveSendBtn ev
		) else if ev==BUTTON_LCLIC then (
			if (g_record_enabled) then (
				// remember wav position and start record
				set gInteractiveLastWavBytes = wav_curplayedbytes ;
				_controlrecord 0
			) else (
				// like BUTTON_CLIC
				set ev = BUTTON_CLIC;
				if (g_int_mask&MASK_BUTTON == 0) then interactiveSendBtn ev	
			)
		)
	);
	controlrfid
	;;

/*
	Utilise dans le cas ou on execute un programme et qu'on est en train
  d'executer une commande "WT". En gros on a un comportement normal
  sauf qu'on lit les rfid en plus
*/
fun controlprogramwait =
	(if (!gItState) then controlplay else controlinteractif) ;
 	controlrfid
;;

fun dumpStatus=
	Secholn "//--- status ---";
	Secho "earDetecting="; Iecholn earDetecting;
	Secho "gSleepState="; Iecholn gSleepState;
	Secho "gStreamingState="; Iecholn gStreamingState;
	Secho "gProcessingState="; Iecholn gProcessingState;
	Secho "gBusyState="; Iecholn gBusyState;
	Secho "gItState="; Iecholn gItState;
	Secho "gItApp="; Secholn gItApp;
	Secholn "//--- end status ---"
	;;

const CONTROL_WAIT=1;;
const CONTROL_PLAY=2;;
const CONTROL_INTERACTIF=3;;
const CONTROL_PROGRAMWAIT=4;;


fun getRunState =
	run;;

fun setRunState runState =
	let run -> oldRun in (
		set run = runState;
		oldRun
	);;


/**
	Stop everything we can be doing and resets to either idle or asleep
 */
fun stopEverythingAndResetToIdle =
	wavstop;
	stopStream;
	earStartReset;
	set gItState = 0;
	set g_cookie = "";
	set gItApp = nil;
	set gProcessingState = 0;
	set gStreamingState = 0;
	set gCurrentProgram = nil;
	set run = if (!gSleepState) then idleRun else sleepRun;
	0
;;


fun loop=
//Secho "l";
	wifiRun;

	if netState==RT2501_S_IDLE then
	match wifi with
	(initW -> nil)
	|(_ ->
		Secholn "######### wifi lost";
		set wifi=reconnectW;
		earStop 1; // make sure that ears are not moving while we're reconnecting.
		0
	);

	buttonloop;
//	buttongetevent;
	let match run with
	( configstartRun -> earRun;runconfigstart;0 )|
	( configwaitRun http -> earRun;runconfigwait http ; 0)|
	( xmppLoginRun ->
		if (earResetting && earsInited) then earRun else earStop 1;
		runLogin;
		CONTROL_WAIT) |
	( xmppReconnectRun params ->
		if (earResetting && earsInited) then earRun else earStop 1;
		if gSleepState == 0 then (
			// Affichage des sources.
			infoRun;
			// On fige la base en violet
			led LED_BASE RGB_VIOLET	
		);
		let params -> [waitTime xSession oldRun] in 
			match xSession.sStatus with
				(sOpened -> set run = oldRun; 0)
				|(sClosed -> 
					if time_ms > waitTime then (
						XmppGateReconnect xSession 0
					);
					0)
				|(_ -> 0);
		CONTROL_WAIT)|

	( idleRun -> earRun;infoRun;bottomled;noseled;runIdle;CONTROL_WAIT) |
	( sleepRun -> earRun;runIdle;0) |
	
	( rscLoadNextRun -> earRun;infoRun;bottomled;noseled;runRscLoadNext; CONTROL_WAIT)|
	( rscLoadWaitRun http-> earRun;infoRun;bottomled;noseled;runRscLoadWait http;CONTROL_WAIT)|
	( cmdEvalOne i-> earRun;runEvalOneCommand i;CONTROL_PLAY)|
	( chorCmdRun i-> earRun;noseled;runChorCmd i;CONTROL_PLAY)|
	( streamCmdRun i0-> earRun;noseled;runStreamingCmd i0;CONTROL_PLAY)|
	( waitCmdRun i -> earRun;noseled;runWaitCmd i;CONTROL_PROGRAMWAIT)|

	( earResetWaitRun cb -> earRun; runEarReset cb; 0) |

	( recordRun -> runrecord; 0)|
	( recordStartRun -> runrecordstart; 0) |

	( interactiveReqWaitRun http-> earRun;infoRun;bottomled;noseled;runInteractiveReqWait http;CONTROL_WAIT)
	 -> keymanager in
	if keymanager==CONTROL_WAIT then
		controlwait
	else if keymanager==CONTROL_PLAY then
		(if (!gItState) then controlplay else controlinteractif)
	else if keymanager==CONTROL_PROGRAMWAIT then
		controlprogramwait
	else
		buttongetevent
	;

	XmppSessionRun; // On envois Èventuellement les packets en attente	
	XmppSessionIdle;
	uploadtimeout;

	checkdhcp 0;

	// if ears touched while interactive : process it
	interactiveEarProcessTouched;

	wavtime;

	updatevol;
	0;;

fun main=
	leds_set_state LEDS_STATE_START ;
	//ResetXmppPassword; // DEBUG
	MACecho netMac 0 1;
	set master=0;
	Secholn ":started";
	confInit;
	wifiInit 0;
	loopcb	#loop;
	infoInit;
	netstart;
	startdnsclient;
	startdhcp;
	Secholn ":done";
	srand time_ms;
	updatevol;
//	wavstartlocal midi_endrecord::nil;
	dumpscan wifiscans;
	runinit;
	set gInteractiveSounds = [intDefaultStart intDefaultStop]; // Default Sounds of InteractiveMode
	set gInteractiveChors = [intchorDefaultStart intchorDefaultStop]; // Default Sounds of InteractiveMode
	0;;

